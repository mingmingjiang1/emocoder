

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/emocoder/img/fluid.png">
  <link rel="icon" href="/emocoder/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="迷途知返">
  <meta name="keywords" content="">
  
    <meta name="description" content="Introduction Regular languages  The weakest formal languages widely used Many applications  正则表达式的缺陷：    Parser：  Input: sequence of tokens from lexer Output: parse tree pf the program  12345678Cool:">
<meta property="og:type" content="article">
<meta property="og:title" content="斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)">
<meta property="og:url" content="https://mingmingjiang1.github.io/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/index.html">
<meta property="og:site_name" content="迷途知返">
<meta property="og:description" content="Introduction Regular languages  The weakest formal languages widely used Many applications  正则表达式的缺陷：    Parser：  Input: sequence of tokens from lexer Output: parse tree pf the program  12345678Cool:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-10T10:06:16.000Z">
<meta property="article:modified_time" content="2023-06-19T15:28:22.565Z">
<meta property="article:author" content="迷途知返">
<meta property="article:tag" content="编译原理，计算机基础，cool">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis) - 迷途知返</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/emocoder/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/emocoder/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/emocoder/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mingmingjiang1.github.io","root":"/emocoder/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/emocoder/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/emocoder/js/utils.js" ></script>
  <script  src="/emocoder/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/emocoder/">
      <strong>Emoer</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/emocoder/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-10 18:06" pubdate>
          2023年6月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          113 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="introduction">Introduction</h2>
<p>Regular languages</p>
<ul>
<li>The weakest formal languages widely used</li>
<li>Many applications</li>
</ul>
<p>正则表达式的缺陷：</p>
<ul>
<li></li>
</ul>
<p>Parser：</p>
<ul>
<li>Input: sequence of tokens from lexer</li>
<li>Output: parse tree pf the program</li>
</ul>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">Cool:<br>	<span class="hljs-keyword">if</span> x = y then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> fi<br>Parser <span class="hljs-keyword">input</span>:<br>	<span class="hljs-keyword">IF</span> ID = ID THEN <span class="hljs-keyword">INT</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">INT</span> FI<br>Parser output:<br>		 <span class="hljs-keyword">IF</span>-THEN-<span class="hljs-keyword">ELSE</span><br>	=      <span class="hljs-keyword">INT</span>      <span class="hljs-keyword">INT</span><br>ID ID    <br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>Phase</th>
<th>Intput</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Lexer</td>
<td>String of characters</td>
<td>String of tokens</td>
</tr>
<tr class="even">
<td>Parser</td>
<td>String of tokens</td>
<td>Parse tree</td>
</tr>
</tbody>
</table>
<blockquote>
<p>上面两步有的编译器是分开做的，有的编译器是放在一起做的</p>
</blockquote>
<h2 id="上下无关文法">上下无关文法</h2>
<p>由词法分析器得到的tokens并不全是有用的，比如标点符号，所以编译器必须识别哪些是有效token，哪些是无效的，我们需要一种描述规则来描述何为有效token，以及一种识别有效token的方法</p>
<p>程序语言都是有着nested(递归)的结构，如：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">EXPR = <span class="hljs-keyword">if</span> <span class="hljs-keyword">EXPR</span> then <span class="hljs-keyword">EXPR</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">EXPR</span> fi<br>	<span class="hljs-keyword">while</span> <span class="hljs-keyword">EXPR</span> loop <span class="hljs-keyword">EXPR</span> pool<br></code></pre></td></tr></table></figure>
<p><strong>上下无关文法据说一种描述这种递归结构的natural
notation</strong></p>
<p>CFG 由下面几部分构成：</p>
<ul>
<li>a set of terminals: <span class="math inline">\(T\)</span></li>
<li>a set of nn-terminals: <span class="math inline">\(N\)</span></li>
<li>a start symbol: <span class="math inline">\(S (S \in
N)\)</span></li>
<li>a set of productions:$ X -&gt; Y_1, ... Y_N (X N, Y_i N T {})$</li>
</ul>
<ol type="1">
<li>Begin with a string with only the start symbol S</li>
<li>Replace any non-terminal X in the string by the right-hand side of
some production</li>
<li>Repeat (2) until there are non-terminals</li>
</ol>
<p>let G be a contexto-free grammar with start symbol S. Then the
language L(G) of is: <span class="math display">\[
\{ a_1, ... a_n \quad | \quad \forall_i \quad a_i \in T \and S
\mathop{\rightarrow}^* a_1, ..., a_n \}
\]</span></p>
<ul>
<li>Terminals are so-called because there are no-reulses for replacing
them 终结符是不变的</li>
<li>Once generated, terminals are permanent，终结符是不变的</li>
<li>Terminals ought to be tokens of the language
(终结符一般是语言的token，比如关键字，标识符)</li>
</ul>
<p>🌰：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">E -&gt; E + E<br>	 | E * E<br>	 | (E)<br>	 |<span class="hljs-built_in"> id</span><br>	 <br>对应的语言：<span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span> *<span class="hljs-built_in"> id</span><br><span class="hljs-built_in">(id</span> +<span class="hljs-built_in"> id</span>) *<span class="hljs-built_in"> id</span><br></code></pre></td></tr></table></figure>
<p>整个CFG是一个很大的步骤，需要：</p>
<ul>
<li>Membership in a alnguage is yes or no, also parse tree of the
input</li>
<li>Must handle errors gracefully</li>
<li>Need an implementation of CFG's (eg: bison)</li>
</ul>
<h2 id="derivations推导">Derivations(推导)</h2>
<p>A derivations s a <strong>sequence</strong> f production: <span
class="math display">\[
S -&gt; .. -&gt; ,,, -&gt; ... -&gt; ..
\]</span> 推导过程可以以树的形式画出来：</p>
<ul>
<li>start symbol is the tree's root</li>
<li>For a production <span
class="math inline">\(X-&gt;Y_1Y_2..Y_n\)</span> add children <span
class="math inline">\(Y_1Y_2...Y_n\)</span> o node X</li>
</ul>
<p>考虑下面语法： <span class="math display">\[
E → E + E |  E * E | (E) | id
\]</span> 以及字符串：id * id + id</p>
<figure>
<img
src="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617134603437.png" srcset="/emocoder/img/loading.gif" lazyload
alt="image-20230617134603437" />
<figcaption aria-hidden="true">image-20230617134603437</figcaption>
</figure>
<p>A parse tree has</p>
<ul>
<li>Terminals at the leaves</li>
<li>Non-terminals at the interior nodes</li>
</ul>
<blockquote>
<p>对叶子节点的in-order遍历就是原始输出，parse
tree表示了token之间的各种关系</p>
<p>如下：</p>
<p>叶子节点从左到右：就是原始输入：id * id + id</p>
<p>中间节点和左右兄弟节点的关系也很明确，*的左右就是id</p>
</blockquote>
<p>上述推导式的产生是left-most，即在每一步优先推导最左边的符号（即推导方向是自左向右），但是这样可能会出现没有结束条件而一直无限推导下去。还有一种与之类似的right-most
推导</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">E<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + E</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">id</span> * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>Note that r-most and l-most derivations have the same parse tree</p>
<p>A derivations defines a parse tree, but one parse tree may have many
derivations</p>
<p>一个Parse tree
可能有很多种推导方式可以得到，但是最左推导和最右推导是最重要的两种方式</p>
</blockquote>
<p><strong>Conclusion</strong>:</p>
<ul>
<li>不仅对某个字符串是否属于L(G)(语法G所产生的语言)感兴趣，也需要对应的解析树</li>
<li>一个推导式定义了一个解析树（或者解析树的一部分），同一个Parse tree
可能有很多种推导方式可以得到</li>
</ul>
<h2 id="ambiguity语法的二义性">Ambiguity(语法的二义性)</h2>
<h3 id="解析优先级">解析优先级</h3>
<p>Grammar: E -&gt; E + E | E * E | (E) | id</p>
<p>String stream: id * id + id</p>
<p>不同的推导得到不同的parse tree：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">		<span class="hljs-built_in">E</span><br>	<span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">id</span><br><span class="hljs-variable">id</span>  <span class="hljs-variable">id</span> <br><br>		<span class="hljs-built_in">E</span><br>	<span class="hljs-built_in">E</span>  <span class="hljs-operator">*</span>  <span class="hljs-built_in">E</span><br>  <span class="hljs-variable">id</span>  <span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br>		 <span class="hljs-variable">id</span>   <span class="hljs-variable">id</span> <br></code></pre></td></tr></table></figure>
<blockquote>
<p>A grammar is ambiguous if it has more than one parse tree for some
string, 换句话说，对于某些字符串，可以由超过一种的做作或最右推导方式</p>
</blockquote>
<p><strong>How to handle ambiguous</strong></p>
<p>Method 1:</p>
<p>重写语法：其实本质上是强制了解析时候的优先级</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E -&gt; <span class="hljs-string">E&#x27; + E/E&#x27;</span><br><span class="hljs-string">E&#x27; -&gt; id * E&#x27;</span> | id | (E) * <span class="hljs-string">E&#x27;| (E) </span><br></code></pre></td></tr></table></figure>
<p>Method 2：</p>
<p>不重写，但是在解析的时候，使用优先级或者判断哪个是最优的</p>
<h3 id="结合性">结合性</h3>
<h2 id="parsing-error-handleparser过程的错误处理">Parsing Error
Handle(parser过程的错误处理)</h2>
<table>

<thead>
<tr class="header">
<th>Error kind</th>
<th>Example</th>
<th>Detected by</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Lexical</td>
<td>使用了未知符号，比如else写成了eles</td>
<td>Lexer</td>
</tr>
<tr class="even">
<td>Syntax</td>
<td>编写的程序存在结构错误，比如while后面应该有一对{},
但是只写了一个{</td>
<td>parser</td>
</tr>
<tr class="odd">
<td>Semantic</td>
<td>int x; x(3);声明x为普通变量，但是却把x当成函数使用</td>
<td>Type Checker</td>
</tr>
<tr class="even">
<td>Correctness</td>
<td>自己的代码虽然通过了编译器，但是运行结果不符合预期</td>
<td>User/Tester，一般需要自己debug</td>
</tr>
</tbody>
</table>
<p>Error handler should:</p>
<ul>
<li>Report errors accurately and clearly</li>
<li>Recover from an error quickly</li>
<li>Not slow down compilation of valid code</li>
</ul>
<p>常见的三种不同错误处理模式：</p>
<ul>
<li>Panic Mode (使用特殊的终止符(error)吃掉错误，继续执行)
<ul>
<li>When an error is detected
<ul>
<li>Discard tokens until one with clear role is found</li>
<li>Continue from here</li>
</ul></li>
</ul></li>
</ul>
<p>​ 🌰：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">(1 + + 2) + 2<br><span class="hljs-keyword">skip </span>ahead to next interger and then continue<br></code></pre></td></tr></table></figure>
<p>Bison: use the special terminal error to descide how mucg input to
skip</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">E -&gt; int | <span class="hljs-type">E</span> + E | <span class="hljs-type">(E</span>) | <span class="hljs-type">error</span> int | <span class="hljs-type">(error</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><p>Error productions (添加可能的错误的推导式): specify known common
mistakes in the grammar</p>
<p>Eg: write 5 x instead of 5 * x</p>
<p>Add production E -&gt; .... | E E</p>
<p>Disadvantage: complicates the grammar</p></li>
<li><p>Automatic local or global correction</p>
<ul>
<li>Find a correct "nearby" program
<ul>
<li>try token insertions and deletions (编辑距离)</li>
<li>exhaustive search</li>
</ul></li>
<li>Disadvantages:
<ul>
<li>hard to impl</li>
<li>slows down parsing of correct programs</li>
<li>"nearby" is not necessarily "the intended" program</li>
</ul></li>
</ul></li>
</ul>
<p>Past:</p>
<ul>
<li>Slow recompilation cycle (even once a day)</li>
<li>rind as many errors in one cycle as possible</li>
</ul>
<p>Present:</p>
<ul>
<li>Quick recompilation cycle</li>
<li>users tend to correct one error/cycle</li>
<li>Complex error recovery is less compelling</li>
</ul>
<h2 id="another-clean-parse-tree-form-ast">Another Clean Parse Tree Form
—— AST</h2>
<p>Parser跟踪(trace)一个token序列的推导过程，并由此产生Parse tree</p>
<p>🌰：</p>
<p>Grammar: E -&gt; int | (E) | E + E</p>
<p>After lexical analysis: [Int(2), '+', '(', Int(1), '+', 'Int(5),
')']</p>
<p>Parse Tree:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">	E<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) (E)<br>		E + E<br>		<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>AST：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br>				<span class="hljs-built_in">Int</span>(<span class="hljs-number">2</span>)  <span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br>												<span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">Int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>被称之为AST，因为它从具体语法中抽象出来，煎炒了具体语法的细节；而Parse
Tree展示了具体的推导规则和相关结构，对于编译器来水说，有很多不必要的内容</p>
<h3 id="递归下降解析">递归下降解析</h3>
<p>解析树一般按照如下方式构建：</p>
<ul>
<li>自上至下</li>
<li>从左到右</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">		<span class="hljs-number">1</span><br><span class="hljs-built_in">t2</span>. <span class="hljs-number">3</span>.  <span class="hljs-built_in">t9</span><br>   <span class="hljs-number">4</span>. <span class="hljs-number">7</span> <br>  <span class="hljs-built_in">t5</span>. <span class="hljs-built_in">t6</span>.  <span class="hljs-built_in">t8</span><br></code></pre></td></tr></table></figure>
<p>Tokens: [t2, t5, t6, t8, t9]</p>
<p>看一个详细的递归下降解析的🌰：</p>
<p>考虑语法Grammar:</p>
<p>E -&gt; T | T | T + E</p>
<p>T -&gt; int | int * T | (E)</p>
<p>输入：<span class="math inline">\((int_5)\)</span></p>
<p>步骤：</p>
<p>从起始菲终结符开始，依次尝试关于E的推导式</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-type">E</span> -&gt; <span class="hljs-type">T</span> -&gt; <span class="hljs-built_in">int</span> (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br>		 <span class="hljs-type">T</span> -&gt; [<span class="hljs-built_in">int</span> * <span class="hljs-type">T</span>] (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br>		 <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符<span class="hljs-built_in">int</span> =&gt;<br>		 <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> -&gt; <span class="hljs-built_in">int</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符) =&gt;<br></code></pre></td></tr></table></figure>
<p>递归下降解析算法的一般定义如下：</p>
<p>首先定义几个关于是否符合某个匹配的函数：</p>
<ul>
<li><p>是否为终结符：</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">bool</span> <span class="hljs-title function_">term</span>(<span class="hljs-params">TOKEN</span> <span class="hljs-params">tok</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-operator">*</span><span class="hljs-variable">next</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">==</span> <span class="hljs-variable">tok</span>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>是否为lfs为S第n个推导式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Sn</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>是否为lfs为S的推导式</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">S</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>🌰：</p>
<ul>
<li><p>E -&gt; T: bool E1() { return T() }</p></li>
<li><p>E -&gt; T + E: bool E2() { return T() &amp;&amp; term(PLUS)
&amp;&amp; E() }</p></li>
<li><p>对于整个E来说：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">bool E() &#123;<br>	TOKEN *<span class="hljs-built_in">save</span> = <span class="hljs-built_in">next</span>;<br>	return (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E1()) || (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E2());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>同样的对于上面的非终结符T，有：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T1</span>()</span> &#123;<br>	<span class="hljs-keyword">return</span> term(INT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T2</span>()</span> &#123;<br>	<span class="hljs-keyword">return</span> term(INT) &amp;&amp; term(TIMES) &amp;&amp; T();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T3</span>()</span> &#123;<br>	<span class="hljs-keyword">return</span> term(OPEN) &amp;&amp; E() &amp;&amp; term(CLOSE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T</span>()</span> &#123;<br> 	TOKEN *save = next;<br>	<span class="hljs-keyword">return</span> (next = save, T1()) || (next = save, T2() || (next = save, T3()));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整个步骤：</p>
<ul>
<li>初始化next为第一个token</li>
<li>调用E()</li>
</ul>
<p><strong>Conslusion</strong>:</p>
<p>递归下降过程中，不断地递归合回溯所产生的函数调用结构其实就是解析树的体现，所以在递归下降的同时构建AST。</p>
<h3 id="上面的递归下降算法的限制">上面的递归下降算法的限制：</h3>
<p>对于E -&gt; T | T | T +
E，一旦递归到了T，并且从继续向下递归，一旦不符合了，只会在当前层级尝试其他的推导式，但是不会基于T的同层级去尝试T和T+E</p>
<p>所以上面的普通的递归下降只适用于一部分语法，对于有些不符合的语法，可以采用左因子(left-factor)进行改写：</p>
<h3 id="左递归">左递归</h3>
<p>考虑产生式：S -&gt; S a</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">bool <span class="hljs-built_in">S1</span>() &#123; return <span class="hljs-built_in">S</span>() &amp;&amp; <span class="hljs-built_in">term</span>()&#125;<br>bool <span class="hljs-built_in">S</span>() &#123; return <span class="hljs-built_in">S1</span>()&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用递归下降，会产生如下的调用链条：S =&gt; S1 =&gt; S =&gt; S1
=&gt; ...</p>
<p>这就是左递归语法</p>
<p>以下是左递归语法更一般的定义： <span class="math display">\[
S \mathop{\rightarrow}^+ S\alpha (+表示至少有一次推导)
\]</span> 再看这个🌰： <span class="math display">\[
S \rightarrow S\alpha | \beta
\]</span> 将会产生以<span class="math inline">\(\beta\)</span>
开头的且<span class="math inline">\(\beta\)</span>
后面紧跟任意数量(&gt;=0)<span
class="math inline">\(\alpha\)</span>的字符串。</p>
<p>既然已经知道了会产生什么样的字符串，可以通过把文法改写成右递归避免递归下降产生的左递归问题：
<span class="math display">\[
S \rightarrow \beta S&#39; \\
S&#39; \rightarrow \alpha S&#39; | \epsilon
\]</span> Conclusion：</p>
<p>一般的递归下降是从左到右解析，由于该算法的性质，遇到做递归文法会导致无穷递归；可以通过把左递归文法改成特殊(这里的右递归文法也仅仅适用于部分语法)的右递归文法避免这个问题，因为这个时候非终结符在最右边，不会有右边字符存在一直饥饿(一直访问不到)的现象。</p>
<p>更一般的，可以改写成如下特殊的右递归文法： <span
class="math display">\[
S&#39; \rightarrow S\alpha_1 | ... | S\alpha_n | \beta_1|...|\beta_m
\]</span></p>
<p><span class="math display">\[
S \rightarrow \beta_1 S&#39;| ... | \beta_m S&#39; \\
S&#39; \rightarrow \alpha_1 S&#39; | ... | \alpha_nS&#39; | \epsilon
\]</span></p>
<p>但是有些语法，如： <span class="math display">\[
S \rightarrow A\alpha | \beta \\
A \rightarrow S \beta
\]</span> 这个语法也是左递归语法，写成如下形式更好理解： <span
class="math display">\[
S \mathop{\rightarrow}^+ S \beta \alpha
\]</span> 可以通过其他方式消除左递归。</p>
<p>继续top-down</p>
<h3 id="预测">预测</h3>
<p>Predicive Parsers like recursive-descent but parser can
<strong>"predict"</strong> which production to use:</p>
<ul>
<li>By looking at the next few tokens</li>
<li>No backtracking</li>
</ul>
<p>Predicive Parsers accept LL(k) grammars (1st L: left 2 right, 2nd L:
left-most derivation, k: k tokens look ahead)</p>
<p>在递归下降算法里：</p>
<ul>
<li>每一步，有很多产生式可以使用，如：E -&gt; T | T | T +
E，对于E，有3种选择</li>
<li>需要通过回溯撤销bad choices</li>
</ul>
<p>LL(1):</p>
<ul>
<li>通过改写成合适的文法（一般是左因子分解，左因子分解可以理解为公共左因子提取，这里的因子值终结符）每一步，仅有一步选择：</li>
</ul>
<blockquote>
<p>Hint:
其实就是根据当前预测字符决定选择使用哪个推导式，而这个预测字符和推导式的关系需要用一张表来记录</p>
</blockquote>
<p>继续考虑语法Grammar:</p>
<p>E -&gt; T | T | T + E</p>
<p>T -&gt; int | int * T | (E)</p>
<p>难以产生预测字符：</p>
<ul>
<li>对于T，有两个int开头的推导式，所以即使当前有预测字符int，也无法选择哪一个是最优的推导</li>
<li>对于E，更不容易看出预测字符是什么</li>
</ul>
<p>需要左因子语法改写：</p>
<p>E -&gt; TX</p>
<p>X -&gt; +E | </p>
<p>T -&gt; intY | (E)</p>
<p>Y -&gt; *T | </p>
<p>根据新语法可以计算得到LL(1) parse table:
其中表头为下一个输入的token，每一行是非终结符，单元格里的内容就是当前使用哪个推导式的rfs，这里暂时没有讲如何构造这张表的</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>int</th>
<th>*</th>
<th>+</th>
<th>（</th>
<th>）</th>
<th>$</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td>TX</td>
<td></td>
<td></td>
<td>TX</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>X</td>
<td></td>
<td></td>
<td>+E</td>
<td></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
</tr>
<tr class="odd">
<td>T</td>
<td>int Y</td>
<td></td>
<td></td>
<td>(E)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Y</td>
<td></td>
<td>*T</td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
</tr>
</tbody>
</table>
<p>比如：[Y, +] entry，表示当前非终结符Y，遇到了当前输入token +</p>
<p>那么Y就可以按照<span class="math inline">\(Y \rightarrow
\epsilon\)</span> 推导，</p>
<p>[E, *] entry，表示当前非终结符X，遇到了当前输入token
*，没有合适的推导式可以使用</p>
<p>这里我们再提一个额外的知识点：</p>
<p>我们不想采用递归的方式去做解析，而是利用栈解析：</p>
<ul>
<li>非终结符仍然是扩展替换的</li>
<li>终结符也仍然会输入进行比较匹配</li>
<li>栈顶=最左边的待处理的非终结符或非终结符</li>
<li>Reject on reaching error state</li>
<li>Accepy on end of input &amp; empty stack</li>
</ul>
<p>形式化定义如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">initialize stack = &lt;S $&gt; and <span class="hljs-keyword">next</span><br>repeat<br>	<span class="hljs-keyword">case</span> stack of<br>		&lt;X, rest&gt;: <span class="hljs-keyword">if</span> T[X, *<span class="hljs-keyword">next</span>] = Y1...Yn<br>								then stack &lt;- &lt;Y1...Yn rest&gt;;<br>								<span class="hljs-keyword">else</span> error(); <span class="hljs-comment">// 不存在推导动作则直接报错</span><br>		&lt;t, rest&gt;: <span class="hljs-keyword">if</span> t == *<span class="hljs-keyword">next</span>++<br>								then stack &lt;- &lt;rest&gt;;<br>								<span class="hljs-keyword">else</span> error();	<br>until stack == &lt;&gt;<br><br>初始化的时候栈顶是其实非终结符S,<br>后续，如果当前栈顶是非终结符X，且根据预测表执行的推导动作是X -&gt; Y1...Yn,则<span class="hljs-keyword">pop</span> X <span class="hljs-keyword">from</span> stack and <span class="hljs-keyword">push</span> Y1...Yn <span class="hljs-keyword">into</span> stack<br>	否则：如果栈顶是终结符且和当前输入相同（说明栈顶的这个元素直接可以使用其本身进行推导），则<span class="hljs-keyword">pop</span> t <span class="hljs-keyword">from</span> stack<br></code></pre></td></tr></table></figure>
<p>看一个🌰：</p>
<figure>
<img
src="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619230522565.png" srcset="/emocoder/img/loading.gif" lazyload
alt="image-20230619230522565" />
<figcaption aria-hidden="true">image-20230619230522565</figcaption>
</figure>
<h3 id="first">first</h3>
<h3 id="follow">follow</h3>
<h3 id="ll1-parse-table">ll1-parse-table</h3>
<p>构建预测表的步骤：</p>
<p>For each production <span class="math inline">\(A \rightarrow
\alpha\)</span> in G do:</p>
<ul>
<li>For each terminal <span class="math inline">\(t \in
First(\alpha)\)</span> do
<ul>
<li><span class="math inline">\(T[A, t] = \alpha\)</span></li>
</ul></li>
<li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>
for each t $t Follow(A) $ do
<ul>
<li><span class="math inline">\(T[A, t] = \alpha\)</span></li>
</ul></li>
<li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>
and t $$ Follow(A) $ do
<ul>
<li><span class="math inline">\(T[A, t] = \alpha\)</span></li>
</ul></li>
</ul>
<p>First() = { $, ) }</p>
<p>Follow(X) = { +, $, ) }</p>
<p>所以上面的语法形成的预测表如下</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>(</th>
<th>)</th>
<th>+</th>
<th>*</th>
<th>int</th>
<th>$</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td>TX</td>
<td></td>
<td></td>
<td></td>
<td>TX</td>
<td></td>
</tr>
<tr class="even">
<td>T</td>
<td>(E)</td>
<td></td>
<td></td>
<td></td>
<td>intY</td>
<td></td>
</tr>
<tr class="odd">
<td>X</td>
<td></td>
<td>+E</td>
<td></td>
<td></td>
<td></td>
<td><span class="math inline">\(\epsilon\)</span></td>
</tr>
<tr class="even">
<td>Y</td>
<td></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td>*T</td>
<td></td>
<td><span class="math inline">\(\epsilon\)</span></td>
</tr>
</tbody>
</table>
<p>上述表格每个表格内的条目最多只有一条，当唯恐的时候，表示解析遇到错误，下面看一个表格内不止一个条目的例子：</p>
<p>语法：<span class="math inline">\(S -&gt; Sa | b\)</span></p>
<p>First(S) = { b }</p>
<p>Follow(S) = { $, a }</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>a</th>
<th>b</th>
<th>$</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$</td>
<td>b / Sa</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>正如上面的例子，如果一个表的内容是多个，则该语法不是LL(1)，当燃判断是否为LL(1)还有其他方法：</p>
<ul>
<li>非左因子语法不是LL(1)</li>
<li>左递归不是LL(1)</li>
<li>二义性也不是</li>
<li>其他的，如LL(k), k &gt; 1也不是</li>
</ul>
<p><strong>网页知识点：</strong></p>
<p>LL和LR：</p>
<p>概念梳理：</p>
<p>首先说明，Context-free
grammar与无二义性文法不是一个层级的概念。CFG的意思是：我们用产生式设计的一组文法，对于每一个推导，其中的NT可以任意地被产生式右部替换而合法（这并不限制对于一个文本，只能推理出一棵树）。也就是每个NT之下的产生式是等价的，比如对于Verb-&gt;吃/睡/飞，在具体解析时，不论前面的主语/后面的宾语是什么，都合法。二义性是在CFG之下的概念。</p>
<p><a
target="_blank" rel="noopener" href="https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html">LL
and LR Parsing Demystified (reverberate.org)</a></p>
<p>LL表示从左到右扫描输入并执行最左推导，LL和LR相比哪个适用范围更广呢？</p>
<p>为简单讨论，我们只讨论LL(1)和LR(1)，1代表向前查看的字符数量（预测1个字符），1表示任何时刻我们提前查看当前输入字符的下一个字符，再根据这个提前查看的字符决定使用哪一个规约行为。</p>
<ul>
<li>In LL(1) we see the first symbol of the input and see the production
to apply. So, if there is two productions with the same ‘first’ symbol
as in the input parser gets a conflict and fails.</li>
<li>在LL(1)里，我们自左到右进行规约，查看当前字符和采用对应的推导式进行规约。所以，如果如果有两个推导式有着相同的fiest
symbol，就会产生冲突</li>
<li>在 LR（1）
中，我们看到从左边开始的输入，直到我们得到一个handle。在此之后，我们再看到一个前瞻符号并确定解析器操作.即，解析器比
LL（1） 中有更多的信息来决定其操作，这使得它比 LL（1）
更强大。更强大的手段是，任何可以被 LL（1） 解析的语法也可以被 LR（1）
解析。</li>
<li>这种情况在更一般的场景下也成立，对于任何k，LL（k）语法集是LR（k）语法集的适当子集</li>
</ul>
<p>这里我们所说的解析器的能力指的是其可以解析的语法的范围，并不是说它能够生成的语言。所以什么是LL(1)语言呢，它们是不是都可以被LL(1)生成呢？</p>
<p>实际上LL(k)的能力和k成正比，k越大，LL(k)的能力越强，LL(k)是LL(k+1)的子集</p>
<p>那LR(k)?</p>
<p><span class="math inline">\(First(\alpha)\)</span> 是从<span
class="math inline">\(\alpha\)</span>推导的handle的起始终结符的集合</p>
<p><span
class="math inline">\(Follow(A)\)</span>(这里大写表示A是一个非终结符)，是紧跟在A后面的终结符的集合</p>
<p>当且仅当一个语法G满足如下条件，G才被称之为LL(1):</p>
<ol type="1">
<li>G not unambiluous</li>
<li>G not left-recursive</li>
<li>If there is a production <span class="math inline">\(A→\alpha |
\beta\)</span>, then
<ol type="1">
<li><span class="math inline">\(First(\alpha) \cup First(\beta) =
empty\)</span> 否则解析器不知道使用哪个推导式</li>
<li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =
empty\)</span> contains <span class="math inline">\(\epsilon\)</span>,
<span class="math inline">\(First(\beta)\)</span>不应该包含<span
class="math inline">\(\epsilon\)</span>,
否则解析器不知道使用哪个推导式</li>
<li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =
empty\)</span>, <span class="math inline">\(First(\beta) \cup
First(\alpha) = empty\)</span>, 否则解析器不知道使用哪个推导式</li>
</ol></li>
</ol>
<p>下面是LR部分:</p>
<p>item：文法的一个产生式G加上其右部某一位置的一个点，这个点表示了分析过程中的状态。</p>
<p>产生式A-&gt;XYZ 产生的四个项：</p>
<p>A-&gt;·XYZ A-&gt;X·YZ A-&gt;XY·Z A-&gt;XYZ·
以第二个项为例，其表示已经接收了一个可以由X推导的串，如果希望能归约，那么接下来要识别一个能够由YZ推导的串。</p>
<p>Dcfl is a superset of regular. But dcfl with prefix property is
not.</p>
<h1 id="viable-prefixes-and-handle-in-lr-parsing">Viable Prefixes and
Handle in LR Parsing</h1>
<h3 id="bottom-up-parsing">Bottom-up Parsing</h3>
<p>Consider the grammar</p>
<ul>
<li><span class="math inline">\(S -&gt; XX\)</span></li>
<li>$X -&gt; aX | b $</li>
</ul>
<p>Now, consider a string in <span class="math inline">\(L(S)\)</span>
say aabb. We can parse it as follows by left most derivation – replacing
the left most non-terminal in each step, or right most derivation –
replacing the rightmost non-terminal in each step.</p>
<p>考虑一个符合该文法的字符串aabb，我们可以按照最左推导解析它（每一步替换最左边的非终结符）或者也可以按照最右推导解析它（每一步替换最右边的非终结符）</p>
<figure>
<img
src="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619000054295.png" srcset="/emocoder/img/loading.gif" lazyload
alt="image-20230619000054295" />
<figcaption aria-hidden="true">image-20230619000054295</figcaption>
</figure>
<p><strong>上面的最右推导被用在bottom-up parsing</strong></p>
<blockquote>
<ul>
<li><em>Any string derivable from the start symbol is a sentential form
— it becomes a sentence if it contains only terminals</em></li>
<li><em>A sentential form that occurs in the leftmost derivation of some
sentence is called left-sentential form</em></li>
<li><em>A sentential form that occurs in the rightmost derivation of
some sentence is called right-sentential form</em></li>
</ul>
</blockquote>
<p>再次考虑字符串aabb，我们可以按照如下方法解析：</p>
<p>从左至右扫描输入，如果存在子串匹配任何推导式的<strong>右侧</strong>(RHS,
right hand of string), 用该推导式的<strong>左侧</strong>替换该字符串</p>
<p>具体步骤如下：</p>
<ol type="1">
<li>‘a’ “abb” – 不存在RHS匹配'a'</li>
<li>‘aa’ “bb” – 不存在RHS匹配'a' 或者 'aa'</li>
<li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches
‘b’ (first b from left) and so we write as</li>
</ol>
<p>Consider the string aabb again. We will see a method to parse
this:</p>
<ol type="1">
<li>Scan the input from left to right and see if any substring matches
the RHS of any production. If so, replace that substring by the LHS of
the production.</li>
</ol>
<p>So, for “aabb” we do as follows</p>
<ol type="1">
<li>‘a’ “abb” – No RHS matches ‘a’</li>
<li>‘aa’ “bb” – No RHS matches ‘a’ or ‘aa’</li>
<li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches
‘b’ (first b from left) and so we write as aaXb</li>
<li>‘aaX’ “b” – RHS of <span class="math inline">\(X→aX\)</span> matches
“aX” and so we write as</li>
<li>aXb – Again RHS of <span class="math inline">\(X→aX\)</span> matches
“aX” and we get</li>
<li>Xb – RHS of <span class="math inline">\(X→b\)</span> matches “b” and
we get</li>
<li>XX – RHS of <span class="math inline">\(S→XX\)</span>matches XX and
we get</li>
<li>S – the start symbol.</li>
</ol>
<p>Now what we did here is nothing but a bottom-up parsing. Bottom-up
because we started from the string and not from the grammar. Here, we
applied a sequence of reductions, which are as follows: <span
class="math display">\[
aabb → aaXb → aXb → Xb → XX → S
\]</span> If we go up and see the Rightmost derivation of the string
“aabb”, what we got is the same but in REVERSE order. i.e., our bottom
up parsing is doing reverse of the RIGHTMOST
derivation(仔细观察上述的替换过程和最开始的最右推导的顺序是相反的).
<strong>So, we can call it an <span class="math inline">\(LR\)</span>
parser –$ L$ for scanning the input from Left side and <span
class="math inline">\(R\)</span> for doing a Rightmost
derivation.</strong></p>
<p>In our parsing we substituted the RHS of a production at each step.
This substituted “substring” is called a HANDLE and are shown in
<strong>BOLD</strong>
below(在推导过程中，我们在每一步替换了子串，这些子串称为Handle，在下面被加粗了).
<span class="math display">\[
aa\bold bb → a\bold a \bold Xb → \bold a \bold Xb → X\bold b → \bold X
\bold X → S
\]</span> Formally a handle is defined as (Greek letters used to denote
a string of terminals and non-terminals)</p>
<blockquote>
<p>"<em>A handle of a right sentential form ‘</em>γ<em>’</em>
(γ=αδβ<em>) is a production</em> E→δ <em>and a position in</em> γ
<em>where</em> δ <em>can be found and substituted by</em> E <em>to get
the</em> <strong>previous step</strong> <em>in the right most derivation
of</em> γ <em>— previous and not “next” because we are doing rightmost
derivation in REVERSE. Handle can be given as a production or just the
RHS of a production.</em></p>
</blockquote>
<p>The handle is not necessarily starting from the left most position as
clear from the above example
(从上面的例子可以看到handle不一定开始于RHS的最左边). There is importance
to the input string which occurs to the left of the handle
(所谓的可行前缀就是当前handle的所有前缀). For example for the handles of
“aabb”, we can have the following set of prefixes</p>
<table>
<tbody>
<tr class="odd">
<td>aa<strong>b</strong>b</td>
<td>{a, aa, aab}</td>
</tr>
<tr class="even">
<td>aa<strong>X</strong>b</td>
<td>{a, aa, aaX}</td>
</tr>
<tr class="odd">
<td>a<strong>X</strong>b</td>
<td>{a, aX}</td>
</tr>
<tr class="even">
<td>X<strong>b</strong></td>
<td>{X, Xb}</td>
</tr>
<tr class="odd">
<td><strong>XX</strong></td>
<td>{X, XX}</td>
</tr>
</tbody>
</table>
<p>These set of prefixes are called Viable Prefixes
(这些前缀集合被称为可行前缀). Formally</p>
<blockquote>
<p>" Viable prefixes are the prefixes of right sentential forms that do
not extend beyond the end of its handle.</p>
<p>i.e., a viable prefix either has no handle or just one possible
handle on the extreme RIGHT which can be reduced.</p>
</blockquote>
<p>We will see later that viable prefixes can also be defined as the set
of prefixes of the right-sentential form that can appear on the stack of
a shift-reduce parser. Also, the set of all viable prefixes of the right
sentential forms of a grammar is a REGULAR LANGUAGE. i.e., viable
prefixes can be recognized by using a FINITE AUTOMATA. Using this FINITE
AUTOMATA and a stack we get the power of a Push Down Automata and that
is how we can parse context-free languages.</p>
<p>在后面，可行前缀也可以被定义为出现在shift-reduce解析器的最右推导式的前缀集合。当然，所有的可行前缀是正则语言，所以，可行前缀可以被有限自动机识别。使用有限自动机和stack就可以Push
Down Automata，这本质上就是在解析上下无关文法。</p>
<p><strong>参考文献</strong>：https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/100%20Bottom-Up%20Parsing.pdf</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/emocoder/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="category-chain-item">编译原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/emocoder/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%8Ccool/">#编译原理，计算机基础，cool</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)</div>
      <div>https://mingmingjiang1.github.io/emocoder/2023/06/10/编译原理三/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>迷途知返</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/" title="斯坦福cs231(编译原理)の 2 Lexical Analysis">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">斯坦福cs231(编译原理)の 2 Lexical Analysis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/" title="斯坦福cs231(编译原理)の 12 Conclusion">
                        <span class="hidden-mobile">斯坦福cs231(编译原理)の 12 Conclusion</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/emocoder/js/events.js" ></script>
<script  src="/emocoder/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/emocoder/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/emocoder/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/emocoder/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
