

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/emocoder/img/fluid.png">
  <link rel="icon" href="/emocoder/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="迷途知返">
  <meta name="keywords" content="">
  
    <meta name="description" content="file abstraction Crash safety：遭遇某种宕机或者突然关机，原文件还存在 Disk layout：文件是如何在硬盘上存储的 Performance 持久化的存储设备读取速率通常很慢，需要buffer和concurrency  API Example fd &#x3D; open(&quot;x&#x2F;y&quot;, _)，文件名是人类可读的 write(fd, &quot;abc&quot;, 3)，写入文件的时候，是不存">
<meta property="og:type" content="article">
<meta property="og:title" content="File system">
<meta property="og:url" content="https://mingmingjiang1.github.io/emocoder/2023/10/05/oslearning/mit-6.s081/filesys/fs/index.html">
<meta property="og:site_name" content="迷途知返">
<meta property="og:description" content="file abstraction Crash safety：遭遇某种宕机或者突然关机，原文件还存在 Disk layout：文件是如何在硬盘上存储的 Performance 持久化的存储设备读取速率通常很慢，需要buffer和concurrency  API Example fd &#x3D; open(&quot;x&#x2F;y&quot;, _)，文件名是人类可读的 write(fd, &quot;abc&quot;, 3)，写入文件的时候，是不存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\fs-layers.png">
<meta property="og:image" content="c:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\disk-layout.png">
<meta property="og:image" content="c:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\%E6%97%A0%E6%A0%87%E9%A2%98-2023-08-26-1159.png">
<meta property="og:image" content="c:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\write1.png">
<meta property="article:published_time" content="2023-10-05T06:56:42.000Z">
<meta property="article:modified_time" content="2023-10-06T07:19:38.626Z">
<meta property="article:author" content="迷途知返">
<meta property="article:tag" content="操作系统，计算机基础, C">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\fs-layers.png">
  
  
  
  <title>File system - 迷途知返</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/emocoder/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/emocoder/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/emocoder/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mingmingjiang1.github.io","root":"/emocoder/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/emocoder/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/emocoder/js/utils.js" ></script>
  <script  src="/emocoder/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/emocoder/">
      <strong>Emoer</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/emocoder/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/emocoder/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="File system"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-05 14:56" pubdate>
          2023年10月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          169 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">File system</h1>
            
            
              <div class="markdown-body">
                
                <ol type="1">
<li><p>file abstraction</p></li>
<li><p>Crash safety：遭遇某种宕机或者突然关机，原文件还存在</p></li>
<li><p>Disk layout：文件是如何在硬盘上存储的</p></li>
<li><p>Performance</p>
<p>持久化的存储设备读取速率通常很慢，需要buffer和concurrency</p></li>
</ol>
<h2 id="api-example">API Example</h2>
<p>fd = open("x/y", _)，文件名是人类可读的</p>
<p>write(fd, "abc",
3)，写入文件的时候，是不存在偏移量的，偏移量是隐式的，需要文件抽象来存储</p>
<p>link("x/y", "x/z"), 建立链接，相当于对同一个文件有多个命名</p>
<p>unlink("x/y")，删除之前的引用</p>
<p>write(fd, "def", 3)，此时仍然可以写入</p>
<p>所以，fd是和文件名无关的对象，</p>
<p>存储信息的组织方式不只是本次课的一种，还有很多方法，比如B+,
红黑树，但本节课是最简单实现的一种</p>
<h2 id="inode">Inode</h2>
<p>Inode &lt;- file info, independent of name</p>
<p>Inode #(仅仅是个数字)</p>
<p>对Inode必须有链接计数，当链接计数为0时且打开文件的fd为0时才能删除对应文件，fd必须维护每次写入后的偏移量</p>
<p>FS layers</p>
<p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\fs-layers.png" srcset="/emocoder/img/loading.gif" lazyload alt="fs-layers" style="zoom:50%;" /></p>
<h2 id="storage-device">Storage Device</h2>
<p>从下面开始讲：</p>
<ol type="1">
<li><p>存储设备</p>
<p>SSD 和HDD</p></li>
</ol>
<p>对于存储设备有个存储划分的概念，且存储设备有对应的分区：扇区(512)和块区(1024B)，这两个是对存储设备不同的划分单位</p>
<p>CPU &lt;- memory</p>
<p>write /read PCI(驱动)</p>
<p>SSD HDD</p>
<p>disk layout：xv6按照块对磁盘进行划分，一个块1024字节</p>
<p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\disk-layout.png" srcset="/emocoder/img/loading.gif" lazyload alt="disk-layout" style="zoom:50%;" /></p>
<p>给定inode，可以计算出在哪个块里，eg:10 -&gt; 32 + 10 * 64 / 1024 =
32，所以在编号为32的块中 inode 17呢 =&gt; 33</p>
<p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\无标题-2023-08-26-1159.png" srcset="/emocoder/img/loading.gif" lazyload alt="无标题-2023-08-26-1159" style="zoom:50%;" /></p>
<p>block 12可以存放(1024/4 = 256，4是block index大学)个block
index，所以xv6里硬盘最大存储(256 + 12) * 1024 bytes大小</p>
<p>如果想要扩展存储最大空间的话，可以加double indirect block index:</p>
<p>index =&gt; block index =&gt; block index</p>
<p>eg: 给定字节，怎么知道是哪个inode read(8000) = 8000 / 1024 = 7 8000 %
1024 = 832</p>
<p>由于7小于direct
index，所以直接可以查到，然后取偏移量为832处的数据</p>
<p>目录：xv6中目录即文件</p>
<p>目录由很多entry组成，每个entry由：entry: inode num(2 bytes) +
filename (14 bytes)，</p>
<p>eg: 查找y/x</p>
<p>从root inode(1)开始查找，在block 32这里，第64~128(32 + 1 * 64 / 1024
= 32, offset = 1*64 % 1024 = 64) =&gt;scans block for name 'y' =&gt;
如果是目录然后遍历它的block是寻找文件名为y的entry，其inode为251，继续向下寻找</p>
<figure>
<img
src="C:\Users\Mmjiang\AppData\Roaming\Typora\typora-user-images\image-20230909201628672.png" srcset="/emocoder/img/loading.gif" lazyload
alt="image-20230909201628672" />
<figcaption aria-hidden="true">image-20230909201628672</figcaption>
</figure>
<h2 id="代码演示">代码演示</h2>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> file<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (<span class="hljs-keyword">block</span> <span class="hljs-number">33</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (filling inode)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">46</span> (data <span class="hljs-keyword">block</span>, root目录的一个块)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">32</span> (update inode <span class="hljs-number">1</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span>  (update <span class="hljs-keyword">new</span> inode)<br><br>hi<br><span class="hljs-keyword">write</span>: <span class="hljs-number">45</span> (bitmap)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">595</span> (<span class="hljs-keyword">write</span> bitmap <span class="hljs-keyword">to</span> <span class="hljs-number">595</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">595</span> (<span class="hljs-keyword">write</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">block</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (update <span class="hljs-keyword">new</span> inode)<br><br>\n<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span><br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure>
<p>你可以使用名叫E1000
的网络设备处理网络通信。对于xv6来说，E1000看起来像是连接到真实局域网的一块硬件设备。实际上，E1000在quemu中是一种软件模拟的形式。在QEMU模拟的局域网里，xv6作为客户端它的IP地址10.0.2.15，同时还有另一台与之通信的IP为10.0.2.2的主机。当xv6使用E1000给10.0.2.2发送数据包，qemu传递该数据包给合适的应用</p>
<h2 id="crash-safety">Crash Safety</h2>
<p>Crash can lead the on-disk fs to be incorrect adn inconsistent
state.</p>
<p>解决方案：logging</p>
<h3
id="risks-fs-operation-are-multipl-steps-disk-operation.-crash-may-leave-fs-invariants-violated破坏文件系统的不变性">RIsks：
fs operation are multipl steps disk operation. crash may leave fs
invariants violated(破坏文件系统的不变性)</h3>
<p>重启后：crash again, or no crash but w/w data incorrectly</p>
<p>case: xv6</p>
<p>bitmap: 用于记录哪些块是空闲的，哪些不是</p>
<p>echo "hi" &gt; x</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span> (allocate inode <span class="hljs-keyword">for</span> x)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span> (init inode x)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">46</span> (<span class="hljs-built_in">record</span> x <span class="hljs-keyword">in</span> / directory&#x27;s data block)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">32</span> (update root inode)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span>  (update inode x)<br><br>单个文件的创建由多步组成<br><br><br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\write1.png" srcset="/emocoder/img/loading.gif" lazyload alt="write1" style="zoom:50%;" /></p>
<p>可以不看通过调整顺序呢？</p>
<p>46 32 33 33 33</p>
<p>可以避免上面的问题，但是会有新的问题，比如在32处发生崩溃，此时OS可见的是未分配的Inode，所以导致该inode后续被用在了其他的文件里，即一个inode被多个文件共享。造成的直观影响是一个用户读写一个文件会影响其他用户。</p>
<p>45(set alloc bitmap block)</p>
<p>595(update h to allocate data block)</p>
<p>595(update i to allocate data block)</p>
<p>33(size update)</p>
<p>修改顺序：33
45，在33后发生崩溃，size发生改变，但实际大小却不是，且在bitmap中595没有被记录属于当前文件的；所以该block后续也会被分配到其他文件，导致共享。</p>
<p>出现问题的本质原因在于：fs
operation不是以原子性对磁盘进行操作，并不是由于操作的顺序所导致的。</p>
<p>解决方法：logging，用日志延迟更新磁盘的操作，将多次写操作组成一个原子性操作，称为事务。</p>
<ol type="1">
<li>atomic fs calls</li>
<li>fast recovery</li>
<li>high performance</li>
</ol>
<p>(本次课程只提到了write，不涉及文件的append操作)</p>
<p>磁盘：</p>
<p>内存：</p>
<p>有了logging之后，磁盘的更新步骤如下：</p>
<ol type="1">
<li>log writes (不做实际写入操作)</li>
<li>commit (提交一次事务到磁盘，更新磁盘的logging block)</li>
<li>install (更新磁盘的data block)</li>
<li>clean log</li>
</ol>
<p>事务帮助多个写入操作成为原子性的，</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl">事务的开始(<span class="hljs-function"><span class="hljs-title">begin_op</span>())</span><br><br>事务的结束(<span class="hljs-function"><span class="hljs-title">end_op</span>())</span><br><br>结束之后才会生成<span class="hljs-variable">commit</span>，<span class="hljs-variable">xv6</span>中的文件系统调用都有这样的代码结构<br></code></pre></td></tr></table></figure>
<p>bitmap：用于记录哪些data block在被使用中</p>
<p>三个注意点：</p>
<ol type="1">
<li>bcache不能驱逐</li>
<li>单次commit不能太大，超过logging block大小，需要分割</li>
<li>并发的情况下，如果多个事务同时参与commit，如果本次commit的大小太大，需要睡眠部分进程，等待上一个事务结束之后再恢复</li>
</ol>
<h2 id="文件系统">文件系统</h2>
<h3 id="概述">概述</h3>
<p>出于以下原因，文件系统背后的机制还比较有意思：</p>
<ul>
<li>文件系统对硬件的抽象较为有用，所以理解文件系统对于硬件的抽象是如何实现的还是有点意思的。</li>
<li>除此之外，还有个关键且有趣的地方就是crash
safety。有可能在文件系统的操作过程中，计算机崩溃了，在重启之后你的文件系统仍然能保持完好，文件系统的数据仍然存在，并且你可以继续使用你的大部分文件。如果文件系统操作过程中计算机崩溃了，然后你重启之后文件系统不存在了或者磁盘上的数据变了，那么崩溃的将会是你。所以crash
safety是一个非常重要且经常出现的话题，我们下节课会专门介绍它。</li>
<li>之后是一个通用的问题，如何在磁盘上排布文件系统。例如目录和文件，它们都需要以某种形式在磁盘上存在，这样当你重启计算机时，所有的数据都能恢复。所以在磁盘上有一些数据结构表示了文件系统的结构和内容。在XV6中，使用的数据结构非常简单，因为XV6是专门为教学目的创建的。真实的文件系统通常会更加复杂。但是它们都是磁盘上保存的数据结构，我们在今天的课程会重点看这部分。</li>
<li>最后一个有趣的话题是性能。文件系统所在的硬件设备通常都较慢，比如说向一个SSD磁盘写数据将会是毫秒级别的操作，而在一个毫秒内，计算机可以做大量的工作，所以尽量避免写磁盘很重要，我们将在几个地方看到提升性能的代码。比如说，所有的文件系统都有buffer
cache或者叫block
cache。同时这里会有更多的并发，比如说你正在查找文件路径名，这是一个多次交互的操作，首先要找到文件结构，然后查找一个目录的文件名，之后再去查找下一个目录等等。你会期望当一个进程在做路径名查找时，另一个进程可以并行的运行。这样的并行运行在文件系统中将会是一个大的话题。</li>
</ul>
<p>文件系统究竟维护了什么样的结构？</p>
<ul>
<li>首先，最重要的可能就是inode，这是代表一个文件的对象，并且它不依赖于文件名。实际上，inode是通过自身的编号来进行区分的，这里的编号就是个整数。所以文件系统内部通过一个数字，而不是通过文件路径名引用inode。同时，基于之前的讨论，inode必须有一个link
count来跟踪指向这个inode的文件名的数量。一个文件（inode）只能在link
count为0的时候被删除。实际的过程可能会更加复杂，实际中还有一个openfd
count，也就是当前打开了文件的文件描述符计数。一个文件只能在这两个计数器都为0的时候才能被删除。</li>
</ul>
<p>文件系统中核心的数据结构就是inode和file
descriptor。后者主要与用户进程进行交互。</p>
<p>尽管文件系统的API很相近并且内部实现可能非常不一样。但是很多文件系统都有类似的结构。因为文件系统还挺复杂的，所以最好按照分层的方式进行理解(图3-2)。可以这样看：</p>
<ul>
<li>在最底层是磁盘，也就是一些实际保存数据的存储设备，正是这些设备提供了持久化存储。</li>
<li>在这之上是buffer cache或者说block
cache，这些cache可以避免频繁的读写磁盘。这里我们将磁盘中的数据保存在了内存中。</li>
<li>为了保证持久性，再往上通常会有一个logging层。许多文件系统都有某种形式的logging，我们下节课会讨论这部分内容，所以今天我就跳过它的介绍。</li>
<li>在logging层之上，XV6有inode
cache，这主要是为了同步（synchronization），我们稍后会介绍。inode通常小于一个disk
block，所以多个inode通常会打包存储在一个disk
block中。为了向单个inode提供同步操作，XV6维护了inode cache。</li>
<li>再往上就是inode本身了。它实现了read/write。</li>
<li>再往上，就是文件名，和文件描述符操作。</li>
</ul>
<figure>
<img
src="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0YjFkYzFlNDg4NTk4NDIyMDc3NTBhNjM3ZDgwZmFfZXBqRmJIeWp4d2x5V3dpODBKcVZpYTliVXpYSkIzSEVfVG9rZW46SHlDRmJFb1hHb01GSDl4a3Q2N2NoOHRqbnpmXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA" srcset="/emocoder/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>(图3-1: filesystem layering)</p>
<h3 id="inode-1">inode</h3>
<p>当今的Unix文件系统(Unix File System, UFS)起源于Berkeley Fast File
System。和所有的文件系统一样，Unix文件系统是以块(Block)为单位对磁盘进行读写的。一般而言，一个块的大小为512bytes或者1024bytes。文件系统的所有数据结构都以块为单位存储在硬盘上，一些典型的数据块包括：</p>
<ul>
<li>Super
block：Superblock包含了关于整个文件系统的元信息(metadata)，比如文件系统的类型、大小、状态和关于其他文件系统数据结构的信息。Superblock对文件系统是非常重要的，因此Unix文件系统的实现会保存多个Superblock的副本。</li>
<li>Inode
block：inode是Unix文件系统中用于表示文件的抽象数据结构。inode不仅是指抽象了一组硬盘上的数据的”文件”，目录和外部IO设备等也会用inode数据结构来表示。inode包含了一个文件的元信息，比如拥有者、访问权限、文件类型等等。对于一个文件系统里的所有文件，文件系统会维护一个inode列表，这个列表可能会占据一个或者多个磁盘块（见下图3-1）。</li>
<li>Data block：Data
block用于存储实际的文件数据。一些文件系统中可能会存在用于存放目录的Directory
Block和Indirection
Block，但是在Unix文件系统中这些文件块都被视为数据，上层文件系统通过inode对其加以操作，他们唯一的区别是inode里记录的属性有所不同。</li>
<li>Directory block</li>
<li>Indirection block</li>
</ul>
<figure>
<img
src="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZmY2I0ZDgxYjE4MTNiMzQ0NGU1ZGM3ODM1YzJkMzJfSERudVhNNjVQRlZYeE1xRUVIN1lQVVhoUjNJTXJRRWhfVG9rZW46VVhwamJOS1NRb0NyQzF4MElyU2N2cGxlblpnXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA" srcset="/emocoder/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>(3-2: inode)</p>
<p>block 12可以存放(1024/4 = 256，4是block index本身大小)个block
index，所以xv6里硬盘最大存储(256 + 12) * 1024 bytes大小</p>
<p>如果想要扩展存储最大空间的话，可以加double indirect block index</p>
<h3
id="存储设备与硬盘上的文件系统布局">存储设备与硬盘上的文件系统布局</h3>
<p>通常来说，xv6的硬件上文件布局如下：</p>
<ul>
<li>block0要么没有用，要么被用作boot sector来启动操作系统。</li>
<li>block1通常被称为super
block，它描述了文件系统。它可能包含磁盘上有多少个block共同构成了文件系统这样的信息。我们之后会看到XV6在里面会存更多的信息，你可以通过block1构造出大部分的文件系统信息。</li>
<li>在XV6中，log从block2开始，到block32结束。实际上log的大小可能不同，这里在super
block中会定义log就是30个block。</li>
<li>接下来在block32到block45之间，XV6存储了inode。我之前说过多个inode会打包存在一个block中，一个inode是64字节。</li>
<li>之后是bitmap
block，这是我们构建文件系统的默认方法，它只占据一个block。它记录了数据block是否空闲。</li>
<li>之后就全是数据block了，数据block存储了文件的内容和目录的内容。</li>
</ul>
<p>通常来说，bitmap block，inode blocks和log blocks被统称为metadata
block。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据。</p>
<blockquote>
<p>学生提问：boot block是不是包含了操作系统启动的代码？</p>
<p>Frans教授：完全正确，它里面通常包含了足够启动操作系统的代码。之后再从文件系统中加载操作系统的更多内容。</p>
<p>学生提问：所以XV6是存储在虚拟磁盘上？</p>
<p>Frans教授：在QEMU中，我们实际上走了捷径。QEMU中有个标志位-kernel，它指向了内核的镜像文件，QEMU会将这个镜像的内容加载到了物理内存的0x80000000。所以当我们使用QEMU时，我们不需要考虑boot
sector。</p>
<p>学生提问：所以当你运行QEMU时，你就是将程序通过命令行传入，然后直接就运行传入的程序，然后就不需要从虚拟磁盘上读取数据了？</p>
<p>Frans教授：完全正确。</p>
</blockquote>
<figure>
<img
src="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YmZjODk4YzY2YmVjMGFmZjU4ZTk5YzRiYWI5N2M0ZDFfakV5eWFEMnhONEROUmdKYVMwRGszeDRmZ2FibmJUMnZfVG9rZW46T3pmaWJzdUxSb1N4aFJ4RDBuR2NZMzNwbkc5XzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA" srcset="/emocoder/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>给定字节，怎么知道是哪个inode？ read(8000) = 8000 / 1024 = 7 8000 %
1024 = 832</p>
<p>由于7小于direct
index，所以直接可以查到，然后取偏移量为832处的数据。</p>
<p><strong>目录</strong>：xv6中目录即文件</p>
<p>目录由很多entry组成，每个entry由：entry: inode num(2 bytes) +
filename (14 bytes)，</p>
<p>eg: 查找y/x</p>
<p>从root inode(1)开始查找，在block 32这里，第64~128(32 + 1 * 64 / 1024
= 32, offset = 1*64 % 1024 = 64) =&gt;scans block for name 'y' =&gt;
如果是目录然后遍历它的block是寻找文件名为y的entry，其inode为251，继续向下寻找。</p>
<h3 id="代码">代码</h3>
<p>下面以open为例看下大致的与磁盘交互的过程：</p>
<h4 id="sys_open">sys_open</h4>
<p>首先是sys_open函数：就是参数校验调用begin_op</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> path[MAXPATH];<br>  <span class="hljs-type">int</span> fd, omode;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> *f;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>((n = <span class="hljs-built_in">argstr</span>(<span class="hljs-number">0</span>, path, MAXPATH)) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">argint</span>(<span class="hljs-number">1</span>, &amp;omode) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-built_in">begin_op</span>();<br><br>  <span class="hljs-keyword">if</span>(omode &amp; O_CREATE)&#123;<br>    ip = <span class="hljs-built_in">create</span>(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">namei</span>(path)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">ilock</span>(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="begin_op">begin_op</h4>
<p>判断是否已经处于committing
status，如果是则睡眠，除此之外日志太大也睡眠</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file.c</span><br><br><span class="hljs-comment">// called at the start of each FS system call.</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">begin_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">acquire</span>(&amp;log.lock);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(log.committing)&#123;<br>      <span class="hljs-built_in">sleep</span>(&amp;log, &amp;log.lock);<br>      <span class="hljs-comment">// MAXOPBLOCKS为10，为什么呢？</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(log.lh.n + (log.outstanding+<span class="hljs-number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;<br>      <span class="hljs-comment">// this op might exhaust log space; wait for commit.</span><br>      <span class="hljs-built_in">sleep</span>(&amp;log, &amp;log.lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.outstanding += <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">release</span>(&amp;log.lock);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="create">Create</h4>
<p>接下来是create函数：主要就是查找父级目录，查找文件是否存在，如果存在直接返回，否则调用ialloc分配空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// fs.c</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">namei</span>(<span class="hljs-type">char</span> *path)<br>&#123;<br>  <span class="hljs-type">char</span> name[<span class="hljs-function">DIRSIZ</span><br><span class="hljs-function">  <span class="hljs-keyword">return</span> <span class="hljs-title">namex</span><span class="hljs-params">(path, <span class="hljs-number">0</span>, name)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">nameiparent</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">namex</span>(path, <span class="hljs-number">1</span>, name); <span class="hljs-comment">// 默认从1，root目录开始</span><br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">namex</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name) <span class="hljs-comment">// nameiparent是父级目录的inode编号</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip, *next;<br><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-comment">// 如果创建目录是root</span><br>    ip = <span class="hljs-built_in">iget</span>(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span> <br>    ip = <span class="hljs-built_in">idup</span>(<span class="hljs-built_in">myproc</span>()-&gt;cwd); <span class="hljs-comment">// 获取当前所在目录，如果是在/下创建的，就是/的inode num</span><br><br>  <span class="hljs-keyword">while</span>((path = <span class="hljs-built_in">skipelem</span>(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">ilock</span>(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.</span><br>      <span class="hljs-built_in">iunlock</span>(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = <span class="hljs-built_in">dirlookup</span>(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">iunlockput</span>(ip);<br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    <span class="hljs-built_in">iput</span>(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip; <span class="hljs-comment">// 返回/(父级)的inode</span><br>&#125;<br><br><span class="hljs-comment">// Look for a directory entry in a directory.</span><br><span class="hljs-comment">// If found, set *poff to byte offset of entry.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">dirlookup</span>(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)<br>&#123;<br>  uint off, inum;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> de; <br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    <span class="hljs-comment">// 父级目录不是目录</span><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br>  <span class="hljs-comment">// de是16byte，对应一个entry的大小</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-built_in">sizeof</span>(de))&#123;<br>    <span class="hljs-comment">// dir entry</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">readi</span>(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-built_in">sizeof</span>(de)) != <span class="hljs-built_in">sizeof</span>(de))<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">namecmp</span>(name, de.name) == <span class="hljs-number">0</span>)&#123; <br>      <span class="hljs-comment">// entry matches path element，有一个entry匹配到了，说明找到了，目录的data就是entry</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">iget</span>(dp-&gt;dev, inum);<br>    &#125;   <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">create</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)<br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip, *dp;<br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-keyword">if</span>((dp = <span class="hljs-built_in">nameiparent</span>(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 查找父级目录，这里说明没找到，返回父级目录的inode</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">ilock</span>(dp); <span class="hljs-comment">// 加锁，其他进程无法访问父级目录的inode，如果不加锁，其他进程操作该文件，可能会引起异常</span><br><br>  <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">dirlookup</span>(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123; <br>    <span class="hljs-comment">// 在父级目录里查找该文件，如果文件存在，返回找到的indoe</span><br>    <span class="hljs-built_in">iunlockput</span>(dp); <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-built_in">ilock</span>(ip); <span class="hljs-comment">// 加锁，其他进程无法访问目标文件inode</span><br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip; <br>    <span class="hljs-built_in">iunlockput</span>(ip); <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">ialloc</span>(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  <span class="hljs-built_in">ilock</span>(ip); <span class="hljs-comment">// 加锁，其他进程无法访问目标文件inode</span><br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">iupdate</span>(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    <span class="hljs-built_in">iupdate</span>(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dirlink</span>(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">dirlink</span>(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dirlink</span>(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  <span class="hljs-built_in">iunlockput</span>(dp);<br><br>  <span class="hljs-keyword">return</span> ip; <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ialloc">Ialloc</h4>
<p>首先调用bread获取缓存inode，如果缓存没有就分配最近未使用的（LRU链表）（这里会加一个睡眠锁，仅允许当前进程使用），找到后返回一个block对应的buf节点，在分配的缓存节点里找适合的位置（合适的位置=inode#/64
+
start_addr），然后log_write就可以写日志了，在日志里记录当前正在写的block。</p>
<p>它很简单，但是又不是很高效。它会遍历所有可能的inode编号，找到inode所在的block，再看位于block中的inode数据的type字段。如果这是一个空闲的inode，那么将其type字段设置为文件，这会将inode标记为已被分配。</p>
<p>以上就是第一次写磁盘涉及到的函数调用。这里有个有趣的问题，如果有多个进程同时调用create函数会发生什么？对于一个多核的计算机，进程可能并行运行，两个进程可能同时会调用到ialloc函数，然后进而调用bread（block
read）函数。所以必须要有一些机制确保这两个进程不会互相影响。</p>
<blockquote>
<p>是的，我们这里看一下目标block
no的cache是否存在，如果存在的话，将block对象的引用计数（refcnt）加1，之后再释放bcache锁，因为现在我们已经完成了对于cache的检查并找到了block
cache。之后，代码会尝试获取block cache的锁。</p>
<p>所以，如果有多个进程同时调用bget的话，<strong>其中一个可以获取bcache的锁并扫描buffer
cache。此时，其他进程是没有办法修改buffer
cache的（注，因为bacche的锁被占住了）。</strong>之后，进程会查找block
number是否在cache中，如果在的话将block
cache的引用计数加1，表明当前进程对block
cache有引用，之后再释放bcache的锁。如果有第二个进程也想扫描buffer
cache，那么这时它就可以获取bcache的锁。假设第二个进程也要获取该block的cache，那么它也会对相应的block
cache的引用计数加1。最后这两个进程都会尝试对block 33的block
cache调用acquiresleep函数。</p>
<p>acquiresleep是另一种锁，我们称之为sleep lock，本质上来说它获取目标
block cache的锁。其中一个进程获取锁之后函数返回。</p>
</blockquote>
<p>如果buffer cache中有两份block
33的cache将会出现问题。假设一个进程要更新inode19，另一个进程要更新inode20。如果它们都在处理block
33的cache，并且cache有两份，那么第一个进程可能持有一份cache并先将inode19写回到磁盘中，而另一个进程持有另一份cache会将inode20写回到磁盘中，并将inode19的更新覆盖掉。所以一个block只能在buffer
cache中出现一次。你们在完成File system lab时，必须要维持buffer
cache的这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">struct buf &#123;<br>  int valid;   <span class="hljs-comment">// has data been read from disk?</span><br>  int disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;<br>  uint blockno;<br>  struct sleeplock lock;<br>  uint refcnt;<br>  struct buf *prev; <span class="hljs-comment">// LRU cache list</span><br>  struct buf *next;<br>  uchar data[<span class="hljs-variable constant_">BSIZE</span>]; <span class="hljs-variable constant_">BSIZE</span> = <span class="hljs-number">1024</span><br>&#125;;<br><br><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-keyword">static</span> struct buf*<br><span class="hljs-title function_">bget</span>(<span class="hljs-params">uint dev, uint blockno</span>)<br>&#123;<br>  struct buf *b;<br>  <span class="hljs-title function_">acquire</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>; b != &amp;bcache.<span class="hljs-property">head</span>; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      <span class="hljs-title function_">release</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br>      <span class="hljs-title function_">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span>; b != &amp;bcache.<span class="hljs-property">head</span>; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      <span class="hljs-title function_">release</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br>      <span class="hljs-title function_">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 分配inode</span><br>struct inode*<br><span class="hljs-title function_">ialloc</span>(<span class="hljs-params">uint dev, short type</span>)<br>&#123;<br>  int inum;<br>  struct buf *bp;<br>  struct dinode *dip;<br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.<span class="hljs-property">ninodes</span>; inum++)&#123;<br>    bp = <span class="hljs-title function_">bread</span>(dev, <span class="hljs-title function_">IBLOCK</span>(inum, sb));<br>    dip = (struct dinode*)bp-&gt;data + inum%<span class="hljs-variable constant_">IPB</span>; <br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-title function_">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-title function_">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      <span class="hljs-title function_">log_write</span>(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      <span class="hljs-title function_">brelse</span>(bp); <span class="hljs-comment">// 释放睡眠锁</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">iget</span>(dev, inum);<br>    &#125;   <br>    <span class="hljs-title function_">brelse</span>(bp);<br>  &#125;<br>  <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-comment">// bread每次只能拿到一个block</span><br>struct buf*<br><span class="hljs-title function_">bread</span>(<span class="hljs-params">uint dev, uint blockno</span>)<br>&#123;<br>  struct buf *b; <br><br>  b = <span class="hljs-title function_">bget</span>(dev, blockno); <span class="hljs-comment">// 根据block获取缓存的对应的buf节点</span><br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123; <span class="hljs-comment">// 如果buf上之前没有数据</span><br>    <span class="hljs-title function_">virtio_disk_rw</span>(b, <span class="hljs-number">0</span>); <span class="hljs-comment">// 从disk上获取数据，完成一次真正的读写</span><br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><br>关于brelese：<br>这个函数会对refcnt减<span class="hljs-number">1</span>，并释放sleep lock。这意味着，如果有任何一个其他进程正在等待使用这个block cache，现在它就能获得这个block cache的sleep lock，并发现刚刚做的改动。<br>假设两个进程都需要分配一个新的inode，且新的inode都位于block <span class="hljs-number">33</span>。如果第一个进程分配到了inode18并完成了更新，那么它对于inode18的更新是可见的。另一个进程就只能分配到inode19，因为inode18已经被标记为已使用，任何之后的进程都可以看到第一个进程对它的更新。<br>这正是我们想看到的结果，如果一个进程创建了一个inode或者创建了一个文件，之后的进程执行读就应该看到那个文件<br></code></pre></td></tr></table></figure>
<h4 id="log_write">log_write</h4>
<p>log_write主要是在log缓存里记录了当前正在写的block（所以一次commit仅一个block，也仅一个文件）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 记录本次操作的日志</span><br><span class="hljs-title function_">log_write</span>(<span class="hljs-params">struct buf *b</span>)<br>&#123;<br>  int i;<br><br>  <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>); <span class="hljs-comment">// 操作日志需要加锁</span><br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt;= <span class="hljs-variable constant_">LOGSIZE</span> || log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt;= log.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>)<br>      <span class="hljs-comment">// 日志的数量最大30，或者大于本身该日志所能承受的大小</span><br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;too big a transaction&quot;</span>);<br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">outstanding</span> &lt; <span class="hljs-number">1</span>) <br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;log_write outside of trans&quot;</span>);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    <span class="hljs-comment">// 寻找目标block</span><br>    <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] == b-&gt;blockno)   <span class="hljs-comment">// log absorption</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  在header的数组里记录block#<br>  log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] = b-&gt;blockno;<br>  <span class="hljs-keyword">if</span> (i == log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>) &#123;  <span class="hljs-comment">// 如果是新增的日志，则n++</span><br>    <span class="hljs-title function_">bpin</span>(b);<br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>++;<br>  &#125;<br>  <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="commit">commit</h4>
<p>最后回到create函数，调用end_op，进而调用commit，commit会连续调用不同的函数，分别是用
header 缓存更新log缓存，接着用更新后的log缓存做真正的提交；用log缓存更新
header 缓存；清空log</p>
<ul>
<li>write_log：基本上就是将所有存在于内存中的log
header中的block编号对应的block写入到磁盘上的log区域中（注，也就是将变化先从内存拷贝到log中）。函数中依次遍历log中记录的block，并写入到log中。它首先读出log
block，将cache中的block拷贝到log block，最后再将log
block写回到磁盘中。这样可以确保需要写入的block都记录在log中。但是在这个位置，我们还没有commit，现在我们只是将block存放在了log中。如果我们在这个位置也就是在write_head之前crash了，<strong>那么最终的表现就像是transaction从来没有发生过，文件不会有任何变化同步到disk上。</strong></li>
<li>write_head：会将内存中的log header写入到磁盘的log
header中。首先读取log的header
block。将n拷贝到block中，将所有的block编号拷贝到header的列表中。最后再将header
block写回到磁盘。函数中的倒数第2行，bwrite是实际的commit
point吗？如果crash发生在这个bwrite之前，会发生什么？<strong>这时虽然我们写了log的header
block，但是数据并没有落盘。所以crash并重启恢复时，并不会发生任何事情。</strong>那crash发生在bwrite之后会发生什么呢？<strong>这时header会写入到磁盘中，当重启恢复相应的文件系统操作会被恢复。在恢复过程的某个时间点，恢复程序可以读到log
header并发现比如说有5个log还没有install，恢复程序可以将这5个log拷贝到实际的位置。所以这里的bwrite就是实际的commit
point。在commit point之前，transaction并没有发生，在commit
point之后，只要恢复程序正确运行，transaction必然可以完成。</strong></li>
<li>install_trans：这里先读取log
block，再读取文件系统对应的block。将数据从log拷贝到文件系统，最后将文件系统block缓存落盘。这里实际上就是将block数据从log中拷贝到了实际的文件系统block中。当然，可能在这里代码的某个位置会出现问题，但是这应该也没问题，因为在恢复的时候，我们会从最开始重新执行过。</li>
<li>最后write_log：会将log header中的n设置为0，再将log
header写回到磁盘中。将n设置为0的效果就是清除log，晴空磁盘额的log。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">void</span><br><span class="hljs-title function_">end_op</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int do_commit = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 枷锁</span><br>  <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>); <br>  log.<span class="hljs-property">outstanding</span> -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(log.<span class="hljs-property">committing</span>)<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;log.committing&quot;</span>);<br>  <span class="hljs-keyword">if</span>(log.<span class="hljs-property">outstanding</span> == <span class="hljs-number">0</span>)&#123;<br>    do_commit = <span class="hljs-number">1</span>;<br>    log.<span class="hljs-property">committing</span> = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// begin_op() may be waiting for log space,</span><br>    <span class="hljs-comment">// and decrementing log.outstanding has decreased</span><br>    <span class="hljs-comment">// the amount of reserved space.</span><br>    <span class="hljs-title function_">wakeup</span>(&amp;log);<br>  &#125;<br>  <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br><br>  <span class="hljs-keyword">if</span>(do_commit)&#123;<br>    <span class="hljs-comment">// call commit w/o holding locks, since not allowed</span><br>    <span class="hljs-comment">// to sleep with locks.</span><br>    <span class="hljs-title function_">commit</span>();<br>    <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>);<br>    log.<span class="hljs-property">committing</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">wakeup</span>(&amp;log);<br>    <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_log</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; tail++) &#123;<br>    struct buf *to = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// log block</span><br>    struct buf *<span class="hljs-keyword">from</span> = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[tail]); <span class="hljs-comment">// cache block</span><br>    <span class="hljs-title function_">memmove</span>(to-&gt;data, <span class="hljs-keyword">from</span>-&gt;data, <span class="hljs-variable constant_">BSIZE</span>);<br>    <span class="hljs-title function_">bwrite</span>(to);  <span class="hljs-comment">// write the log to disk</span><br>    <span class="hljs-title function_">brelse</span>(<span class="hljs-keyword">from</span>);<br>    <span class="hljs-title function_">brelse</span>(to);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">commit</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">write_log</span>();     <span class="hljs-comment">// 用 header 缓存更新log缓存</span><br>    <span class="hljs-title function_">write_head</span>();    <span class="hljs-comment">// 用更新后的log缓存 -- the real commit</span><br>    <span class="hljs-title function_">install_trans</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 用log缓存更新 header 缓存</span><br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">write_head</span>();    <span class="hljs-comment">// Erase the transaction from the log</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// file.h</span><br>struct inode &#123;<br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  int ref;            <span class="hljs-comment">// Reference count</span><br>  struct sleeplock lock; <span class="hljs-comment">// protects everything below here</span><br>  int valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  short type;         <span class="hljs-comment">// copy of disk inode</span><br>  short major;<br>  short minor;<br>  short nlink;<br>  uint size;<br>  uint addrs[<span class="hljs-variable constant_">NDIRECT</span>+<span class="hljs-number">1</span>];<br>&#125;;<br>    <br><span class="hljs-comment">// Contents of the header block, used for both the on-disk header block</span><br><span class="hljs-comment">// and to keep track in memory of logged block# before commit.</span><br>struct logheader &#123;<br>  int n; 一般用于判断是否真的需要往disk里写东西<br>  int block[<span class="hljs-variable constant_">LOGSIZE</span>]; <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-variable constant_">BSIZE</span> <span class="hljs-number">1024</span><br><span class="hljs-variable constant_">LOGSIZE</span> <span class="hljs-number">30</span><br><span class="hljs-variable constant_">MAXOPBLOCKS</span> <span class="hljs-number">10</span><br><br>struct log &#123;<br>  struct spinlock lock;<br>  int start;<br>  int size;<br>  int outstanding; <span class="hljs-comment">// how many FS sys calls are executing，可以理解为往disk输送的调用有几个.</span><br>  int committing;  <span class="hljs-comment">// in commit(), please wait.</span><br>  int dev;<br>  struct logheader lh; <br>&#125;;<br>struct log log;<br><br><span class="hljs-comment">// Read the log header from disk into the in-memory log header</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">read_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *lh = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> = lh-&gt;n;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] = lh-&gt;block[i];<br>  &#125;<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br><br><span class="hljs-comment">// Write in-memory log header to disk.</span><br><span class="hljs-comment">// This is the true point at which the</span><br><span class="hljs-comment">// current transaction commits.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *hb = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  hb-&gt;n = log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    hb-&gt;block[i] = log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i];<br>  &#125;<br>  <span class="hljs-title function_">bwrite</span>(buf);<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br><br><span class="hljs-comment">// 更新缓存里的header</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">install_trans</span>(<span class="hljs-params">int recovering</span>)<br>&#123;<br>  int tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; tail++) &#123;<br>    struct buf *lbuf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// read log block，这里的log.start+tail+1是log block no</span><br>    struct buf *dbuf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[tail]); <span class="hljs-comment">// read dst，因为这里的log.lh.block[tail]就是文件系统数据block no</span><br>    <span class="hljs-title function_">memmove</span>(dbuf-&gt;data, lbuf-&gt;data, <span class="hljs-variable constant_">BSIZE</span>);  <span class="hljs-comment">// copy block to dst</span><br>    <span class="hljs-title function_">bwrite</span>(dbuf);  <span class="hljs-comment">// write dst to disk</span><br>    <span class="hljs-keyword">if</span>(recovering == <span class="hljs-number">0</span>)<br>      <span class="hljs-title function_">bunpin</span>(dbuf);<br>    <span class="hljs-title function_">brelse</span>(lbuf);<br>    <span class="hljs-title function_">brelse</span>(dbuf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看下write_head，bread会往该缓存blokc
buf加睡眠锁，该睡眠锁持续时间挺长，然后bwrite正在写入buf数据到disk，最好释放该睡眠锁。</p>
<p>如果这里不用睡眠锁，使用自旋锁可以吗？</p>
<p>不可以，首先这里锁的加的时间挺长，和磁盘交互时间一般是比较大的，也就是说这段时间不会让出cpu，但cpu下导致其他进程被迫等待；且自旋锁加锁期间不允许中断，这意味着bread和bwrite将永远无法完成和disk的交互</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *hb = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  hb-&gt;n = log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    hb-&gt;block[i] = log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i];<br>  &#125;<br>  <span class="hljs-title function_">bwrite</span>(buf);<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于缓存链表：block
cache的实现，这对于性能来说是至关重要的，因为读写磁盘是代价较高的操作，可能要消耗数百毫秒，而block
cache确保了如果我们最近从磁盘读取了一个block，那么我们将不会再从磁盘读取相同的block。</p>
<p>brelese函数中首先释放了sleep
lock；之后获取了bcache的锁；之后减少了block
cache的引用计数，表明一个进程不再对block
cache感兴趣；最后如果引用计数为0，那么它会修改buffer
cache的linked-list，将block
cache移到linked-list的头部，这样表示这个block cache是最近使用过的block
cache。这一点很重要，当我们在bget函数中不能找到block
cache时，我们需要在buffer cache中腾出空间来存放新的block
cache，这时会使用LRU（Least Recent Used）算法找出最不常使用的block
cache，并撤回它（注，而将刚刚使用过的block
cache放在linked-list的头部就可以直接更新linked-list的tail来完成LRU操作）。为什么这是一个好的策略呢？因为通常系统都遵循temporal
locality策略，也就是说如果一个block
cache最近被使用过，那么很有可能它很快会再被使用，所以最好不要撤回这样的block
cache。</p>
<p>以上就是对于block cache代码的介绍。这里有几件事情需要注意：</p>
<ul>
<li><strong>首先在内存中，对于一个block只能有一份缓存。这是block
cache必须维护的特性。</strong></li>
<li>其次，这里使用了与之前的spinlock略微不同的sleep
lock。与spinlock不同的是，可以在I/O操作的过程中持有sleep lock。</li>
<li>第三，它采用了LRU作为cache替换策略。</li>
<li>第四，<strong>它有两层锁。第一层锁用来保护buffer
cache的内部数据；第二层锁也就是sleep
lock用来保护单个block的cache。</strong></li>
</ul>
<figure>
<img
src="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM5MmY4ZmJlOGQyZmY2YmQ5ZGQzMDVhNjk0ODkzYjhfbFZmNHpuUnZ4QXVRT0V2akJuUmlIeVJ6OVEwSnNUeGJfVG9rZW46UDZ6TmJTeGJkb0JMMEF4eGt3cmNxWnJVbnhjXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA" srcset="/emocoder/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>以创建为例，其整体的调用链路如下：</p>
<figure>
<img
src="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYzZWQ0NTkwN2M2MWQ0NmVlMjYwYmY5NmY4OGMzOWFfUEVaWEVMTFFoNWVJemszRVVLdzE5dERhV1BEeDBLRWlfVG9rZW46SllybmJSY2Fnb3FUMlF4eTg2S2NQM2c0blVkXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA" srcset="/emocoder/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>关键在于</p>
<ol type="1">
<li>每一个系统调用之间都会有begin_op和end_op，begin_op表明想要开始一个事务，在最后有end_op表示事务的结束。并且事务中的所有写block操作具备原子性，这意味着这些写block操作要么全写入，要么全不写入。</li>
<li>和文件相关的和inode的代码都在bio.c里，比如创建文件是ialloc，写入文件是walloc</li>
<li>inode对应buffer cache
linklist里的一个buf节点，其数据存在data成员上，其存储的block再blockno上</li>
<li>每一次commit都是commit一个inode（即一个文件，一个blockno，根据一个inode即可算出对应的blockno）以及相关的logheader</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/emocoder/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/emocoder/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-C/">#操作系统，计算机基础, C</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>File system</div>
      <div>https://mingmingjiang1.github.io/emocoder/2023/10/05/oslearning/mit-6.s081/filesys/fs/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>迷途知返</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/emocoder/2023/10/05/oslearning/mit-6.s081/booting/main/" title="xv6 Booting">
                        <span class="hidden-mobile">xv6 Booting</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/emocoder/js/events.js" ></script>
<script  src="/emocoder/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/emocoder/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/emocoder/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/emocoder/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
