<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 1 register allocation</title>
    <link href="/emocoder/2023/05/20/register-allocation/"/>
    <url>/emocoder/2023/05/20/register-allocation/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>中间代码使用了无限制的临时变量</p><ul><li>简化了代码生成和优化</li><li>复杂了向汇编转换的过程</li></ul><p>实际情况寄存器是有限的，不能无限制的使用，所以在向汇编转换的时候使用有限的寄存器。</p><blockquote><p>Register allocation is as old as compilers</p><ul><li>Register allocation was used in the original FORTRAN compiler in the‘50s</li><li>Very crude algorithms</li></ul><p>A breakthrough came in 1980 – Register allocation scheme based ongraph coloring – Relatively simple, global and works well inpractice</p></blockquote><p><strong>思路：</strong></p><ul><li>将多个临时变量分配给同一个寄存器</li><li>同时不改变原来的语义</li></ul><p>考虑如下程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := c + d<br>e := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br>f : = e - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果仅仅使用三个寄存器的话，这里假设a和e在使用完之后立马dead：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r2</span> + <span class="hljs-built_in">r3</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> + <span class="hljs-built_in">r4</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给众多的临时变量分配有限的寄存器并且相互不冲突这是重中之重：</p><ul><li>如果在程序在某个运行点临时变量t1和t2不同时存活，那么t1和t2可以共享相同的寄存器</li><li>否则，t1和t2不能同时分配给一个寄存器</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152040397.png"alt="image-20230520152040397" /><figcaption aria-hidden="true">image-20230520152040397</figcaption></figure><p>基于之间的活跃变量分析构建无向图(寄存器干扰图, RIG)：</p><ul><li>节点是临时变量</li><li>边表示这两个节点对应的变量同时在某个时刻存活</li><li>如果节点之间没有边，说明节点可以共享一个寄存器</li></ul><p>如下：</p><ul><li>例如，b和c不能在同一寄存器中</li><li>例如，b和d可以在同一寄存器中</li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050602.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>RIG构建完成后，寄存器分配算法与体系架构无关，不依赖任何机器属性</p></blockquote><h2 id="图染色">图染色</h2><p>图着色是对节点的颜色分配，使得通过边连接的节点具有不同的颜色</p><p>如果一个图可以用k种颜色按照上述规则着色，则该图形为k−colorable（这里的颜色就是寄存器，k为寄存器数量）</p><p>进一步的，如果RIG是k−colorable，则存在不超过k个寄存器的寄存器分配。</p><p>图染色算法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The following works well <span class="hljs-keyword">in</span> practice:<br>  – Pick <span class="hljs-keyword">a</span> node t <span class="hljs-keyword">with</span> fewer than k neighbors<br>  – Put t <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">stack</span> <span class="hljs-title">and</span> <span class="hljs-title">remove</span> <span class="hljs-title">it</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">RIG</span><br>  – Repeat <span class="hljs-keyword">until</span> <span class="hljs-keyword">the</span> graph has <span class="hljs-literal">one</span> node<br>Assign colors <span class="hljs-built_in">to</span> nodes <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">stack</span><br>  – Start <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> node added<br>  – At <span class="hljs-keyword">each</span> step pick <span class="hljs-keyword">a</span> color different <span class="hljs-built_in">from</span> those assigned<br>  <span class="hljs-built_in">to</span> already colored neighbors<br></code></pre></td></tr></table></figure><p>下面这张图里第四个才符合题意</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050704.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="变量溢出">变量溢出</h2><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152930506.png"alt="image-20230520152930506" /><figcaption aria-hidden="true">image-20230520152930506</figcaption></figure><p>在这种情况下，我们无法将所有值都保存在寄存器中，这个时候会选择一些变量放入内存；其他变量继续图染色，这些溢出的变量将会有以下操作：</p><p><strong>选择哪些变量溢出呢？</strong></p><p>可能的启发式方法：</p><ul><li>spill冲突最多的临时变量（这个时候边比较多）</li><li>spill定义和用途很少的临时变量（因为很少用，放到内存里，也无伤大雅）</li><li>在内部循环中避免spill（因为循环里一直会复用缓存或者寄存器，如果spill了变量到内存，可能会很大程度降低运行速度，见下面缓存部分）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span> <span class="hljs-keyword">each</span> operation that reads f, <span class="hljs-keyword">insert</span><br>f := <span class="hljs-keyword">load</span> fa<br><span class="hljs-keyword">After</span> <span class="hljs-keyword">each</span> operation that writes f, <span class="hljs-keyword">insert</span><br>store f, fa<br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152957854.png"alt="image-20230520152957854" /><figcaption aria-hidden="true">image-20230520152957854</figcaption></figure><p>重新计算活跃变量：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153015201.png"alt="image-20230520153015201" /><figcaption aria-hidden="true">image-20230520153015201</figcaption></figure><blockquote><p>New liveness information is almost as before</p><p>​ – Note f has been split into three temporaries</p><p>fi is live only</p><p>​ – Between a fi := load fa and the next instruction</p><p>​ – Between a store fi, fa and the preceding instr.</p><p>Spilling reduces the live range of f</p><p>​ – And thus reduces its interferences</p><p>​ – Which results in fewer RIG neighbors</p></blockquote><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153209988.png"alt="image-20230520153209988" /><figcaption aria-hidden="true">image-20230520153209988</figcaption></figure><h2 id="管理缓存">管理缓存</h2><p>缓存的速度介于寄存器和内存中间，可作为缓冲存在，如果没有缓冲的话，寄存器和内存直接交互，由于访问内存的速度远远小于访问寄存器的速度，这样整个程序会是相对较慢的，所以缓存很重要；</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520151753508.png"alt="image-20230520151753508" /><figcaption aria-hidden="true">image-20230520151753508</figcaption></figure><p>通常情况下，寄存器和内存交互的值，会放在缓存里，每次寄存器访问数据先去缓存里查找，如果没有，才去内存里查找，如果缓存一直没有命中，那么缓存也就失去了它的价值。</p><ul><li>编译器非常擅长管理寄存器<ul><li>比程序员要好得多</li></ul></li><li>但是编译器不善于管理缓存<ul><li>这个问题仍然留给程序员</li><li>尚有一个未解决的问题，编译器可以做些什么来提高缓存性能</li></ul></li></ul><p>考虑如下程序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>上面的代码由于内部循环很大，而且每次i都会变化，如果缓存没有足够的大小，那么a[i]和b[i]就一直命中不了缓存；相反，下面的代码在10次以内，一定都是可以缓存的，速度至少比上面代码快10倍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++)<br><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>像这种交换for循环的优化，很少有编译器实现，因为难以发现什么样的循环可以优化，事实上，大部分情况下，还是需要程序员自己去优化这种case的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>automatic-memory-management</title>
    <link href="/emocoder/2023/05/20/automatic-memory-management/"/>
    <url>/emocoder/2023/05/20/automatic-memory-management/</url>
    
    <content type="html"><![CDATA[<h2 id="引出">引出</h2><p>自动内存管理也称之为垃圾回收(garbage collection)</p><p>手动管理内存有很多出乎意料的bug：</p><ul><li>忘记释放没有被使用的内存</li><li>忘记去掉一些无用引用，或者是野指针</li><li>偶然的内存覆盖</li><li>...</li></ul><p>内存相关bug很难发现(比如内存溢出，就需要排查很长时间)</p><p>🌰：</p><p>某个对象没有被引用了，但是对应的指针还在；突然后面该对象被覆盖了，但是指针仍然引用这块内存，这个时候使用这个指针的读写还是按照原来的类型进行读写，就很容易出现错误(原类型是8bit大小，现在的类型是16bit大小这种情况)</p><p>如何自动管理内存呢？</p><p>思路：当一个对象被创建的时候就会同时分配空间；但是当没有足够的空间可用的时候，是否可以复用那些没有被使用(引用)的对象的空间呢？</p><p>我们如何得知一个对象"没有被再次使用呢"</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> x: A &lt;- new A <span class="hljs-keyword">in</span> &#123; x &lt;- y; ... &#125;<br></code></pre></td></tr></table></figure><p>上面的代码里newA生成的A对象后面被覆盖了，这个A对象就是没有被再次使用的对象(这里不考虑其他代码，仅考虑本行代码)，x和y共同引用一个对象。这个A对象被称作为不可达对象</p><p>不可达对象定义，当且仅当：</p><ul><li>存在寄存器指向了对象x，或者</li><li>存在某一个可达对象y指向这个x</li></ul><p>考虑如下代码：if分支始终为True</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>;<br>y &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>;<br>x &lt;- y;<br><span class="hljs-keyword">if</span> alwaysTrue() then x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> <span class="hljs-keyword">else</span> x.foo() fi<br></code></pre></td></tr></table></figure><p>假设在<code>x &lt;- y</code> 之后，y是非活跃变量，这里：</p><ul><li>A是不可达的</li><li>B是可达的，通过x，但是B之后再也没有被使用过；</li></ul><p>所以，判断可达和不可达只是一种近似手段；</p><p>可以通过以寄存器为起点遍历引用链，寻找所有可达对象(为什么以寄存器为起点，因为只有保存在寄存器的变量才说明是参与计算的活跃的对象)，总的来说，有以下几种比较常见的垃圾回收算法：</p><ul><li>标记清除(mark and sweep)</li><li>复制转移(stop and copy)</li><li>引用计数(reference count)</li></ul><p>前两种都是内存耗尽的时候，才垃圾回收；引用计数不是等待内存耗尽的才开始进行，在没有指针指向该对象时尝试收集该对象</p><h2 id="mark-and-sweep标记清除">mark and sweep(标记清除)</h2><p>标记清除有两个步骤：</p><ul><li>the mark phase: 找到可达对象(rearchable objects)</li><li>the sweep phase: 收集可回收对象</li></ul><p>实现方式：</p><p>每个对象有一个额外的标记是否可回收的bit位</p><ul><li>该bit位初始化为0</li><li>在mark phase期间，对于所有的可达对象设置为1</li></ul><p><strong>mark phase:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> todo = &#123;<span class="hljs-keyword">all</span> roots&#125;<br><span class="hljs-keyword">while</span> todo != 空集 <span class="hljs-keyword">do</span><br>pick v 属于 todo<br>todo &lt;- todo - &#123;v&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">mark</span>(v) == <span class="hljs-number">0</span> then<br><span class="hljs-keyword">mark</span>(v) &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> v1, v2, ..., <span class="hljs-keyword">vn</span> <span class="hljs-keyword">be</span> the pointers contained in v<br>todo &lt;- todo 并集 &#123;v1, v2, ..., <span class="hljs-keyword">vn</span>&#125;<br>fi<br>od<br></code></pre></td></tr></table></figure><p><strong>sweep phase:</strong></p><p>清除阶段扫描堆空间里可以清除的对象(也就是比特标记仍为0的对象)，这些对象是不可达的，可以被视作"垃圾"。这些垃圾对象可以在清除阶段形成一段链表(可以避免堆内存碎片)</p><p>清除阶段过后，之前被设置为1的对象应该重置为0，方便下一次垃圾回收。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">siseof</span><span class="hljs-params">(p)</span></span> is the size of block starting at p，<span class="hljs-built_in">sizeof</span>(p)表示p对象所占据的大小，这里默认大部分情况下对象的内存布局是连续的<br><br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-attribute">bottom</span> of heap<br>while <span class="hljs-selector-tag">p</span> &lt; <span class="hljs-attribute">top</span> of heap fp<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">mark</span>(p) == <span class="hljs-number">1</span> then<br><span class="hljs-selector-tag">mark</span>(p) &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span><br>add block <span class="hljs-selector-tag">p</span>...(<span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p) - <span class="hljs-number">1</span>) to freelist<br>fi<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p)<br>od<br><br>这一段代码的大概意思就是从堆的起点开始出发，直到堆的终点，如果发现p为<span class="hljs-number">1</span>，则重置为<span class="hljs-number">0</span>；否则，说明是垃圾对象，把<span class="hljs-selector-attr">[start, start + sizeof(p)]</span>的内存串到freelist链表里，在每一轮结束后，别忘了对p增加本次对象的偏移量<br></code></pre></td></tr></table></figure><p>🌰：这里假设只有一个寄存器，初始的时候寄存器指向A对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>标记阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>清除阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>以上普通标记-清除的缺点：</p><p>由于一旦使用该算法的时候，已经是内存不够用了，然而在<strong>标记阶段</strong>还要借用内存去维护todo这样一个数据结构，并且这个结构的大小是不受控制的，有可能有许多垃圾需要回收，这是和垃圾回收的目的相悖的</p><p><strong>改进：</strong></p><p>todo这样的数结构可否不开辟新的空间？</p><p>todo这个数据结构是为了寻找可达对象，那么可否直接遍历对象引用图，把可达对象的bit标志位设置为呢？</p><p>对图dfs遍历，但是引用是大部分情况下是单向的，如何在图里回溯(在遍历的同时反转链表，这样回溯的时候沿着反转指针即可)，这里实际操作的时候需要注意借用临时变量(寄存器)去存储当前遍历节点，以便下一个节点使用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cur.next</span> = tmp(反转) // 连接上一个节点<br><span class="hljs-attr">tmp</span> = cur<span class="hljs-comment">; // 现在tmp是当前节点，给下一个节点使用</span><br><span class="hljs-attr">cur</span> = cur.next<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>对象在被分配的时候一般按如下规则进行分配：</p><ul><li>挑选尽量大的空间块</li><li>按需分配</li><li>顺序且连续分配，比如有100个bit大小的自左向右的连续内存空间，现在要分配50bit给某个对象，那么分配的就是前50bit</li></ul></blockquote><p>标记—清除的优势：</p><ul><li>碎片化内存，更多的使用内存碎片，减少空间利用率</li><li>对象在垃圾回收的时候不需要移动，也就是对应的指针也不会变化(这在一些允许自己手动管理内存的语言很重要，如C，C++，不会引起歧义)</li></ul><h2 id="stop-and-copy">stop and copy</h2><p>内存被划分为两块：</p><ul><li>old space: 用于分配内存</li><li>new space: 为垃圾回收备用</li></ul><p>另外有一个heap pointer, 总是指向oldspace的下一个可用空间，所以，分配内存仅仅在增加heap pointer</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520103417917.png"alt="image-20230520103417917" /><figcaption aria-hidden="true">image-20230520103417917</figcaption></figure><p>stop and copy的特点：</p><ul><li>仅仅从old space copy可达对象到newspace(所以当垃圾很多的时候，这种算法效率很高)</li><li>垃圾被留在了old space</li><li>在copy之后，new space比垃圾回收之前的old space占用的空间更少</li><li>在copy结束之后，old space和new space交换</li><li>由于需要移动scan pointer和allocpointer，和标记-清除一样，需要知道对象的大小</li><li>由于对象被移动了，函数堆栈里的相关指针必须更新</li></ul><p>每次copy之后，需要更新被copy对象内部的指针，因为其指向后续也会发生copy才对，如何让其指针引用的对象指向最新的已经copy的对象？可以在每个对象增加一个关于转移指针的字，如果对象发生了copy，那么转移指针有值且指向最新的地址，</p><blockquote><p>总结：转移指针就是存在于旧对象里指向新拷贝对象的一个指针，作用是方便后续引用该对象的指针能够根据转移指针正确更新，另外就是标记旧的对象已经被拷贝了</p></blockquote><p>所以stop and copy的目标是寻找到所有的可达对象并copy至newspace，对于当前copy对象，还需要更新其内部的所有指针</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520111956200.png"alt="image-20230520111956200" /><figcaption aria-hidden="true">image-20230520111956200</figcaption></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">while</span> scan &lt;&gt; alloc <span class="hljs-keyword">do</span><br><span class="hljs-keyword">let</span> O be the <span class="hljs-type">object</span> at scan pointer<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> pointer p contained <span class="hljs-keyword">in</span> O <span class="hljs-keyword">do</span><br>find O<span class="hljs-comment">&#x27; that p points to</span><br><span class="hljs-keyword">if</span> O<span class="hljs-comment">&#x27; is without a forwarding pointer</span><br>copy O<span class="hljs-comment">&#x27; to new space (update alloc pointer)</span><br><span class="hljs-keyword">set</span> a word <span class="hljs-keyword">of</span> old O<span class="hljs-comment">&#x27; to point the new copy (这一步就是标记旧的对象已经被拷贝了)</span><br>change p <span class="hljs-keyword">to</span> point <span class="hljs-keyword">to</span> the <span class="hljs-built_in">new</span> copy <span class="hljs-keyword">of</span> O<span class="hljs-comment">&#x27;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> p <span class="hljs-keyword">in</span> O equal <span class="hljs-keyword">to</span> the forwarding pointer<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">for</span><br>increment scan pointer <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> <span class="hljs-type">object</span><br>od<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>相对比较快，尤其垃圾比较多的时候，因为只需要处理可达对象</li><li>分配内存是简单且快速的，因为只需要增加heap pointer</li></ul><p>缺点：</p><ul><li>一些语言，如C和C++不允许对象拷贝，以及指针转移，<strong>因为指针作为对象语义的一部分在程序中公开</strong></li></ul><p>针对C和C++不允许对象拷贝，以及指针转移，有一些Conservativecollection技术</p><h2 id="引用计数">引用计数</h2><p>在没有耗尽内存的时候就开始对对象的引用数（每个分配操作都会引起引用计数），进行计数，一旦计数为0，说明该对象需要被回收了。</p><p><code>rp(x)为x的引用计数</code></p><p>每个赋值<code>x &lt;- y</code> ，这里假设x,y对象分别指向o和p：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(p)</span></span> &lt;- <span class="hljs-built_in">rc</span>(p) + <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(o)</span></span> &lt;- <span class="hljs-built_in">rc</span>(o) + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rc</span>(o) == <span class="hljs-number">0</span>) then free o<br>x &lt;- y<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>易于实现</li><li>增量收集垃圾，而不会在执行过程中出现大量的停顿，因为它在没有耗尽内存的时候就开始对对象的引用数，每次赋值语句都可能会引起垃圾回收，但是每次的垃圾都是增量变化的，并不会占据很多时间。</li></ul><p><strong>缺点：</strong></p><ul><li>无法处理循环引用</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">x -&gt; A <span class="hljs-operator">=</span>&gt; B <span class="hljs-operator">=</span>&gt;A<br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> null<br></code></pre></td></tr></table></figure><p>上面语句里，x是一个指针引用了A，而A又引用了B，当x不再指向A的时候，由于A和B的引用计数始终不为0，所以没有办法回收A和B</p><ul><li>在每次分配时处理引用计数有的时候比较慢，如果一个赋值一句牵连到了很多对象，那么引用计数就会计算这些对象，可以在编译的时候优化这些赋值语句，比如如果有一个对象的两次更新，可以优化成一次，这样就会计算一次引用计数了。</li></ul><h2 id="总结">总结</h2><p>自动内存管理可防止严重的存储错误</p><p>But，也减少了程序员对内存的控制：</p><ul><li>例如，内存中的数据布局</li><li>例如，何时重新分配内存</li></ul><p>常见的自动内存管理问题：</p><ul><li>实时应用里可能由于垃圾回收时间过长出现短暂的程序停止</li><li>内存泄漏，一般多是程序员没有及时回收"野"对象</li></ul><p>有一些更高级的垃圾回收算法：</p><ul><li>concurrent: 垃圾回收的同时允许程序运行</li><li>generational：不会扫描长期存活对象（v8里就有）</li><li>real time: 减少因为垃圾回收引起的程序停止的下界</li><li>parallel: 允许多个垃圾回收器同时运行；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 3 cool-optimize</title>
    <link href="/emocoder/2023/05/14/cool-optimize/"/>
    <url>/emocoder/2023/05/14/cool-optimize/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><hr /><h2 id="中间代码">中间代码</h2><p>什么是中间代码？一般常指介于高级语言(源语言)和低级语言(汇编语言)的一种语言</p><ul><li>Provides an intermediate level of abstraction<ul><li>More details than the source</li><li>Fewer details then the target</li></ul></li></ul><p>source lang =&gt;intermediate lang =&gt; target lang</p><p>intermediate lang = high-level assembly</p><ul><li>uses register names, but has unlimited number</li><li>Uses control structures like assemblly language</li><li>uses opcodes but some are higher level<ul><li>Eg: push translates to serveral assembly instructions</li><li>most opcodes correspond directly to assembly opcodes</li></ul></li></ul><p>每个指令都是以下两种形式之一(三地址码)：</p><ul><li>x := y op z</li><li>x := op y</li></ul><p>🌰：表达式 x + y * z可以转换成如下中间代码形式(每一个子表达式都有一个(寄存器)名称)：</p><ul><li><p>t1 := y * z</p></li><li><p>t2 := x + t1</p></li></ul><p><strong>总结</strong></p><p>中间代码的好处：与机器无关，可以在中间代码实现优化，提高了程序在不同系统架构之间迁移的可能性</p><h2 id="优化">优化</h2><p>Optimization is complex and largest phase</p><p>Parsing =&gt; Semantic =&gt; Opt =&gt; Gen</p><p>什么时候做优化？</p><ul><li>On AST ?<ul><li>Pro: Machine independent</li><li>Cons: Too high level</li></ul></li><li>On assembly lang ?<ul><li>Pro: Exposes optimization oppotunities</li><li>Cons: Machine dependent</li><li>Cons: Must reimplement optimizations when retargetting</li></ul></li><li>On intermediate lang ?<ul><li>Pro: machine independent</li><li>Pro: Exposes optimization oppotunities</li></ul></li></ul><p><strong>Basic Block:</strong> is a maximal sequence of instructionswith:</p><ul><li>no labels (except at the first instructions), and</li><li>no jumps (except at the last instructions)</li></ul><blockquote><p>其实就是指一段除了起始入口和末尾跳转(退出)指令没有其他跳转(退出)指令的一段指令集</p></blockquote><p>A basic block is a single-entry, single-exit, straight-line codesegment</p><blockquote><p>单一入口，单一出口，一行一行执行的程序段</p></blockquote><p><strong>control-flow graph</strong>：is a directed graph with:</p><ul><li>Basic blocks as nodes</li><li>An edge from block A to block B if the execution can pass from thelast instruction in A to the first instruction in B</li></ul><p>​ eg:</p><ul><li>the last instruction in A is <code>jump LabelB</code></li><li>execution can fall through from block A to block B (在blockA执行失败了后跳转到了block B)</li></ul><p>优化的好处：</p><ul><li>提高执行时间</li><li>减小代码体积</li><li>减少网络传输量</li><li>减小内存的使用</li><li>减小硬盘的使用（存储汇编代码文件）</li><li>减少硬件使用的电量 (这也可以，...)</li></ul><p>优化的三个粒度：</p><ul><li>local optimizations (局部优化)<ul><li>Apply to a basic block isolation</li></ul></li><li>global optimizations (全局优化)<ul><li>Apply to a control-flow in isolation</li></ul></li><li>Inter-procedural optimizations<ul><li>Apply across method boundaries</li></ul></li></ul><p>实际情况下：很难实现一个非常理想化的优化算法</p><ul><li>为什么？<ul><li>某些优化难以实现</li><li>某些优化会花费大量的编译时间</li><li>一些优化的回报很低</li><li>很多花哨的优化同时满足这三点</li></ul></li></ul><h2 id="局部优化">局部优化</h2><p>优化基本block，不涉及整个代码，比较简单</p><p><strong>algebra optimization (代数优化)</strong></p><p>有些运算可以被另一些更快的运算代替：</p><p>x := x * 8 =&gt; x := x &lt;&lt; 3</p><p><strong>Constant fold（常数折叠）</strong></p><p>Operations on constants can be computed at compile time:</p><ul><li>if there is a statement x := y op z</li><li>and y and z constants</li><li>then y op z can be computed at compile time</li></ul><p>Eg: x := 2 + 2 =&gt; x := 4; if 2 &lt; 0 jump L can be deleted</p><p>常数折叠也并不安全，因为会存在交叉编译的情况：</p><p>在X架构上编译到架构Y上运行，编译后的产物在X上运行和在Y上运行可能会产生不同的结果</p><p>X: a : = 1.2 + 6.9 经过常数折叠后=&gt; a := 8.1</p><p>Y: a: = 8</p><p><strong>单一赋值形式</strong>：每一个寄存器名称仅仅出现在一次在赋值语句的左侧</p><p>x := z + b := z + y</p><p>a := x =&gt; a := b</p><p>x := 2 * x x := 2 * b</p><p>这里有一个很重要的概念，和变量活跃度有关：Single assigment form</p><p>基于这个假设：如果基本块是以单一赋值形式出现的，即 <code>x:=</code>是在该块内仅有的一次为x赋值</p><p>那么当块内出现了相同的右侧表达式，这个表达式就是重复的（<strong>Commonsubexpression elimination</strong>）</p><p>🌰: 这个例子里x，y和z的值在省略号里是不会改变的</p><p>x := y + z x := y + z</p><p>... =&gt; ...</p><p>w := y + z w := x</p><p><strong>Copy propagatation（拷贝传播）</strong></p><p>假设基本块是以单一赋值形式存在的：</p><p>if w := x appears in a block, replace subsequent uses of w with usesof x</p><p>🌰:</p><p>b := z + y b := z + y</p><p>a := b =&gt; a := b</p><p>x := 2 * a x := 2 * b</p><p><strong>Dead code elimination</strong></p><p>上面的<code>a := b</code>对代码结果没什么恭喜，可以删除</p><p><strong>Unresearchable code delete</strong></p><p>删除不可达代码，减小代码体积</p><p>Eg:不可能走的条件分支语句；导入了一个包里所有的工具，但是有没有用(有点类似treeshaking)</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>代数优化后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050407.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>拷贝传播后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>常数折叠：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050411.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>公共子表达式删除：</p><p>最终：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050416.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="peephole-optimization">Peephole Optimization</h2><h2 id="全局优化">全局优化</h2><p>为了在基本块之间用常数k代替变量x，编译器必须知道每条使用变量x路径的最后一个关于x的赋值语句<code>x := k</code>～～</p><p>对于全局优化，全局常量传播应该在～～处执行</p><p>所以全局优化的目标就是找到所有的～～</p><p>定义如下形式化符号：</p><table><thead><tr class="header"><th>value</th><th></th></tr></thead><tbody><tr class="odd"><td>$ $</td><td>This statement never executes（还没执行，一般用于初始化）</td></tr><tr class="even"><td>$ C $</td><td>X = C (C is constant)</td></tr><tr class="odd"><td>$$</td><td>X is not a constant（已执行，但是不确定具体值）</td></tr></tbody></table><p><strong>常数拷贝：</strong>常数拷贝是很有用的因为它可以使得一些变量直接转换成常量，从而减少寄存器的使用，但是在控制图里，判断一个变量是否可以被替换成常量是困难的</p><p>一种思路是一个变量的信息和它的上下文有关（前后语句） <spanclass="math display">\[C(s, x, in) = value \quad of \quad x \quad before \quad s  \quad在语句s之前变量x的信息\]</span></p><p><span class="math display">\[C(s, x, out) = value \quad of \quad x \quad after \quad s \quad在语句s之后变量x的信息\]</span></p><p>由于课本上的规则过于复杂，本人总结了以下规则rules：</p><ul><li>针对某个节点的入度，有以下几种情况：<ol type="1"><li>如果其入度节点其中有一个是T，则该节点信息为T</li><li>如果其入度节点存在常量，但是均不相等，则该节点信息为T</li><li>如果其入度节点存在节点固定为某个常量，且其入度节点不为T，则该节点也为该常量</li><li>如果其入度节点均为unknown，则该节点为unknown</li></ol></li><li>针对某个节点的出度，<ol start="5" type="1"><li><p>入度为unknown，则出度也为unknown</p></li><li><p>在s语句赋值为某个常量，则出度为该常量</p></li><li><p>在s语句赋值为某个非常量表达式，则出度为T</p></li><li><p>s语句如果没有对入度节点做任何更改，则出度=入度</p></li></ol></li></ul><p><strong>伪代码描述常量传播：</strong></p><blockquote><p>For every entry s to the program,，set C(s, x, in) = <spanclass="math inline">\(\top\)</span> set C(s, x, in) = C(s, x, out) =<span class="math display">\[\perp\]</span> everywhere else repeat utilall points satisfy 1-8： Pick s not satisfying 1-8 and update using theappropriate rule</p></blockquote><p><strong>为什么要引入$ $？</strong></p><p>由于循环，循环的每个点都需要值存在</p><p>直觉上，分配一些初始值去打破循环</p><p>$ $表示直到目前为止，控制流程还没有到达当前点；</p><p><spanclass="math inline">\(\top\)</span>事一种抽象值，因为不知道运行的时候具体的值，</p><p>C之间是不可比较的</p><p><span class="math inline">\(\top\)</span>是最大的，$ $是最小的</p><p><strong>符号形式化：</strong></p><p>对是$ ,, C$进行排序： <span class="math display">\[\perp &lt; C &lt; \top\]</span> 可以形象化如下：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520134741534.png"alt="image-20230520134741534" /><figcaption aria-hidden="true">image-20230520134741534</figcaption></figure><p>定义 <code>lub</code> 运算： 在这个层级规则下的最小上界</p><p><code>lub(x, y, z, ..)</code>：大于等于x,y,z,...的最小值</p><p>部分可以写作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">C(<span class="hljs-params">s</span>, <span class="hljs-params">x</span>, <span class="hljs-params">in</span>)</span> = lub &#123; <span class="hljs-constructor">C(<span class="hljs-params">p</span>, <span class="hljs-params">x</span>, <span class="hljs-params">out</span>)</span> <span class="hljs-pattern-match">| p is a predecessor <span class="hljs-keyword">of</span> s &#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure><p>🌰：</p><p><code>Lub(到, 1) = 1</code></p><p><code>Lub(T, 1) = 1</code></p><p><code>Lub(1, 2) = T</code></p><p>之前简单的说一直重复直到没什么东西发生变化才停止是不准确，不规范的；</p><p>正式描述应该使用lub，lub为什么是正确的？</p><ul><li>values start as 到 and only increase</li><li>$ $ can change to a constant, and a constant to <spanclass="math inline">\(\top\)</span></li><li>Thus, <code>C(s, x, _)</code> can change at most twice</li></ul><p>常量拷贝算法是的时间复杂度和程序大小成正比</p><blockquote><p>Number of steps =</p><p>Number of C(...) values computed * 2 =✖️2是因为每个语句的最多算两次</p><p>Number of program statements * 4 ✖️2是因为每个语句的in and out</p></blockquote><p><strong>变量生存分析：</strong></p><p>从程序退出节点开始分析，向上回溯节点，</p><ol type="1"><li>如果当前节点包含出度的活跃变量的赋值语句，则当前节点的入度，就不会在有这个活跃变量(因为重新赋值了，之前的相当于是deadcode，可以被视为dead variable)；</li><li>如果当前节点的rfs（右表达式）包含某个变量，则这些变量是活跃变量；</li></ol><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050601.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">有两个exit节点，initNode = </span><span class="hljs-template-variable">&#123; a, b &#125;</span><span class="language-xml">, lives = </span><span class="hljs-template-variable">&#123; b &#125;</span><span class="language-xml">，开始自底向上分析</span><br><span class="language-xml"></span><br><span class="language-xml">b = f + c 使用了f和c，产生了b，根据规则2，入度里f和c是活跃变量，根据规则1入度里b不是活跃变量 </span><span class="hljs-template-variable">&#123;f, c&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">f = 2 * e 使用了e，根据规则2，入度里e是活跃变量，f是新的赋值，根据规则1入度里f不是活跃变量，格局规则3，c的活跃不发生变化 </span><span class="hljs-template-variable">&#123;c, e&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">b = d + e，使用了d和e，根据规则2，d和e是活跃变量，而b被赋值了，c和f未出现1在左侧，所以</span><span class="hljs-template-variable">&#123;c,d,e,f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = e + 1, 使用了e，根据规则1，e是活跃变量，而c和f以及b都是其后续节点需要的，所以</span><span class="hljs-template-variable">&#123;b, c, e, f &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于分支处，取并集得：</span><span class="hljs-template-variable">&#123;b, c, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于f = 2 * e的入度，f被重新赋值，而e是被用的，所以</span><span class="hljs-template-variable">&#123; c, e &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">同理对于 b = d + e和e = e + 1的入度，其活跃变量已经计算过：</span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">取并集的e = d + f的出度 </span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = d + f的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, d, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">d = -a 的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, a, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">a = b + c的入度 =&gt; </span><span class="hljs-template-variable">&#123;f, c, b&#125;</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>变量分析是自底向上，从程序的退出节点回溯的，因为程序退出的时候，可能希望某些变量依旧保存</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 2 cool-semantics</title>
    <link href="/emocoder/2023/05/14/cool-semantics/"/>
    <url>/emocoder/2023/05/14/cool-semantics/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出。</p><p>接下来的课程比较"符号化"</p><h2 id="引言">引言</h2><p>类比：</p><p>parser阶段，我们要给每种token设置对应的action</p><p>语法分析阶段，有一系列的文法式，要在每个文法式规约的时候设置action，规定对应的行为</p><p>类型分析阶段：对每一种表达式设置对应的语义动作，进行语义分析</p><p>同样的优化阶段：对每一种表达式设置对应的代码生成及优化动作。</p><p>如何形式化表示这些表达式对应动作（语义，我理解就是表达式的动作）</p><blockquote><p>Denotational semantics: 数学函数表示</p><p>Axiomatic semantics: 通过逻辑公式描述程序行</p><p>Operational sematics: 通过执行规则描述程序评估</p></blockquote><h2 id="操作语义">操作语义</h2><p>在类型推断和检查的时候，引进过这样一种符号： <spanclass="math display">\[Context \vdash e: C在给定大的上下文context里，表达式是类型C\]</span>同样的，评估阶段(代码生成阶段之前的准备工作)，也会用类似的符号： <spanclass="math display">\[Context \vdash e: v在给定大的上下文context里，表达式会被评估为值v\]</span> 🌰： <span class="math display">\[\frac{Context \vdash e1: 5 \quadContext \vdash e2: 7}{Context \vdash e1 + e2: 12}\]</span> &gt;在语境Context下e1被评估为5，e2被评估为7，那么e1+e2就是12，当然这种是常量比较简单哈，没什么用处，实际情况下有变量的情况下就复杂了；&gt;</p><p>考虑评估：y &lt;- x + 1</p><p>由于存在局部作用域，所以评估一个值，需要：</p><p>Environment: where in memory a variable is</p><p>Store: what is in the memory</p><p>简单来说就是两个映射表：</p><p>Enviroment：va r =&gt; loc</p><p>Store: loc =&gt; value</p><p>形式化表示：</p><p><span class="math display">\[E = [a: l1, b: l2] \quad 变量a在内存中的l1处，b在内存的l2处 \\S = [l1 =&gt; 5, l2 =&gt; 7] \quad l1处存储的值是5，l2处存储的值是7 \\S&#39; = S[l2/l1] \quad defines \quad a \quad store \quadS&#39;\quad  such \quad that \\ S&#39;(l1) = 12 \quad and\quad  S&#39;(l) = S(l) \quad  if \quad l \neq l1 \\简单理解下S&#39;就是S在l1处做了单点修改\]</span></p><h2 id="cool里的语义">cool里的语义</h2><p>cool里面值都是对象（cool是面向对象的语言）</p><p><code>X(a1 = l1, ..., an = ln)</code> 表示为一个cool 对象，其中</p><ul><li><p>X是类</p></li><li><p>ai是其属性，包含继承的属性</p></li><li><p>li是对应ai被存储的内存位置</p></li></ul><p><strong>cool内置类：</strong></p><ul><li>Int(5),</li><li>Bool(true)</li><li>String(4, "cool") the string "Cool" of length 4</li><li>特殊值：void，该对象上没有方法，如果调用isvoid将会抛出异常，cool里对void的具体实现时NULL（Cpp里的空指针，因为cool是用cpp实现的）</li></ul><p>考虑如下评估式： <span class="math display">\[{so, E, S \vdash e: v, S&#39;}\]</span> so(self object)， E 是当前的变量环境，S是当前Store；</p><p>e获得了评估结果后值是v，并且新的store是S‘</p><p>评估的结果实际是值v和新的Store，新的Store是有副作用(副作用是值引用修改，而不是copy)</p><p>但是在评估后有一些事不会改变的：</p><ul><li><p>变量环境</p></li><li><p>self</p></li><li><p>操作语义允许递归</p></li></ul><p>下面具体介绍了cool的一些操作语义评估，我就简单那几个比较经典的：</p><hr /><p><strong>变量使用</strong>：在E中找到id的位置，然后在S中找对应的值<span class="math display">\[\frac{E(id) = I_{id} \quadS(I_{id}) = v}{so, E, S \vdash id: v, S}\]</span> ------</p><p><strong>self:</strong> <span class="math display">\[{so, E, S \vdash self: so, S}\]</span> ------</p><p><strong>变量赋值：</strong>就是对id处做单点修改返回新的Store，id的评估结果就是e的评估结果v<span class="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadE(id) = I_{id} \quadS_2 = S_1[v/id]}{so, E, S \vdash id=e: v, S2}\]</span> e1+e2：先递归对e1评估，评估后e1的值是v1，并产生新的StoreS1，接着对e2递归进行评估，评估后e2的值是v2，并产生新的StoreS2，最终e1+e2的评估结果就是值为v1 + v2，新的Store S2 <spanclass="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadso, E, S1 \vdash e: v2, S_2}{so, E, S \vdash e1 + e2: v1 + v2, S2}\]</span> ------</p><p>🌰：{ X = 7 + 5; 4;}</p><p>先对一个表达式X=7+5评估 <span class="math display">\[{so, [X&lt;-1], [l&lt;-0] \vdash x=7+5: ?, ?}\]</span> 继续递归对7+5进行评估 <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: ?, ?}\]</span> 继续递归对7评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7: Int(7), [l&lt;-0]}\]</span> 同样的对5评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 5: Int(5), [l&lt;-0]}\]</span></p><p>返回到上一层7+5: <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: Int(12), [l&lt;-0]}\]</span> 继续返回到上一层x=7+5：</p><p>这个时候已经处理完了7+5，继续处理x，这是声明变量，得到单点更新后的Store：<span class="math display">\[[l&lt;-0](12/l) =&gt; [l/12]\]</span> 这个时候子表达式都处理完了，继续处理最外层的第一个表达式 <spanclass="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash x=7+5: 12, [l&lt;-12]}\]</span> 继续处理同级别的表达式4 <span class="math display">\[{so, [X&lt;-l], [l&lt;-12] \vdash 4: Int(4), [l&lt;-12]}\]</span></p><p><span class="math display">\[\frac{...}{so, [X&lt;-1], [1&lt;-0] \vdash \{X=7+5;4;\}: Int(4),[1&lt;-12]}\]</span></p><hr /><p><strong>if-else</strong></p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173710435.png"alt="image-20230514173710435" /> <span class="math display">\[\frac{so, E, S \vdash e1: Bool(false), S1}{so, E, S \vdash while \quade1 \quad loop \quad e2 \quad pool: void, S1}\]</span> ------</p><p><strong>while</strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173719883.png"alt="image-20230514173719883" /><figcaption aria-hidden="true">image-20230514173719883</figcaption></figure><hr /><p><strong>声明变量：</strong> <span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad so, ?, ? \vdash v, S2}{so, E, S\vdash let \quad id: T = e1 \quad in \quad e2: v2, S2}\]</span> e2应该在什么环境下评估呢（问号处应该填什么呢）？</p><p>—仍然是E，但是E里应该新增映射<code>id =&gt; Inew</code>，表示为id新分配了一块内存，同样的Store应该是有新的映射<code>Inew =&gt; v1</code></p><p>新增符号：Inew =newloc(S)，表示Inew是一个新分配的内存，newloc可以理解为是一个内存分配函数<span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad I_{new} = newloc(S1) \quad  so,E[I{new}/id], S1[v1/I_{new}] \vdash v2, S2}{so, E, S \vdash let \quadid: T = e1 \quad in \quad e2: v2, S2}\]</span></p><hr /><p><strong>new对象的评估语义：</strong></p><ul><li><p>首先，为对象的所有参数分配内存（本质上就是分配对象）</p></li><li><p>为对象设置缺省值</p></li><li><p>评估对象的初始化语句，并重新设置属性值</p></li><li><p>返回被分配的对象</p></li></ul><p>每个对象都有默认值</p><ul><li><p>int： Int(0)</p></li><li><p>bool: Bool(false)</p></li><li><p>String: String(0, '')</p></li></ul><p>类A的形式化表示：</p><p><code>class(A) = (a1: T1 &lt;-e1, ..., an: Tn &lt;- en)</code>，其中：</p><ul><li><code>ai</code>是属性，包含继承属性</li><li><code>Ti</code>是属性的类型</li><li><code>ei</code>是初始化表达式</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173910377.png"alt="image-20230514173910377" /><figcaption aria-hidden="true">image-20230514173910377</figcaption></figure><p>在评估初始化表达式阶段：</p><ul><li><p>self is the current object</p></li><li><p>only the attributes are in scope()，作用域内只有属性</p></li><li><p>属性的初始值都是默认值，主要是防止在初始化语句里面会用到这些初始值，比如:<code>Class A &#123; a &lt;- a &#125;</code>，用a初始化a，如果a没有默认值，可能会有异常；</p></li></ul><p>Informal semantics of class e0.f(e1, ..., en)：</p><ul><li><p>首先，依次评估参数e1, ..., en，</p></li><li><p>评估e0，获得e0的值</p></li><li><p>假设X是e0评估结果的动态类型</p></li><li><p>从dispatch table中获取f</p></li><li><p>为n个参数分配内存空间，更新Enviroment</p></li><li><p>为分配的空间初始化值</p></li><li><p>set selft to the target object and evaluate f's body</p></li></ul><p>For a class <code>A</code> and a method f of <code>A</code> (possibleinherited)</p><p><code>impl(A, f) = (X1, ..., Xn, ebody)</code>，其中：</p><ul><li><code>Xi</code>是形式参数</li><li><code>ebody</code>是方法体(函数体)</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514174645616.png"alt="image-20230514174645616" /><figcaption aria-hidden="true">image-20230514174645616</figcaption></figure><p><u>impl</u>有没有可能获取不到方法？不可能，因为类型检查以已经通过了，倘若没有类型检查，这一阶段会更复杂</p><p>当然也有一些runtime error类型检查检查不到：</p><ul><li><p>A dispathc on void</p></li><li><p>Division by zero</p></li><li><p>Substring out of range</p></li><li><p>Heap overflow</p></li></ul><p>这些异常情形下，编译器必须抛出错误，并中断，而不是崩溃(not with asegfault)</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 1 cool object layout</title>
    <link href="/emocoder/2023/05/14/cool-object-layout/"/>
    <url>/emocoder/2023/05/14/cool-object-layout/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><ul><li>Introduction to code gen</li><li>code gen 1</li><li>code gen 2</li></ul><h2 id="temporaries">Temporaries</h2><p>之前介绍的汇编代码比如两个表达式相加：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">a0</span> (<span class="hljs-number">0</span>)$<span class="hljs-built_in">sp</span><br>li $<span class="hljs-built_in">t0</span> ?<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span> $<span class="hljs-built_in">sp</span><br></code></pre></td></tr></table></figure><p>这里把其中一个加数放在了stack里，然后取出来，再把计算的中间结果放在了stack里，这就是临时变量</p><p>最普通的<strong><code>堆栈机</code></strong>需要在函数栈帧暂存这些临时变量（虽然这并不高效，后面会讲解关于临时变量分配到寄存器的算法）</p><p>考虑下面代码使用了多少临时变量：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = <br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">1</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">0</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">2</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">1</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>) ==&gt; x-<span class="hljs-number">1</span>是一个，x-<span class="hljs-number">2</span>是一个，两式相加，会产生一个，所以共两个<br><span class="hljs-attribute">fi</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>定义NT(e)为表达式e需要多少个临时变量</p><p>对于一个函数定义：<code>f(x1, ..., fn) = e</code>，the AR has<code>2 + NT(e)</code> elements:</p><ul><li>Return</li><li>Frame pointer</li><li>n arguments</li><li>NT(e)</li></ul><p>以下是一些常见的规则：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NT(<span class="hljs-params">e1</span> + <span class="hljs-params">e2</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>)<br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e1</span>)</span><br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span><br>Of course, space used <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e1 can be reused <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e2<br><br><span class="hljs-constructor">NT(<span class="hljs-params">if</span> <span class="hljs-params">e1</span> = <span class="hljs-params">e2</span> <span class="hljs-params">then</span> <span class="hljs-params">e3</span> <span class="hljs-params">else</span> <span class="hljs-params">e4</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e3</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e4</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>(<span class="hljs-params">e1</span>, <span class="hljs-operator">...</span>, <span class="hljs-params">en</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, ..., <span class="hljs-constructor">NT(<span class="hljs-params">en</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">int</span>)</span> = <span class="hljs-number">0</span><br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>)</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在没有使用临时变量之前：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> - <span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>使用了临时变量之后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(e1 + e2, nt) = <br>cgen(e1, nt)<br>sw <span class="hljs-variable">$a0</span> nt(<span class="hljs-variable">$fp</span>) <span class="hljs-regexp">//</span> 在偏移量处做压入栈<br><span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> - <span class="hljs-number">4</span> 这样就不用了频繁执行addiu了<br>cgen(e2, nt + <span class="hljs-number">4</span>)<br>lw <span class="hljs-variable">$t1</span> nt(<span class="hljs-variable">$fp</span>)<br>add <span class="hljs-variable">$a0</span> <span class="hljs-variable">$t1</span> <span class="hljs-variable">$a0</span><br>  <span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$a0</span> <span class="hljs-variable">$sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="object-layout-and-dynamic-dispatch">Object Layout and dynamicdispatch</h2><p>OO(Objetc Oriented) Implementation = Basic code generation + morestuff(面向对象的实现其实就是之前所介绍的基本代码生成+本次要讲的内容)</p><p>OO Slogan：如果A是B的子类，那么B类对象可以用于任何A类的地方：</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b</span> <span class="hljs-title">extends</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span> <span class="hljs-params">(A a)</span> &#123;<br><br>&#125;<br><br>函数f的入参可以是A及其子类<br></code></pre></td></tr></table></figure><p>这就意味着在代码生成的时候，在已经生成完了A类的代码，那么B类(A的子类)可以不用修改其父类(A)的代码，而只是在其基础上进行扩展。</p><p>再介绍对象的代码生成之前，需要考虑以下问题：</p><p><code>对象在哪村里如何表示？</code></p><ul><li><p>Objects are laid out int contiguous memory;</p></li><li><p>Each attribute stored at a fixed offset in the object;</p></li><li><p>The attribute is in the same place in every object of thatclass;</p></li><li><p>When a method is invoked, the object is self and the fields arethe object's attributes;</p></li></ul><blockquote><p>为什么对象每个属性都是固定的偏移量呢？这要归结于同一个类可以new多个对象，但这些对象的数据内存是各自独有的，每个对象同一个属性在固定偏移量的内存处，方便获取；而方法是共享的，所以方法单独维护在了一张methodstable中，每个对象都都持有指向这个methods table的指针dispatchpointer，不然不同的对象还要维护各自的方法，这样太费内存了。</p></blockquote><p><code>如何实现动态分配?</code></p><p>Method table and dispatch ptr</p><p>关于动态分配和静态分配的概念：https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/</p><p>其实node里也有静态分配和动态分配的概念：</p><p>wip</p><p><strong>首先介绍下对象布局</strong></p><p>考虑如下🌰，以下内容均围绕该🌰展开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">class <span class="hljs-selector-tag">A</span> &#123;<br><span class="hljs-selector-tag">a</span>: Int &lt;- <span class="hljs-number">0</span>;<br>d: Int &lt;- <span class="hljs-number">1</span>;<br>f(): Int &#123; <span class="hljs-selector-tag">a</span>&lt;- <span class="hljs-selector-tag">a</span> + d &#125;;<br>&#125;<br><br>class <span class="hljs-selector-tag">B</span> &#123;<br> <span class="hljs-selector-tag">b</span>: Int &lt;- <span class="hljs-number">2</span>;<br> f(): Int &#123; <span class="hljs-selector-tag">a</span> &#125;;<br> g(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span> &#125;;<br>&#125;<br><br>class C &#123;<br>c: Int &lt;- <span class="hljs-number">3</span>;<br>h(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> * c &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>cool objects layout: (下面内存是连续的)</p><table><thead><tr class="header"><th style="text-align: center;">Class tag(int) 类标识符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Object size(int)</td></tr><tr class="even"><td style="text-align: center;">Dispatch ptr</td></tr><tr class="odd"><td style="text-align: center;">Attribute 1</td></tr><tr class="even"><td style="text-align: center;">Attribute 2</td></tr><tr class="odd"><td style="text-align: center;">...</td></tr></tbody></table><p>其中前3个称为header infomation</p><p>关于继承的子类的内存布局：考虑父类A，其子类B可以通过在A布局之上进行扩展得到，如下：</p><blockquote><p>B is an extension， just leaves the layout of A unchanged</p></blockquote><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th><th>8</th><th>12</th><th>16</th><th>20</th></tr></thead><tbody><tr class="odd"><td>A</td><td>Atag</td><td>5(word)</td><td>dispatch ptr1</td><td>a</td><td>d</td><td></td></tr><tr class="even"><td>B</td><td>Btag</td><td>6(word)</td><td>dispatch ptr2</td><td>a</td><td>d</td><td>b</td></tr><tr class="odd"><td>C</td><td>Ctag</td><td>6(word)</td><td>dispatch ptr3</td><td>a</td><td>d</td><td>c</td></tr></tbody></table><p>The offset for an attribute is the same in a class and all of itssubclass</p><p><strong>介绍下动态分配</strong></p><p>考虑e.f(), 这个表达式e生成之后，该如何调用对象上的方法呢？</p><p>和属性布局一样，对象的方法同样在内存上有着固定的偏移量(包含继承的方法)，只不过这些方法是存在一张dispatchtable里的(其实我个人喜欢称之为methodtable)，这张表提供了索引这些方法的能力，表里存储的是函数地址，如，方法f就是在其附属类的表里的固定偏移量处，当然在其子类也是同样的偏移量；</p><p>为什么同一方法在类和其子类中设计成固定的偏移量呢？wip</p><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th></tr></thead><tbody><tr class="odd"><td>A</td><td>fa</td><td></td></tr><tr class="even"><td>B</td><td>fb</td><td>g</td></tr><tr class="odd"><td>C</td><td>fa</td><td>h</td></tr></tbody></table><p>注：如果fa中海定义了其他方法，则可以</p><p>类的每个方法f都在编译期被分配在dispatch table的固定偏移量O_f处，换句话说，编译器的工作就是找出类的所有方法然后给每个方法分派一个固定的位置。</p><p>综上，为了实现dynamic dispatch<code>e.f()</code>，编译器应该走以下两个步骤：</p><ol type="1"><li>评估表达式e，得到一个对象x；</li><li>call <code>D[Of]</code><ul><li>D is the disptatch table for x</li><li>in the call ,self is bound to x</li></ul></li></ol><h2 id="总结">总结</h2><p>在学习完之后，我们考虑下如果是我们该如何为以下代码设计代码生成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>a: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">1</span>;<br>f(): <span class="hljs-type">Int</span> &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">1</span>) &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>b: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">10</span>;<br>g(): int &#123; b;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>m: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">2</span>;<br>f(): int &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">2</span>)&#125;;<br>&#125;<br><br>b: <span class="hljs-type">B</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br>b.g();<br><br>c: <span class="hljs-type">C</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>();<br>c.f();<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">评估b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new B();</span><br><span class="hljs-attribute">初始化</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table1</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><span class="hljs-attribute">g</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__g</span><br><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br><span class="hljs-attribute">评估c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new C();</span><br><span class="hljs-attribute">初始化c</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table2</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">m</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><br><br><span class="hljs-attribute">dispath table2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br>b.g();<br>获取b对象的dispatch table1<br>拿到g方法<br>调用即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug</title>
    <link href="/emocoder/2023/05/07/debug/"/>
    <url>/emocoder/2023/05/07/debug/</url>
    
    <content type="html"><![CDATA[<h2 id="日志工具">日志工具</h2><p>开发者使用： trace：打印调用堆栈debug：不仅打印调用堆栈，还打印变量信息</p><p>用户使用： info warn：只是警告，但是不影响运行error：报错，但是不影响整个应用程序的继续运行 fatal:中断整个应用程序的执行</p><p>首先</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端，node，调试，debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hacktech</title>
    <link href="/emocoder/2023/05/06/hacktech/"/>
    <url>/emocoder/2023/05/06/hacktech/</url>
    
    <content type="html"><![CDATA[<p>内网渗透+爆破：https://blog.csdn.net/m0_46684679/article/details/117854834</p><p>安全集锦：https://www.zhihu.com/column/c_1334810805263515648</p><p>网络防火墙：https://zhuanlan.zhihu.com/p/159088465</p><p>格式: echo -e "\033[字背景颜色;字体颜色m字符串\033[0m"</p><p>-e对特殊字符做转义</p><p>eg: echo -e "\033[41;36m something here \033[0m"</p><p>其中41的位置代表底色, 36的位置是代表字的颜色</p><p>正则通配符和linux通配符是不一样的，<em>（星号）是linux中的通配符，代表一个或一个以上的所有字符。linux的隐藏文件和隐藏文件夹都是以.（点号）开头，所以.</em>应该是代表当前目录下的所有隐藏目录和隐藏文件夹。如果是./*则表示当前目录下的所有文件和所有目录，因为.（点号）还有代表当前目录的意思</p><p>https://zhuanlan.zhihu.com/p/96272363，日志应该是最初开发的一部分其次，结束调试不要删除日志</p><p>写日志的地方： 关键方法调用：时间和调用参数 上下游对接处可能存在异常的地方</p><p>其他console方法： console.count: 用于计算函数被调用的次数console.log.countReset</p><p>console.group: 用于折叠 console.groupCollapsed() console.groupEnd</p><p>consoel.time() console.timeEnd()</p><p>console.table()</p><p>console.dir(obj, { depth: })</p><h2 id="chrome-devtools">Chrome Devtools</h2><p>Network: 查看，过滤网络请求列表，查看请求详情 模拟弱网环境搜索headers以及response内容 使用requeset block</p><p>Source 查看加载的资源文件 编辑css和js，修改css和js snippets管理断点调试 通过workspace关联到本地</p><ol type="1"><li><p>如何让source里的文件树看起来更清晰——查看author-deployed，但是项目必须有source-map</p></li><li><p>如何让call stack中仅出现关心的文件 ——debug ignore list在实际操作里，在stepin的过程中，如果遇到了一个不想调试的文件直接右击文件的代码区域，addignore list，下一次step in的时候就不会出现这个文件了，</p></li></ol><p>如何恢复？ ——顶级settings，找到ignore list</p><ol start="3" type="1"><li><p>如何对js的修改，reload之后还可以生效——overrides，选择本地目录添加到overrides中，</p></li><li><p>如何找出哪一行代码影响了我的元素 ——dom change breakponits比如找到哪一行删除了某个dom节点：右击某个dom节点——》break on-》noderemoval</p></li><li><p>如何找出哪一行代码发起了请求 ——source面板找到xhr/fetchbreakpoints，输入拦截的url即可</p></li><li><p>异常断点：source面板找到break points，勾选pause oncaught/uncaught points 捕获的or未捕获的</p></li><li><p>事件断点 全局事件：source面板找到event listener breakpoints，选择相应的事件即可</p></li><li><p>如何打断点，不会中断？ source 面板，某一行，右击选择edit breakpoints =》选择log points，输入想打印的语句即可</p></li></ol><p>字颜色:30-----------37 30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色36:深绿 37:白色</p><p>字背景颜色范围:40----47 40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色46:深绿 47:白色</p><p>字体加亮颜色:90------------97 90:黑 91:红 92:绿 93:黄 94:蓝色 95:紫色96:深绿 97:白色</p><p>背景加亮颜色范围:100--------------------107 40:黑 41:深红 42:绿43:黄色 44:蓝色 45:紫色 46:深绿 47:白色</p><p>===============================================ANSI控制码的说明\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m反显 \33[8m 消隐 \33[30m -- \33[37m 设置前景色 \33[40m -- \33[47m设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行\33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l隐藏光标 \33[?25h 显示光标</p><p>1b[2J1b[$;1H $表示行位</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透，爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXS</title>
    <link href="/emocoder/2023/05/05/xxs/"/>
    <url>/emocoder/2023/05/05/xxs/</url>
    
    <content type="html"><![CDATA[<p>XSS (Cross-sitescripting)，即跨站脚本攻击，应该是前端同学都应该听过的网络安全相关的名词。它是一种尝试注入恶意脚本代码到网站上的攻击形式。它可以使得恶意使用者的代码在受影响用户的浏览器端执行，并对用户的影响。原本简称css，为了与前端的级联样式表(cascader style sheet)区分，改称 xss。</p><h2 id="xss-类型">XSS 类型</h2><p>XSS 大致可以分为 3 个类型</p><p>反射型 （Reflected XSS Attacks） 此种类型的跨站代码存在于 URL中，所以黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。</p><p>存储型（Stored XSS Attacks） 存储型 XSS 脚本攻击是指 Web应用程序会将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，因此存储型XSS 具有较强的稳定性。</p><p>DOM-based 型（DOM-based XSS Attacks） DOM-based的跨站脚本攻击是通过修改页面 DOM 节点数据信息而形成的跨站脚本攻击。</p><p>为了更加深切的近距离体验xss，可以登陆下https://xss-game.appspot.com/level3，这个游戏是 Google提供的一个 XSS的小游戏，大家可以自己在浏览器里试试看能不能闯过所有的关卡（可以通过研究Target Code 来找到可以注入代码的地方，如果想不出来可以看看页面上的Hints）。建议尽量不要看提示来挑战。这个游戏一共有 6关，每个关卡利用了各种不同的技巧和方式来插入恶意代码，有些方式确实非常取巧。</p><p>level1: 通过在 query 里拼接 script 元素，而前端代码又是会展示这个query 的，所以没有过滤的话，就直接运行脚本了，直接利用了 url插入脚本，属于反射型</p><p>level2: 用户提交 blog 或者评论，前端会展示这些评论或者 blog，虽然script 元素不会展示，但是像 dom 节点，如 a，img 元素还是会展示的，利用了dom，属于 dom 型，也可以理解为存储型，和存储相关。</p><p>level3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chooseTab</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// Dynamically load the appropriate image.</span><br>  <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;Image &quot;</span> + <span class="hljs-built_in">parseInt</span>(num) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>  html += <span class="hljs-string">&quot;&lt;img src=&#x27;/static/level3/cloud&quot;</span> + num + <span class="hljs-string">&quot;.jpg&#x27; /&gt;&quot;</span>;<br>  $(<span class="hljs-string">&quot;#tabContent&quot;</span>).<span class="hljs-title function_">html</span>(html);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用了在浏览器直接输入 url 的漏洞，前端代码会用 url 里的参数作为 img元素的属性直接拼接，由于没有对这些参数做转义，所以可能会导致恶意代码插入，由于利用了dom 元素，属于 dom 型</p><p>level4: 服务端模板包含如下代码：<img src="/static/loading.gif" onload="startTimer('');"/&gt;而timer是从url的参数里取的，如果这个timer包含了其他的js脚本代码，就会有问题，如下：https://xss-game.appspot.com/level4/frame?timer=')%3Balert(1)%3Bvarb=('</p><p>=&gt; startTimer('');alert(1);var b=('');</p><p>level5: 前端脚本： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; next &#125;&#125;&quot;</span>&gt;</span>Next &gt;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>前端直接利用url的参数拼接成了a元素的href属性：https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</p><p>level6: 服务端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInnerText</span>(<span class="hljs-params">element, value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">innerText</span>) &#123;<br>    element.<span class="hljs-property">innerText</span> = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element.<span class="hljs-property">textContent</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">includeGadget</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">var</span> scriptEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br>  <span class="hljs-comment">// This will totally prevent us from loading evil URLs!</span><br>  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^https?:\/\//</span>)) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&#x27;Sorry, cannot load a URL containing &quot;http&quot;.&#x27;</span><br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Load this awesome gadget</span><br>  scriptEl.<span class="hljs-property">src</span> = url;<br><br>  <span class="hljs-comment">// Show log messages</span><br>  scriptEl.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>), <span class="hljs-string">&quot;Loaded gadget from &quot;</span> + url);<br>  &#125;;<br>  scriptEl.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&quot;Couldn&#x27;t load gadget from &quot;</span> + url<br>    );<br>  &#125;;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(scriptEl);<br>&#125;<br><br><span class="hljs-comment">// Take the value after # and use it as the gadget filename.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGadgetName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;/static/gadget.js&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">includeGadget</span>(<span class="hljs-title function_">getGadgetName</span>());<br></code></pre></td></tr></table></figure><p>这里本来想直接插入script元素的，但是行不通，只有通过script的src外链加载外域脚本：htTps://pastebin.com/raw.php?i=15S5qZs0https://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw.php?i=15S5qZs0</p><h2 id="更进一步地实验">更进一步地实验</h2><p>因为现在大部分的前后端框架都会有 XSS相关的安全策略，且默认是开启的，平时想要测试一下 XSS的漏洞可能还比较麻烦。针对这种情况，可以使用 Damn Vulnerable WebApplication（https://github.com/digininja/DVWA），它是一个主动关闭了各种安全策略的Web 应用，包括了各种各样漏洞，当然也包括 XSS的部分，可以用来测试自己对这些漏洞的掌握。</p><p>防范手段 防御 XSS一大原则就是不要信任用户输入的内容！所有用户输入的内容都可以默认为不可控的、不安全的，包括但不限于表单输入/URL 等可以由用户任意输入的来源。在回显用户的输入时候一定要做XSS 的过滤和相应的编码。</p><h2 id="浏览器内置的安全机制">浏览器内置的安全机制</h2><p>开启 X-XSS-Protection：针对反射型 XSS的一种浏览器防御机制，现在大部分现代浏览器已经废弃了这个属性。</p><p>内容安全策略 CSP：CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS 攻击所依赖的载体。一个 CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本(包括内联脚本和 HTML 的事件处理属性) 浏览器的同源策略。</p><p>Cookie 安全：设置 Cookie 的 HttpOnly 属性，能够最大限度的保证你的Cookie 不会被脚本所读取并发送到其他服务器上。</p><h2 id="使用成熟的框架安全机制">使用成熟的框架安全机制</h2><p>对于前端来说，使用常用的库，React/Vue/Angular等流行框架来渲染数据基本上都不会有太大的问题。需要注意的是，必须非常非常非常慎重使用类似React 的 dangerouslySetInnerHTML 或者 Vue 的 v-html 这类绕过 XSS过滤能力的属性。</p><p>不少后端服务的框架也都在设计时就考虑了 XSS 的安全问题，如 Ruby onRails。当然这类防御措施还是有其局限性的，并不是能一劳永逸的解决所有攻击威胁的。</p><h2id="在没有框架安全机制保证下需要避免的操作">在没有框架安全机制保证下需要避免的操作</h2><p>对于前端来说，主要需要针对处理的是 DOM-based 的 XSS 威胁。</p><p>在使用 Vanilla JavaScript 需要避免那些能够直接修改 HTML 的操作，如innerHTML/outerHTML 属性或者 document.write之类的方法。当需要展示文本的时候，选择如 textContent/innerText之类安全的方法。当需要创建 HTML 标签的时候，选择createElement/appendChild 之类的方法。</p><p>还有就是更加危险的 eval方法，虽然一般不会使用，但是需要避免一些隐式的 eval 使用，比如setTimeout/setInterval 就可以通过 setTimeout(codeAsString, delay)的形式执行任意字符串代码。</p><p>除此之外还有 HTML 标签上的一些事件属性等等。</p><p>如果无可避免的要使用类似方法，一定在渲染前做好过滤和编码工作。</p><h2 id="更加细致的防范-cheatsheet">更加细致的防范 CheatSheet</h2><p>开放式 Web 应用程序安全项目 （ OWASP）提供了针对 XSS 防御的详尽CheatSheet，感兴趣的同学可以作为参考。</p><p>https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.htm</p><p>https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html</p><h2 id="安全检测">安全检测</h2><p>一些工具可以扫描网站存在的 XSS 漏洞，可以方便查缺补漏</p><p>https://github.com/s0md3v/XSStrike</p><p>https://www.zaproxy.org/</p><h2 id="最后的最后">最后的最后</h2><p>需要注意，以上这些防御措施不能详尽描述每个细节和抵御所有 XSS攻击方式。针对 XSS的攻防战没有一劳永逸的银弹，也没有傻瓜式的解决方案。只有严格遵照安全最佳实践来尽量避免，并提升安全防范的意识，加强安全审计的工作。</p><p>钓鱼攻击： 主要是发生在提交的 HTMl内容的时候带有一些其他的域名地址，这些域名地址存在钓鱼的风险。 防范方式通过 securitykit.surl 方法进行校验，该方法对非白名单的地址进行剔除。</p><p>XSS防御方案最好是在编译时合运行时提供相关的预防方案：编译时预防开发人员出现存在安全漏洞的代码；运行时尽量不相信用户的任何输入</p><ul><li>运行时：提供运行时过滤API，能够过滤不在白名单上的标签以及常见的伪协议字符串。</li><li>编译时：提供 Babel 插件进行 AST 风险点识别，在风险点中包裹运行时过滤API，起到自动防御的能力。</li></ul><h2 id="参考文章">参考文章：</h2><p>https://blog.dornea.nu/2014/06/02/googles-xss-game-solutions/</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端，xxs，跨站脚本攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git checkout 妙用</title>
    <link href="/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/"/>
    <url>/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>当你在 Git中处理一个仓库时，你可能需要从另一个分支中获取（checkout）一个指定的文件。</p><p>幸运的是，Git提供了许多可能的方法来快速完成这项任务。其中一个最简单的解决方案是使用gitcheckout命令，将指定的文件作为一个参数。</p><p>在这篇文章中，我们将分析这个问题的不同解决方案，并介绍每一种解决方案所需要遵循的流程。</p><p>让我们开始吧。😎</p><p>Git Checkout 用例你正在处理一个名为feature/A的分支，其中包含一个名为utils.js的文件。</p><p>你有另一个名为feature/B的分支，里面有一个更新的utils.js文件。</p><p>你想签出该文件，并将其从feature/B分支带到feature/A分支。</p><p>下面是这个任务的三种可行的解决方案。</p><p>解决方案 1：使用 git checkout 命令 gitcheckout命令提供了一个简单的方法来从另一个分支获取文件或文件夹。</p><p>以下是从另一个分支获得（checkout）文件的语法：</p><p>git checkout <other-branch-name> -- path/to/your/folder以下是要遵循的流程：</p><ol type="1"><li>切换（checkout）到你想复制文件的那个分支。</li></ol><p>git checkout feature/A 2. 你在当前分支上，复制该文件。</p><p>git checkout feature/B -- utils.js 3. 使用gitstatus命令来确保文件已经被复制了。</p><ol start="4" type="1"><li>提交并推送到远程。</li></ol><p>在使用 checkout 命令时，你也可以得到：</p><p>一个来自另一个分支的文件夹。 通过指定每一个文件，可以指定多个文件另外，请注意，你可以从 stash 获得一个文件/文件夹。</p><p>解决方案 2：使用 git restore 命令 另一个选择是使用git switch命令和gitrestore命令。</p><p>如果你从未听说过这两个命令，那也没关系。它们是比较新的。Git 在 2019年的 2.23 版本中引入了它们。</p><p>这两个命令的目的是减少使用 git checkout命令，以简化用户的工作。</p><p>git restore命令可以恢复工作树。</p><p>git switch命令切换分支。</p><p>下面是从另一个分支获取文件的过程：</p><ol type="1"><li>切换到你想获取（checkout）文件的分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git restore --source feature/B -- utils.js 3. 提交并推送更改。</p><p>解决方案 3：使用 git show 命令 最后，我们可以使用git show命令。</p><p>以下是要遵循的流程：</p><ol type="1"><li>切换到工作分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git show feature/B:path/utils.js &gt; path/utils.js 3.提交并推送更改。</p><p>注意: 这次你需要指定来自你的目录根的相对路径。</p><p>小结正如你所看到的，从另一个分支获取一个文件并不是什么像发射火箭那样困难。</p><p>当我在日常生活中需要这样做时，我通常使用git checkout命令。</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node从头手写一个简单编译器</title>
    <link href="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>使用语言：node本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><p>结果示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来从以下几个方面介绍：</p><ol type="1"><li>parser：包含正则表达式生成和词法token生成</li><li>semantic：文法推导式解析和抽象语义树生成</li><li>check：语法和类型校验</li><li>gen：汇编代码生成</li></ol><h2 id="parser">parser</h2><p>在词法分析阶段，输入是字符串，输出是 token流，一开始设计输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学在构建自动机过程中，自动机把输入流转成token流，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级，这里的优先级比较简单，直接遍历终态节点数组endStates(可以理解为叶子节点)，遇到第一个符合的即返回，所以正则的优先级和前后顺序有关；</p><p>那么如何构建自动机？我们的目标是构建一系列单个正则表达式单元nfa，然后联合成一个大的nfa单元，这个nfa可以解析我们的之前正则单元，再得到联合nfa的邻接矩阵edges，最后根据edges转成dfa，具体步骤如下：</p><p>首先，需要名明确的是，我们的词法分析器支持以下几个单元： +: a+, <em>:a</em>, 连接: ab， 逻辑或: a|b， 字符集: [a-z]支持少部分字符转义，如：, t, </p><p>如何把正则表达式构建为nfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个元外加一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是单个字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack进行存储，类比括号匹配算法。(<code>lib =&gt; parser =&gt; nfa =&gt; flex函数</code>)</p><h3 id="构建基本正则单元">构建基本正则单元</h3><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>: VertexNode, to: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-comment">// from的尾和to的头相互连接,注意circle</span><br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">memo</span>: number[] = [];<br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span> &amp;&amp; !memo.<span class="hljs-title function_">includes</span>(cur.<span class="hljs-property">index</span>)) &#123;<br>    memo.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">index</span>);<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br><br>  graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<br>    to.<span class="hljs-property">index</span>,<br>    graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>或</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">or</span>(<span class="hljs-params">a: VertexNode, b: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, a.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(b.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, b.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeEnd, nodeEnd.<span class="hljs-property">index</span>);<br>  <span class="hljs-title function_">connect</span>(a, nodeEnd);<br>  <span class="hljs-title function_">connect</span>(b, nodeEnd);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">characters</span>(<span class="hljs-params">chars: string[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>, chars);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(nodeEnd.<span class="hljs-property">index</span>, chars);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br><br>  <span class="hljs-keyword">const</span> pre = nodeStart.<span class="hljs-property">firstEdge</span>;<br>  nodeStart.<span class="hljs-property">firstEdge</span> = nodeEnd;<br>  nodeEnd.<span class="hljs-property">next</span> = pre;<br><br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutipliy</span>(<span class="hljs-params">wrapped: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(wrapped.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = tmp;<br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(wrapped.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span>) &#123;<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br>  <span class="hljs-title function_">connect</span>(cur, nodeStart);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">base: VertexNode</span>) &#123;<br>  <span class="hljs-comment">// 基于old新建节点</span><br>  <span class="hljs-keyword">let</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, base.<span class="hljs-property">edgeVal</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">const</span> res = nodeStart;<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">let</span> cur = base?.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">const</span> vertexNode = graph.<span class="hljs-title function_">getVertex</span>(cur?.<span class="hljs-property">index</span>);<br>    <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(tmp.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart = tmp;<br>    tmp.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>    graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br>    cur = vertexNode.<span class="hljs-property">firstEdge</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mutipliy</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用邻接表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。</p><p>if对应的nfa: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104727865.png" class=""></p><p>[a-z][a-z0-9]* 的nfa为: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104740056.png" class=""></p><p>联合后就变成了一个大的nfa，并在终态节点上放置一些动作：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104921040.png" class=""></p><h3 id="构建邻接矩阵">构建邻接矩阵：</h3><p><code>lib =&gt; parser =&gt; nfa =&gt; build_edges函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;);<br>edges[起始点][终止点] = [边集合]，如果是epsilon，则是<span class="hljs-literal">null</span><br><span class="hljs-title function_">build_edges</span>() dfs + bfs + 集合去重<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   ======&gt; <span class="hljs-number">0</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">1</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, f, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">2</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">3</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">4</span><br>    [<br>       a,  b,  c, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>,<br>      <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>,<br>      <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>, <span class="hljs-number">113</span>, <span class="hljs-number">114</span>,<br>      <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z<br>    ],<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">5</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">6</span><br>    [<br>       a,  b,  c, d, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>,<br>      <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>,<br>      <span class="hljs-number">113</span>, <span class="hljs-number">114</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,<br>       <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span><br>    ],<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">7</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">8</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">9</span><br>]<br></code></pre></td></tr></table></figure><p>可以验证下就是如下节点边值对(行索引对应source节点，列索引对应target节点，矩阵值就是边集合)：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">2</span>: i<br><br><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">4</span>: null<br><br><span class="hljs-symbol">2 </span>=&gt; <span class="hljs-number">3</span>: f<br><br><span class="hljs-number">4</span>=&gt;<span class="hljs-number">5</span>: [a-z]<br><br><span class="hljs-number">5</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">6</span>=&gt;<span class="hljs-number">7</span>: [a-z] [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><br><span class="hljs-number">7</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">8</span>=&gt;<span class="hljs-number">6</span>: null<br></code></pre></td></tr></table></figure><h3 id="根据邻接矩阵构建dfa">根据邻接矩阵构建dfa</h3><p><span class="math display">\[Closure(S):S的可达闭包，表示从集合S出发，无需接受任何字符，即只通过epsilon边即可到达的状态组成的集合\\Closure(S) = S \cup(\bigcup_{m\in{S}}edge(m, \epsilon))，其中edge(m, \epsilon)\\表示从状态m出发沿着边c可到达的所有NFA状态的集合\]</span></p><p><span class="math display">\[假设状集合有如下几个状态：S=\{m, n, k\} \\从S的状态出发，沿着某条边c可到达的新的状态集合，表示为DFAedge(S, c) \\DFAedge(S, c) = Closure(\bigcup_{k\in{S}}edge(k, c))\]</span></p><p>有了Closure和DFAedge算法单元，这样从NFA的起点出发，不断的更新DFAedge(S,c)，每次新生成的DFAedge(S,c)，即得到DFA里的状态节点，据此得到dfa状态转移表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">states<span class="hljs-selector-attr">[0]</span> &lt;- <span class="hljs-selector-attr">[]</span> <br>states<span class="hljs-selector-attr">[1]</span> &lt;- <span class="hljs-built_in">Closure</span>(<span class="hljs-selector-attr">[S]</span>)<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-number">1</span>, j &lt;- <span class="hljs-number">0</span> <br>while j &lt;= <span class="hljs-selector-tag">p</span> <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> 字母集 <br>e &lt;- <span class="hljs-built_in">DFAedge</span>(states<span class="hljs-selector-attr">[j]</span>, c) <br><span class="hljs-keyword">if</span> e == states<span class="hljs-selector-attr">[i]</span> <span class="hljs-keyword">for</span> some <span class="hljs-selector-tag">i</span> &lt;= <span class="hljs-selector-tag">p</span> <br>then trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">i</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-number">1</span><br>states<span class="hljs-selector-attr">[p]</span> &lt;- e<br>trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">p</span><br>j &lt;- j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>构建完正则表达式之后就可以对我们的输入处理成token流了。(<code>lib =&gt; scan函数</code>)</p><h2 id="构建抽象语法树">构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,</p><p>理论上上下无关文法所代表的文法范围： LR(1) &gt; LSPR &gt; SLR &gt;LR(0) <strong>LR(0):</strong> 没有提前预测的符号，容易出现 shift-reduce冲突以及 reduce-reduce 冲突，所以需要设计适合的文法；<strong>SLR:</strong> 有简单的预测，可以用follow集解决部分shift-reduce冲突，但是在有些情况下还是 shift-reduce冲突 <strong>LR(1):</strong>可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突<strong>LSPR:</strong> 由于 LR(1)的表特别大，在此基础上做了优化</p><p>看如下文法的 LR(0)生成过程：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">E-&gt; Program $<br>P<span class="hljs-function"><span class="hljs-title">rogram</span> -&gt;</span> Assign == Assign<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Assign + Token<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Token<br>T<span class="hljs-function"><span class="hljs-title">oken</span> -&gt;</span> id<br></code></pre></td></tr></table></figure><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约。</p><p>slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><h2 id="五ast生成">五、AST生成</h2><p>生成好分析表之后，就可以根据分析表进行语法分析了，如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><p>下图简单模拟了<code>int ID (int ID)</code>的token流处理过程，<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/stack.gif" class="" title="这是一张图片">在没有规约动作的时候token一直push进栈，直到有对应的规约动作，这个时候按照指定的规约动作，生成非终结符，再把该非终结符放入栈内，重复进行，直到栈内为空或者遇到了$，当然，如果在这过程中遇到了不合法的字符，直接抛出异常</p><p>以及生成的简单ast如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Program</span>_Class &#123;<br>  <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>    <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>    <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Branch</span>_Class &#123;<br>      <span class="hljs-attr">ifCond</span>: <span class="hljs-title class_">Cond</span>_Class &#123;<br>        <span class="hljs-attr">lExpr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>        <span class="hljs-attr">rExpr</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;0&#x27;</span> &#125;,<br>        <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;==&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">statementTrue</span>: <span class="hljs-title class_">Return</span>_Class &#123; <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125; &#125;,<br>      <span class="hljs-attr">statementFalse</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;m&#x27;</span>,<br>        <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>          <span class="hljs-attr">params_list</span>: [ <span class="hljs-literal">undefined</span> ],<br>          <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>          <span class="hljs-attr">params</span>: <span class="hljs-title class_">Sub</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;<br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>        &#125;,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>          <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;m&#x27;</span> &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;,<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>      <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span> ],<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sum&#x27;</span>,<br>      <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>        <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>          <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>          <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;y&#x27;</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;y&#x27;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;<br>      &#125;,<br>      <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>        <span class="hljs-attr">formal_list</span>: [],<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br>        <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>,<br>          <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>          <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;10&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;10&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;print&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">formals</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：遍历ast自上向下进行利用堆栈机代码生成，由于本语言比较简单，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cgenForSub(e1, e2) &#123;<br>cgen(e1)<br>sw <span class="hljs-variable">$a0</span>, 0(<span class="hljs-variable">$29</span>)<br>addiu <span class="hljs-variable">$29</span>, <span class="hljs-variable">$29</span>, -4<br>cgen(e2)<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$a0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用域获取变量，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/%E9%A3%9E%E4%B9%A620230502-104729.jpg" class="" title="这是一张图片"></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h3 id="项目踩坑点">项目踩坑点</h3><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npm linktypescript，再运行即可</li></ol><h3 id="项目难点">项目难点</h3><p>其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li></ol><h3 id="参考文章">参考文章</h3><p><ahref="https://blog.csdn.net/qq_42977003/article/details/112341427">LL1文法、LR(0)文法、SLR文法、LR(1)文法、LALR文法_不积硅步的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/77663680">栈和栈帧 - 知乎(zhihu.com)</a></p><p><ahref="https://www.cnblogs.com/henuliulei/p/10872483.html">LL(1),LR(0),SLR(1),LALR(1),LR(1)对比与分析- 你的雷哥 - 博客园 (cnblogs.com)</a></p><p><ahref="https://wangwangok.github.io/2020/05/05/bottom2top_syntax_parser_lalr/#:~:text=“规范LR”">语法分析——自底向上语法分析中的规范LR和LALR· 凌云壮志幾多愁 (wangwangok.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础, node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git多账号管理</title>
    <link href="/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <url>/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>为什么提交了代码并推送到github，但是github上的contributions并没有增加呢？</p><p>其中Github官方给出了一个官方文件，告诉我们什么样的Commit可以被记入Contribution，请点击此处查看。</p><p>在官方的帮助文档中，有一条是Commit被记入Contribution中必须满足用于Commit的邮件地址必须与Github账户相关联。其实，这也是为什么我的Commit没有被记入Contribution和不显示头像的原因，也是大多数人也是这个原因</p><p>https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/why-are-my-contributions-not-showing-up-on-my-profile</p><p>我遇到的问题的解决方案是：该仓库的本地的邮箱和github账户的邮箱不是同一个配置：可以修改本地仓库的邮箱和github上一致：git config --local user.name 张三 git config --local user.emailzhansan@996icu.com</p><p>如果拿到一台公司电脑, 那么就请按照下面的最佳实践配置下git的多环境:请先执行命令打开配置文件 vi ~/.ssh/config</p><p>然后输入以下内容： # gitlab Host gitlab User git HostNamegitlab.company.com PreferredAuthentications publickey IdentityFile~/.ssh/gitlab_rsa ServerAliveInterval 300 ServerAliveCountMax 10 #github Host github User git HostName github.com PreferredAuthenticationspublickey IdentityFile ~/.ssh/github_rsa ServerAliveInterval 300ServerAliveCountMax 10</p><p>这里唯一需要替换的gitlab里的HostName部分, 改成你们公司的git地址.</p><p>遇到GitHub报permission denied错就执行：ssh-add -k ~/.ssh/github_rsa遇到gitlab报permission denied错就执行：ssh-add -k ~/.ssh/gitlab_rsa</p><p>推荐阅读：https://zhuanlan.zhihu.com/p/62071906</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/05/05/minic/"/>
    <url>/emocoder/2023/05/05/minic/</url>
    
    <content type="html"><![CDATA[<h1 id="node-手写编译器-minicompiler">node 手写编译器-minicompiler</h1><p>使用语言：node, C++本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><h2 id="一minic-语法">一、minic 语法：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我会从以下四个方面依次入手：</p><ol><li>parser</li><pre><code class="hljs">&lt;ul&gt;&lt;li&gt;正则&lt;/li&gt;&lt;li&gt;todo&lt;/li&gt;&lt;/ul&gt;</code></pre><li>sematic</li><ul><li>slr</li><li>语义分析</li><li>todo</li></ul><li>代码生成</li><li>可视化</li><h2 id="二parser">二、parser</h2><p>在词法分析阶段，输入是字符串，输出是 token 流，这里 token流有一个坑，一开始我的输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学过编译原理都知道，需要有自动机把输入流，转成一个个token，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级</p><p>那么如何构建自动机？ 首先我们的目标是对每种特定的 token设置对应的正则表达式，并生成对应的 dfa，用过 flex的同学应该都知道，比如：</p><p>然后我们把这些 dfa 构建为一个大的 nfa，再把 nfa 转为 dfa</p><p>我们的词法分析器支持以下几个单元： +: a+, ?: a?, <em>: a</em>, 连接:ab， 逻辑或: a|b， 字符集: [a-z] 支持少部分字符转义：, t, </p><p>如何把正则表达式构建为dfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个单元+一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack 进行存储，一般的，形式化如下：对于正则表达式 xxxxx 其中 X为可能的任意字符，<code>stack = []</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">0</span><br>pattern = <span class="hljs-string">&#x27;XXXX&#x27;</span><br><span class="hljs-keyword">while</span> (i &lt; len(pattern)) &#123;<br>  <span class="hljs-keyword">auto</span> node = getNode(pattern[i]);<br>  <span class="hljs-built_in">stack</span>.push(node);<br>&#125;<br><br>node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;]&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;+&#x27;</span>)<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getNode函数做的事请就是识别特定的符号，然后用对应的正则表达式函数生成即可，比如对于特殊的符号:[],需要收集其包含的字符集，然后构建一个如图的基本正则单元；再比如a+，我们需要从 stack 内 pop 出一个元素，生成对应的基本正则单元。</p><p>最后，所有的特殊符号处理完成，也就意味着栈内只有正则表达式单元这种数据结构，这些节点之间没有任何修饰符(因为修饰符之前都被处理完了，除了连接运算)，然后我们依次连接这些节点即可，另外对于每个正则的叶子节点确定，即当前栈顶元素的最后一个节点(因为栈顶元素对应正则的末尾)。</p><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs node">export function connect(from: VertexNode, to: VertexNode): VertexNode &#123;<br>  // from的尾和to的头相互连接,注意circle<br>  let cur = graph.getVertex(from.index); // 获取邻接表<br>  const memo: number[] = [];<br>  while (cur.firstEdge &amp;&amp; !memo.includes(cur.index)) &#123;<br>    memo.push(cur.index);<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br><br>  graph.getVertex(cur.index).firstEdge = new Node(<br>    to.index,<br>    graph.getVertex(cur.index).firstEdge<br>  );<br>  return from;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>逻辑或</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node">export function or(a: VertexNode, b: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  nodeStart.firstEdge = new Node(a.index, null, a.edgeVal || null);<br>  nodeStart.firstEdge.next = new Node(b.index, null, b.edgeVal || null);<br>  const nodeEnd = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeEnd, nodeEnd.index);<br>  connect(a, nodeEnd);<br>  connect(b, nodeEnd);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node">export function characters(chars: string[]) &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const nodeEnd = new Node(Graph.node_id, null, chars);<br>  const tmp = new VertexNode(nodeEnd.index, chars);<br>  graph.addVertexNode(tmp, tmp.index);<br><br>  const pre = nodeStart.firstEdge;<br>  nodeStart.firstEdge = nodeEnd;<br>  nodeEnd.next = pre;<br><br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node">export function mutipliy(wrapped: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const tmp = new Node(wrapped.index, null, null);<br>  nodeStart.firstEdge = tmp;<br>  let cur = graph.getVertex(wrapped.index); // 获取邻接表<br>  while (cur.firstEdge) &#123;<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br>  connect(cur, nodeStart);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs node">export function plus(base: VertexNode) &#123;<br>  // 基于old新建节点<br>  let nodeStart = new VertexNode(Graph.node_id, base.edgeVal);<br>  nodeStart.firstEdge = base.firstEdge;<br>  const res = nodeStart;<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  let cur = base?.firstEdge;<br>  while (cur) &#123;<br>    const vertexNode = graph.getVertex(cur?.index);<br>    const tmp = new VertexNode(Graph.node_id, vertexNode.edgeVal);<br>    nodeStart.firstEdge = new Node(tmp.index, null, vertexNode.edgeVal);<br>    nodeStart = tmp;<br>    tmp.firstEdge = base.firstEdge;<br>    graph.addVertexNode(tmp, tmp.index);<br>    cur = vertexNode.firstEdge;<br>  &#125;<br>  return mutipliy(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用linjie表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。 通过以上流程，我们得到了一个 nfa，由该 nfa可以得到各个节点的边，以及叶子节点(并且叶子节点上放置了相应的动作)</p><p>nfa =&gt; dfa:这一步使用的是虎书上的算法，这里不过多描述，简单来说就是把很多个大的 nfa联合构建成一个 dfa 从而得到一张状态转移表</p><h2 id="三构建抽象语法树">三、构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,理论上上下无关文法LR(1) &gt; LSPR &gt; SLR &gt; LR(0) LR(0): 没有提前预测的符号，容易出现shift-reduce 冲突以及 reduce-reduce 冲突，所以需要设计适合的文法； SLR:有简单的预测，可以解决 shift-reduce 冲突，但是无法解决 reduce-reduce冲突 LR(1): 可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突 LSPR:由于 LR(1)的表特别大，在此基础上做了优化</p><p>根据相应文法生成 ast，本质上是利用栈和 nfa，看如下文法的LR(0)生成过程： E-&gt; Program $ Program -&gt; Assign == Assign Assign-&gt; Assign + Token Assign -&gt; Token Token -&gt; id</p><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约，slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><p>有了这张表就可以基于输入(一般是 token流)去做语法分析了，刷过算法题的都应该猜到了会用栈来作为数据结果，是的，每一次自底向上规约都可以看作是栈的pop动作，并且在这次动作中可以做很多事情，比如生成我们想要的树节点，如：</p><p>在设计 AST 结构的同时需要同时兼顾到 AST的结构方便语义分析和代码生成，该语言的 ast 结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs node">Program_Class &#123;<br>  expr: Function_Class &#123;<br>    formal_list: [ &#x27;x&#x27; ],<br>    name: &#x27;total&#x27;,<br>    expressions: Branch_Class &#123;<br>      ifCond: Cond_Class &#123;<br>        lExpr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>        rExpr: Int_Contant_Class &#123; token: &#x27;0&#x27; &#125;,<br>        op: &#x27;==&#x27;<br>      &#125;,<br>      statementTrue: Return_Class &#123; expr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125; &#125;,<br>      statementFalse: Assign_Class &#123;<br>        name: &#x27;m&#x27;,<br>        ltype: &#x27;int&#x27;,<br>        r: Caller_Class &#123;<br>          params_list: [ undefined ],<br>          id: &#x27;total&#x27;,<br>          params: Sub_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Int_Contant_Class &#123; token: &#x27;1&#x27; &#125;<br>          &#125;,<br>          next: undefined<br>        &#125;,<br>        next: Return_Class &#123;<br>          expr: Add_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Indentifier_Class &#123; token: &#x27;m&#x27; &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    formals: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;,<br>    next: Function_Class &#123;<br>      formal_list: [ &#x27;x&#x27;, &#x27;y&#x27; ],<br>      name: &#x27;sum&#x27;,<br>      expressions: Return_Class &#123;<br>        expr: Add_Class &#123;<br>          lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>          rvalue: Indentifier_Class &#123; token: &#x27;y&#x27; &#125;<br>        &#125;<br>      &#125;,<br>      formals: Formal_Class &#123;<br>        name: &#x27;y&#x27;,<br>        type: &#x27;int&#x27;,<br>        next: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;<br>      &#125;,<br>      next: Function_Class &#123;<br>        formal_list: [],<br>        name: &#x27;main&#x27;,<br>        expressions: Assign_Class &#123;<br>          name: &#x27;x&#x27;,<br>          ltype: &#x27;int&#x27;,<br>          r: Caller_Class &#123;<br>            params_list: [ &#x27;10&#x27; ],<br>            id: &#x27;total&#x27;,<br>            params: Int_Contant_Class &#123; token: &#x27;10&#x27; &#125;,<br>            next: undefined<br>          &#125;,<br>          next: Caller_Class &#123;<br>            params_list: [ &#x27;x&#x27; ],<br>            id: &#x27;print&#x27;,<br>            params: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            next: undefined<br>          &#125;<br>        &#125;,<br>        formals: undefined,<br>        next: undefined,<br>        return_type: &#x27;int&#x27;<br>      &#125;,<br>      return_type: &#x27;int&#x27;<br>    &#125;,<br>    return_type: &#x27;int&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其树节点是各种表达式类，源码在 tree.ts 文件里，</p><p>follow集和first集生成： follow集： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs node">_processFollow(_nts: string) &#123;<br>  // 3 若存在一个表达式 X -&gt; ABCD 则 Follow(A) 需要加上 First(B) - ε，若First(B) 包含 ε，则Follow(A) 需要加上 First(C) - ε，向右迭代... 迭代至表达式结束。<br>  for (const nts of this.nonTerminalSymbol) &#123;<br>    for (let grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    <br>      const len = grammarArr.value.length;<br>      let index = -1;<br>      // 找到 B<br>      for (let i = 0; i &lt; len; i += 1) &#123;<br>        const ch = grammarArr.value[i];<br>        if (ch === _nts) &#123;<br>          index = i;<br>          break;<br>        &#125;<br>      &#125;<br>      if (index === -1) continue;<br>      while (index + 1 &lt; len) &#123;<br>        const ch = grammarArr.value[index + 1];<br>        if (this.terminalSymbol.has(ch)) &#123;<br>          // 终结符直接加入<br>          this._followSet[_nts].add(ch);<br>          break;<br>        &#125; else &#123;<br>          const set = this._firstSet[ch];<br>          for (const v of Array.from(set || []))<br>            if (v !== EMPTY) this._followSet[_nts].add(v);<br>          if (!set?.has(EMPTY)) break;<br>          index += 1;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>startBuildFollowSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    this._followSet[nts] = new Set();<br>  &#125;<br>  this._followSet[START].add(END);<br>  while (true) &#123;<br>    let flag = false;<br>    for (let nts of this.nonTerminalSymbol) &#123;<br>      this._processFollow(nts);<br>      if (isEqual(prevFollowSet, this._followSet)) flag = true;<br>      else flag = false;<br>      prevFollowSet = cloneDeep(this._followSet);<br>    &#125;<br>    if (flag) break;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs node">// 求firset集这里做了点改动，一般需要手动消除左递归文法，这里在代码里如果遇到了左递归直接结束<br>_processFirst(nts: string, memo: Set&lt;string&gt;) &#123;<br>  memo.add(nts);<br>  for (const grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    const len = grammarArr.value.length;<br>    for (let i = 0; i &lt; len; i += 1) &#123;<br>      const ch = grammarArr.value[i];<br>      if (this.terminalSymbol.has(ch)) &#123;<br>        this._firstSet[nts].add(ch);<br>        break;<br>      &#125; else &#123;<br>        if (i === 0 &amp;&amp; ch === nts) &#123;<br>          // 避免左递归<br>          break;<br>        &#125;<br>        if (memo.has(ch)) &#123;<br>          // 避免循环递归<br>          break;<br>        &#125;<br>        <br>        this._processFirst(ch, memo);<br>        for (const v of this._firstSet[ch]) this._firstSet[nts].add(v);<br>        if (!this._firstSet[ch].has(EMPTY)) break;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>startuildFirstSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) this._firstSet[nts] = new Set();<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    const memo = new Set([]);<br>    this._processFirst(nts, memo);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五ast生成">五、AST生成</h2><p>如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：自上向下进行利用堆栈机代码生成，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；总结了下，最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用取，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="../飞书20230502-104729.jpg" /></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><p>以下是具体的几个单元表达式生成的例子：</p><p>a + b lw $a0 局部 or 参数 / li $a0, imm sw $a0, 0($29) addiu $29,$29, -4 lw $a0 局部 or 参数 / li $a0, imm add $a0, $t0, $a0</p><p>对于int x = 2，直接用li命令存储，并在函数的局部变量处向函数栈内放置元素; 对于int x = a + b,先利用a+b元表达式生成对应的代码，再用lw指令存储单元表达式的值，</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h2 id="九前端可视化">九、前端可视化</h2><p>canvas</p><p>项目踩坑点：</p><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npmlink typescript，再运行即可</li></ol><p>项目难点：其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li><li><p>前端部分：用的是原生 canvas，主要是平时工作很少用canvas，之前学过，不用就忘，顺便学习下，主要是整个 canvas类的设计吧。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/emocoder/2023/02/27/hello-world/"/>
    <url>/emocoder/2023/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/emocoder/2023/02/27/My-New-Post/"/>
    <url>/emocoder/2023/02/27/My-New-Post/</url>
    
    <content type="html"><![CDATA[<p>你好</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
