<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Network-CS144 の 3 Packet Switching</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="分组交换">分组交换</h2><p>特点：</p><ul><li>Packets被独立地路由，通过查找当前路由的局部路由表</li><li>所有的Packets共享一个完整的Link</li><li>路由不需要维护通信状态</li><li>路由是有缓存的<ul><li>缓存在以下情况下会存在Packets：<ul><li>When two or more packets arrive at the same time</li><li>During periods of congestion</li></ul></li></ul></li></ul><h2 id="curcuit-switching">Curcuit switching</h2><p>建议了解下通信历史</p><p>建议了解下网络历史</p><p>特点：</p><ul><li>Each call has its own private, guaranteed, isolated data rate fromend-to-end</li><li>A call has three phases:<ul><li>Establish circuit form end-to-end</li><li>Communicate</li><li>Close circuit</li></ul></li><li>Originally, a circuit was end-to0end physical wire</li><li>Nowdays, a circuit is like a virtual private wire</li></ul><p>能否在计算机通信使用Curcuit switching</p><ul><li>Inefficient:计算机通信是爆炸式的，通信需要比较高的速度，不然影响体验</li><li>Diverse Rates: 计算机通信在不同情况下速度是不同的，比如 a web serverstreaming video at 6Mb/s, typing at a. Character per second. A fixedrate circuit will not be much use.</li><li>State management. Curcuit switch maintain per-communication state,which must be managed.</li></ul><blockquote><p>Efficient use of expensive links</p><ul><li>Links were assumed to be expensive and scarce</li><li>Packet switching allows many, bursty flows to shae the same linkefficiently</li><li>Circuit switching is rarely used for data networks, ... because ofvery inefficient use of the links</li></ul><p>(PS:其实就是说分组交换允许共享链接，而电报交换每次链接都是一个新的链路，重新构建一个Link代价是比较大的)</p><p>Resilience to failure of links &amp; routerss</p><ul><li>For high reliability, [the internet] was to be a datagram subnet, soif some lines and [routers] were destroyed, messages could be ...rerouted</li></ul><p>(PS: 分组交换即使中间路由损坏了，也可以通过其他路由重新路由)</p></blockquote><p>排队机制是ATM交换中一个极为重要的内容，队列的溢出会引起信元丢失，信元排队是交换时延和时延抖动的主要原因，因此排队机制对ATM交换机性能有着决定性的影响。基本排队机制有三种：输入排队、输出排队和中央排队。这三种方式各有缺点，如输入排队有信头阻塞，交换机的负荷达不到60%；输出排队存储器利用率低，平均队长要求长，而中央排队存储器速率要求高、存储器管理复杂。同时，三种方式有各有优点，输入队列对存储器速率要求低，中央排队效率高，输出队列则处于两者之间，所以在实际应用中并没有直接利用这三种方式，而是加以综合，采取了一些改进的措施。</p><h2 id="分包交换">分包交换</h2><h3 id="what-does-a-packet-switch-look-like">what does a packet switchlook like ?</h3><h3 id="what-does-a-packet-switch-do">what does a packet switch do?</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><h3 id="how-address-lookup-works">How address lookup works</h3><ul><li>以太网交换机(Ethernet switch)</li><li>因特网路由器(Internet router)</li></ul><p>以太网交换机：</p><figure><img src="https://img1.sdnlab.com/%20/wp-content/uploads/2020/11111.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617171950912.png"alt="image-20230617171950912" /><figcaption aria-hidden="true">image-20230617171950912</figcaption></figure><p><strong>Ethernet switch</strong></p><ul><li>Examine the header of each arrving frame</li><li>If the Ethernet DA(Destniation addrdress) is in the forwardingtable, forward the frame to correct output port(s)</li><li>If the Ethernet DA is not in the table, boradcast the frame to allposts</li><li>Entries in the table are learned by examining the Ethernet ofarriving packets.</li></ul><p>Internet Router</p><ul><li><p>If the Ethernet DA of the arriving frame belongs to the router,accept the frame. Else drop it</p></li><li><p>Examine the IP version number and length of the datagram</p></li><li><p>Decrement the TTL, update the IP header checksum.</p></li><li><p>Check to see if TTL == 0</p></li><li><p>if the IP DA is in the forwarding table, forward to the correctegress port(s) for the next hop</p></li><li><p>Find the Ethernet DA for the next hop router</p></li><li><p>Create a new Ethernet frame an d send it</p></li><li><p>Lookup address: How is the address looked up into forwardingtable ?</p></li><li><p>Switching: How is the packet sent to the correct output port?</p></li></ul><p>Lookup address: Ethernet</p><ul><li><p>Methods:</p><ul><li>Store address in hash table (maybe 2-way hash)</li><li>Look for exact match in hash table</li></ul></li></ul><p>Lookup address: IP</p><p>Lookup is a longest prefix match, not an exact match</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172810926.png"alt="image-20230617172810926" /><figcaption aria-hidden="true">image-20230617172810926</figcaption></figure><p>Method 1:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172841236.png"alt="image-20230617172841236" /><figcaption aria-hidden="true">image-20230617172841236</figcaption></figure><p>Method 2:</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172919259.png"alt="image-20230617172919259" /><figcaption aria-hidden="true">image-20230617172919259</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617172935778.png"alt="image-20230617172935778" /><figcaption aria-hidden="true">image-20230617172935778</figcaption></figure><p>switching packetd to the egress port:</p><ul><li>Output queuing and shared memory</li><li>Inout queuing and head-of-line blocking</li><li>Virtual output queues</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175054605.png"alt="image-20230617175054605" /><figcaption aria-hidden="true">image-20230617175054605</figcaption></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175119541.png"alt="image-20230617175119541" /><figcaption aria-hidden="true">image-20230617175119541</figcaption></figure><p>但是存在线头阻塞（Head of lineblocking），由于其影响，速率下降了，因为同一时刻，inputqueue内最前面的挡住了后面排队的：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175353059.png"alt="image-20230617175353059" /><figcaption aria-hidden="true">image-20230617175353059</figcaption></figure><p>解决方法：Virtual Output Queue</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617175420698.png"alt="image-20230617175420698" /><figcaption aria-hidden="true">image-20230617175420698</figcaption></figure><p>The simplest and slowesr switches uses output queuing, whichminimizes packet delay.</p><p>High performance switches often use iput queuing, with virtual outputqueues to maximize throughput.</p><p>lab 0:</p><p>使用操作系统的TCP和流式socket抽象，基于Internet写一个fetch webpage的程序：</p><ul><li>使用IDE打开../apps/webget.cc</li><li>在ge tURl函数里实现你的代码</li><li>就像该文件里描述的那样，实现一个简单的web客户端（使用http协议）（注：使用<code>TCPSocket</code>and <code>address</code> 这两个类）</li></ul><p>提示：</p><ul><li>Please note that in HTTP, each line must be ended with “” (it’s notsufficient to use just “” or endl).</li><li>Don’t forget to include the “Connection: close” line in yourclient’s request. This tells the server that it shouldn’t wait aroundfor your client to send any more requests after this one. Instead, theserver will send one reply and then will immediately end its outgoingbytestream (the one from the server’s socket to your socket). You’lldiscover that your incoming byte stream has ended because your socketwill reach “EOF” (end of file) when you have read the entire byte streamcoming from the server. That’s how your client will know that the serverhas finished its reply.</li><li>Make sure to read and print all the output from the server until thesocket reaches “EOF” (end of file)—<strong>a single call to read is notenough.</strong>确保读取和打印所有来自服务器的输出，知道socket达到了EOF（文件末尾）</li><li>希望你只用9行代码</li></ul><p>正如上面的<code>TCPSocket</code>类在网络通信中是非常重要的，eventhough the Internet itself only provides the service of “best-effort”(unreliable) datagrams.</p><p>下面将实现一个字节流，已经提供了相关的抽象。</p><p>字节s从input侧写入，并以相同顺序从output侧读取，字节流是有限的writer可以endthe input, 表示没有更多字节写入了。reader一直读，直到遇到了EOF。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 2 TCP Model</title>
    <link href="/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/emocoder/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp模型">TCP模型</h2><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>字节流</td><td>可靠的字节传输服务</td></tr><tr class="even"><td>可靠传输</td><td>确认机制保证了正确有序的传输；checksum检测错误数据，序列号检测丢失数据，滑动窗口式流量控制让值接收方过载；超时和重传机制</td></tr><tr class="odd"><td>有序</td><td>有序同步传输（序列号和确认号机制）</td></tr><tr class="even"><td>用塞控制</td><td></td></tr></tbody></table><p>TCP连接的唯一ID</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[TCP Data src<span class="hljs-built_in"> port </span>, dest port][Ipv4 header,<span class="hljs-built_in"> IP </span>src addr,<span class="hljs-built_in"> IP </span>dest addr, protocol ID = <span class="hljs-string">&#x27;TCP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>一般由src port , dest port][Ipv4 header, IP src addr, IP dest addr,protocol ID = 'TCP'组成唯一ID</p><p>Host A increments src port for every new connection</p><p>TCP picks ISN(initial seq number) to avoid overlap with previousconnections with same ID(防止和上一个TCP连接的数据混淆)</p><h2 id="section"></h2><p>TCP如何可靠？</p><p>停止与等待/滑动窗口</p><h2 id="端到端原则">端到端原则</h2><p>为什么Network不做更多的事情：</p><ul><li>压缩数据</li><li>reformat/imporove requests</li><li>Serve cached data</li><li>add security</li><li>Migrate connections across the network</li><li>or one of any of a huge number of other things</li></ul><p>Network仅仅负责传输的事情，不负责其他的，如存储，如果像上面所说，把很多东西都交给了network来做，实际上很多做不到，或者说有缺陷，所以实际实现中，网络的设计应该满足端到端原则，只负责两边的传输相关功能</p><h2 id="finite-state-machine">Finite State Machine</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">state1 =&gt;([event causing <span class="hljs-keyword">state</span> transition | actions taken <span class="hljs-keyword">on</span> <span class="hljs-keyword">state</span> transition]) state2<br><br>state1 =&gt;[event | action] state3<br></code></pre></td></tr></table></figure><h2 id="flow-control">flow control</h2><p>flow control 1：要解决的问题是发送方和接收方速度差异不一致问题</p><ul><li>Stop and wait</li></ul><p>sender: 500, 000 packets/second</p><p>receiver: 200, 000</p><p>如果全速发送，将会丢包40%</p><p>流量控制：不要发送超过接收方可以处理的数据包</p><p>idea：接收方可以发送反馈，这里有两种方式</p><ul><li>停止等待 (其实是window size = 1的滑动窗口)</li><li>滑动窗口</li></ul><p>停止等待：</p><ul><li>任意时间链路中最多仅有一个packet</li><li>发送者每次发送一个</li><li>接收方收到后返回响应</li><li>当接收方收到响应，再次发送新的packet</li><li>一旦超时，重新发送当前数据</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121206723.png"alt="image-20230611121206723" /><figcaption aria-hidden="true">image-20230611121206723</figcaption></figure><p>简单停止等待的🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121246484.png"alt="image-20230611121246484" /><figcaption aria-hidden="true">image-20230611121246484</figcaption></figure><p>case 1: 没有信息丢失</p><p>case 2: req 丢失，timeout 重新发送</p><p>case 3: response 丢失， timeout 重新发送</p><p>case 4: 前面一个丢失的数据报仅仅是delay了，这样就会有重复</p><p><strong>solution:</strong> Use 1-bit counter in data andacknowledgements</p><p>​ Receiver can tell if new data or duplicated</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230611121527344.png"alt="image-20230611121527344" /><figcaption aria-hidden="true">image-20230611121527344</figcaption></figure><p>这样间隔的数据报counter位是不一样的</p><p>1bit基于两个假设：</p><ul><li>延迟不会超过多个timeout，这样间隔的数据counter位是一样的</li><li>网络本身并复制packet，因为如果发送重复packet，那么前后两个packet本身是一致的，但是由于计数却是不一致的，这样两个packet就会同时存在</li></ul><h2 id="滑动窗口">滑动窗口</h2><p>考虑一个发送数据包的🌰：</p><p>上海 =&gt; 北京</p><p>网络性能上限是 10Mb/s</p><p>RTT = 50ms</p><p>Ethnet的传输速度是12kb/s</p><p>这样1s可以发送20次，总共可以发20 * 12 = 240kb/s</p><p>240kb/s/10Mb/s = 240/10, 000 = 2.4%</p><p>假如使用滑动窗口（这里考虑发送方和接收方窗口大小一致）：我们可以使用一个可以达到新能瓶颈的windowsize</p><p>240 * 42 = 1080，大约48个window size即可充分使用整个网络带宽</p><p>滑动窗口：</p><ul><li>Gerneration of stop-and-wait: allow multiple un-packed segments</li><li>Bound on number of un-packed segments, called window</li><li>Can keep pipe full (充分使用整个网络带宽)</li></ul><p>Sliding window Sender</p><ul><li>窗口内的每个segment都有一个序列号</li><li>发送方维护三个变量<ul><li>send window size(sws)</li><li>Last acknowledgment received (LAR)</li><li>Last segment sent(LSS)</li></ul></li><li>Maintain invariant: (LSS - LAR) &lt;= SWS</li><li>缓存窗口内的segments</li><li>当有新的确认到来，扩张窗口</li></ul><p>Sliding window Receiver</p><ul><li>维护三个变量<ul><li>Receive window size(sws)</li><li>Last acceptable segment (LAS)</li><li>Last segment received(LSR)</li></ul></li><li>Maintain invariant: (LAS - LSR) &lt;= RWS</li><li>如果接受的Packet小于LAS，回复确认</li><li>累计确认：如果收到了1,2,3,5，则回复ack = 3</li></ul><p>比如：RWS=5, LSR = 3, 那么本次将会接收4 ,5 ,6, 7, 8,如果有10，是不会接收的</p><p>RWS, SWS and Seq Space</p><ul><li>RWS &gt;= 1, SWS &gt;= 1, RWS &lt;= SWS</li><li>if RWS = 1, go back N protocol, need SWS + 1 seq numbers</li><li>if RWS = SWS, need 2SWS seq numbers</li><li>Generally need RWS + SWS seq numbers</li></ul><p>TCP流量控制：</p><ul><li>接收方 advertises RWS using window field</li><li>Sender can only send data up to LAR + window</li></ul><p>累计确认：累积确认这个概念应该不只适用于TCP协议，也适用其他层，比如链路层。</p><p>一般地讲，如果发送方发了包1，包2，包3，包4；接受方成功收到包1，包2，包3。那么接受方可以发回一个确认包，序号为4(4表示期望下一个收到的包的序号；当然你约定好用3表示也可以)，那么发送方就知道包1到包3都发送接收成功，必要时重发包4。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。</p><p>具体到TCP，它对字节编号。比如发送方发了包1，包2，包3；包1含字节0到10，包2含字节11到20，包3含字节21到30。接受方成功收到包1，包2。那么接受方发回一个包含确认序号21的包，发送方就知道字节0到20(包1，包2)都成功收到，必要时要重发的只需从字节21开始。</p><h2 id="重传策略">重传策略</h2><p>现在已经有了window size的概念，累计确认的概念，每个Packet都有自己的定时器</p><p>如果定时器超时怎么办？</p><ul><li>Go-back-N:一旦一个包丢失了将会重发整个窗口数据，本质上是因为接收方的窗口大小仅仅为1</li><li>选择重传：一旦一个包丢失了只会重发整个窗口数据丢失的那个包</li></ul><p>https://blog.csdn.net/qq_44807642/article/details/103054914https://zhuanlan.zhihu.com/p/589068775https://blog.csdn.net/u011617742/article/details/50387670#:~:text=%E5%9C%A8%E8%BF%94%E5%9B%9EN%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%BF%85%E9%A1%BB%3C%3D2m-1%2C%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%A7%8B%E7%BB%88%E4%B8%BA1%E3%80%82,%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%B8%8D%E8%83%BD%20%E8%B6%85%E8%BF%87%E5%BA%8F%E5%8F%B7%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E6%98%AF3%EF%BC%8C%E7%AA%97%E5%8F%A3%E6%98%AF6%E7%AA%97%E5%8F%A3%E6%AF%94%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%8F%B7%E5%A4%A7%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B00%EF%BC%8C1%EF%BC%8C2%2C3%2C0%2C1%E8%BF%99%E6%A0%B7%E7%9A%84%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BD%A0%E6%97%A0%E6%B3%95%E5%88%A4%E6%96%AD%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84ACK0%E6%98%AF%E4%BB%A3%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA0%E6%94%B6%E5%88%B0%E8%BF%98%E6%98%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA0%E6%94%B6%E5%88%B0%E3%80%82</p><h2 id="tcp-header">TCP header</h2><h2 id="tcp的setup-teardown">TCP的Setup &amp; Teardown</h2><p>可靠的通信依赖于通信双方的状态</p><p>问题是链接建立的时候如何维护这个状态？</p><p>当断连的时候如何清理这些状态？</p><p>Cleaning Up Safely</p><ul><li>Problems with closed socket<ul><li>What if final ack is lost in the network</li><li>What if the same port pair is immediately resued for a newconnection ?</li></ul></li><li>Solution: 'active' closer goes into TIME WAIT<ul><li>Active close is sendingFIN before receving one</li><li>Keep socket around for 2 MSL (twice the 'maximum segmentlifetime')</li></ul></li><li>Can pose problems with servers<ul><li>OS has too many socketd in TIME WAIT, slows things down</li><li>Hack: Can send RST and delete socket, so SO_LINGER socket option totime 0</li><li>OS won't let you re-start server because port still in use(SO_REUSEADDR) option lets you re-bind used port number.</li></ul></li></ul><p><strong>TCP🌰：</strong></p><p>不管是发送方还是接收方都会维护一个序列号（用于同步自己发送的数据）和确认号（用于同步对方的序列号），即使是像建立连接的时候数据段长度为0，但是对应的序列号和确认号也要消耗掉一个序号（即自增）</p><figure><imgsrc="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a437fcc7a69a4ef9b57b34d38a02c2bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>来看一个🌰：以下都是相对序列号</p><figure><imgsrc="https://img-blog.csdn.net/20160818012008762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>客户端 =&gt; 服务端: [SYN], seq = 0, len = 0, syn = 1, len = 0(客户端传递seq希望和服务端同步自己的数据,同时消耗掉客户端一个序列号，下一次客户端序列号就是从1开始)</p><p>客户端 &lt;= 服务端: [SYN, ACK] , seq = 0, ack = 1, syn = 1, len = 0(服务端回应同步，传递seq希望和客户端同步自己的数据,同时消耗掉服务端一个序列号, 下一次服务端序列号就是从1开始)</p><p>客户端 =&gt; 服务端: [ACK], ack = 1, seq = 1, len =0(客户端回应同步)</p><p>开始发送数据</p><p>客户端 =&gt; 服务端：[ACK], seq = 1, len = 474, ack =1(ack用于同步对方的消息)</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475(ack用于同步对方的消息,表示我已经收到你的前474个数据包)，服务端无响应数据，仅仅是ack数据包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1, ack = 475, len = 1448, next seq= 1449, 是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 1449, ack = 475, len = 1448, nextseq = 2897, 依旧是对上一次的客户端请求的一次tcp响应包</p><p>客户端 &lt;= 服务端：[ACK], seq = 2897, ack = 475, len = 1334, nextseq = 2897 + 1334, 还是对上一次的客户端请求的一次tcp响应包</p><p>上面的序列号是相对的，所以看起来都是从0开始，但是实际上起始序列号是随机的，为什么要初始化起始序列号？</p><ul><li>避免偶然性，防止意外乱入</li><li>安全性，防止恶意插入，因为如果起始序列号是固定的活着容易猜到的，在网络代理中，抓到tcp包，即可插入自己的数据，但是实际上几乎所有代理工具都无法解析道tcp的起始序列号。</li></ul><p>https://www.cnblogs.com/163yun/p/9552368.html</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>WIP</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 2 Lexical Analysis</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>WIP</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 3 Parsing Analysis 1 (Introduction &amp; LL Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Regular languages</p><ul><li>The weakest formal languages widely used</li><li>Many applications</li></ul><p>正则表达式的缺陷：</p><ul><li></li></ul><p>Parser：</p><ul><li>Input: sequence of tokens from lexer</li><li>Output: parse tree pf the program</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">Cool:<br><span class="hljs-keyword">if</span> x = y then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> fi<br>Parser <span class="hljs-keyword">input</span>:<br><span class="hljs-keyword">IF</span> ID = ID THEN <span class="hljs-keyword">INT</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">INT</span> FI<br>Parser output:<br> <span class="hljs-keyword">IF</span>-THEN-<span class="hljs-keyword">ELSE</span><br>=      <span class="hljs-keyword">INT</span>      <span class="hljs-keyword">INT</span><br>ID ID    <br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>Phase</th><th>Intput</th><th>Output</th></tr></thead><tbody><tr class="odd"><td>Lexer</td><td>String of characters</td><td>String of tokens</td></tr><tr class="even"><td>Parser</td><td>String of tokens</td><td>Parse tree</td></tr></tbody></table><blockquote><p>上面两步有的编译器是分开做的，有的编译器是放在一起做的</p></blockquote><h2 id="上下无关文法">上下无关文法</h2><p>由词法分析器得到的tokens并不全是有用的，比如标点符号，所以编译器必须识别哪些是有效token，哪些是无效的，我们需要一种描述规则来描述何为有效token，以及一种识别有效token的方法</p><p>程序语言都是有着nested(递归)的结构，如：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">EXPR = <span class="hljs-keyword">if</span> <span class="hljs-keyword">EXPR</span> then <span class="hljs-keyword">EXPR</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">EXPR</span> fi<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">EXPR</span> loop <span class="hljs-keyword">EXPR</span> pool<br></code></pre></td></tr></table></figure><p><strong>上下无关文法据说一种描述这种递归结构的naturalnotation</strong></p><p>CFG 由下面几部分构成：</p><ul><li>a set of terminals: <span class="math inline">\(T\)</span></li><li>a set of nn-terminals: <span class="math inline">\(N\)</span></li><li>a start symbol: <span class="math inline">\(S (S \inN)\)</span></li><li>a set of productions:$ X -&gt; Y_1, ... Y_N (X N, Y_i N T {})$</li></ul><ol type="1"><li>Begin with a string with only the start symbol S</li><li>Replace any non-terminal X in the string by the right-hand side ofsome production</li><li>Repeat (2) until there are non-terminals</li></ol><p>let G be a contexto-free grammar with start symbol S. Then thelanguage L(G) of is: <span class="math display">\[\{ a_1, ... a_n \quad | \quad \forall_i \quad a_i \in T \and S\mathop{\rightarrow}^* a_1, ..., a_n \}\]</span></p><ul><li>Terminals are so-called because there are no-reulses for replacingthem 终结符是不变的</li><li>Once generated, terminals are permanent，终结符是不变的</li><li>Terminals ought to be tokens of the language(终结符一般是语言的token，比如关键字，标识符)</li></ul><p>🌰：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">E -&gt; E + E<br> | E * E<br> | (E)<br> |<span class="hljs-built_in"> id</span><br> <br>对应的语言：<span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span> +<span class="hljs-built_in"> id</span> *<span class="hljs-built_in"> id</span><br><span class="hljs-built_in">(id</span> +<span class="hljs-built_in"> id</span>) *<span class="hljs-built_in"> id</span><br></code></pre></td></tr></table></figure><p>整个CFG是一个很大的步骤，需要：</p><ul><li>Membership in a alnguage is yes or no, also parse tree of theinput</li><li>Must handle errors gracefully</li><li>Need an implementation of CFG's (eg: bison)</li></ul><h2 id="derivations推导">Derivations(推导)</h2><p>A derivations s a <strong>sequence</strong> f production: <spanclass="math display">\[S -&gt; .. -&gt; ,,, -&gt; ... -&gt; ..\]</span> 推导过程可以以树的形式画出来：</p><ul><li>start symbol is the tree's root</li><li>For a production <spanclass="math inline">\(X-&gt;Y_1Y_2..Y_n\)</span> add children <spanclass="math inline">\(Y_1Y_2...Y_n\)</span> o node X</li></ul><p>考虑下面语法： <span class="math display">\[E → E + E |  E * E | (E) | id\]</span> 以及字符串：id * id + id</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230617134603437.png"alt="image-20230617134603437" /><figcaption aria-hidden="true">image-20230617134603437</figcaption></figure><p>A parse tree has</p><ul><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ul><blockquote><p>对叶子节点的in-order遍历就是原始输出，parsetree表示了token之间的各种关系</p><p>如下：</p><p>叶子节点从左到右：就是原始输入：id * id + id</p><p>中间节点和左右兄弟节点的关系也很明确，*的左右就是id</p></blockquote><p>上述推导式的产生是left-most，即在每一步优先推导最左边的符号（即推导方向是自左向右），但是这样可能会出现没有结束条件而一直无限推导下去。还有一种与之类似的right-most推导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">E<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + E</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * E + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">E * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">id</span> * <span class="hljs-built_in">id</span> + <span class="hljs-built_in">id</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Note that r-most and l-most derivations have the same parse tree</p><p>A derivations defines a parse tree, but one parse tree may have manyderivations</p><p>一个Parse tree可能有很多种推导方式可以得到，但是最左推导和最右推导是最重要的两种方式</p></blockquote><p><strong>Conclusion</strong>:</p><ul><li>不仅对某个字符串是否属于L(G)(语法G所产生的语言)感兴趣，也需要对应的解析树</li><li>一个推导式定义了一个解析树（或者解析树的一部分），同一个Parse tree可能有很多种推导方式可以得到</li></ul><h2 id="ambiguity语法的二义性">Ambiguity(语法的二义性)</h2><h3 id="解析优先级">解析优先级</h3><p>Grammar: E -&gt; E + E | E * E | (E) | id</p><p>String stream: id * id + id</p><p>不同的推导得到不同的parse tree：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">id</span><br><span class="hljs-variable">id</span>  <span class="hljs-variable">id</span> <br><br><span class="hljs-built_in">E</span><br><span class="hljs-built_in">E</span>  <span class="hljs-operator">*</span>  <span class="hljs-built_in">E</span><br>  <span class="hljs-variable">id</span>  <span class="hljs-built_in">E</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">E</span><br> <span class="hljs-variable">id</span>   <span class="hljs-variable">id</span> <br></code></pre></td></tr></table></figure><blockquote><p>A grammar is ambiguous if it has more than one parse tree for somestring, 换句话说，对于某些字符串，可以由超过一种的做作或最右推导方式</p></blockquote><p><strong>How to handle ambiguous</strong></p><p>Method 1:</p><p>重写语法：其实本质上是强制了解析时候的优先级</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E -&gt; <span class="hljs-string">E&#x27; + E/E&#x27;</span><br><span class="hljs-string">E&#x27; -&gt; id * E&#x27;</span> | id | (E) * <span class="hljs-string">E&#x27;| (E) </span><br></code></pre></td></tr></table></figure><p>Method 2：</p><p>不重写，但是在解析的时候，使用优先级或者判断哪个是最优的</p><h3 id="结合性">结合性</h3><h2 id="parsing-error-handleparser过程的错误处理">Parsing ErrorHandle(parser过程的错误处理)</h2><table><thead><tr class="header"><th>Error kind</th><th>Example</th><th>Detected by</th></tr></thead><tbody><tr class="odd"><td>Lexical</td><td>使用了未知符号，比如else写成了eles</td><td>Lexer</td></tr><tr class="even"><td>Syntax</td><td>编写的程序存在结构错误，比如while后面应该有一对{},但是只写了一个{</td><td>parser</td></tr><tr class="odd"><td>Semantic</td><td>int x; x(3);声明x为普通变量，但是却把x当成函数使用</td><td>Type Checker</td></tr><tr class="even"><td>Correctness</td><td>自己的代码虽然通过了编译器，但是运行结果不符合预期</td><td>User/Tester，一般需要自己debug</td></tr></tbody></table><p>Error handler should:</p><ul><li>Report errors accurately and clearly</li><li>Recover from an error quickly</li><li>Not slow down compilation of valid code</li></ul><p>常见的三种不同错误处理模式：</p><ul><li>Panic Mode (使用特殊的终止符(error)吃掉错误，继续执行)<ul><li>When an error is detected<ul><li>Discard tokens until one with clear role is found</li><li>Continue from here</li></ul></li></ul></li></ul><p>​ 🌰：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">(1 + + 2) + 2<br><span class="hljs-keyword">skip </span>ahead to next interger and then continue<br></code></pre></td></tr></table></figure><p>Bison: use the special terminal error to descide how mucg input toskip</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">E -&gt; int | <span class="hljs-type">E</span> + E | <span class="hljs-type">(E</span>) | <span class="hljs-type">error</span> int | <span class="hljs-type">(error</span>)<br></code></pre></td></tr></table></figure><ul><li><p>Error productions (添加可能的错误的推导式): specify known commonmistakes in the grammar</p><p>Eg: write 5 x instead of 5 * x</p><p>Add production E -&gt; .... | E E</p><p>Disadvantage: complicates the grammar</p></li><li><p>Automatic local or global correction</p><ul><li>Find a correct "nearby" program<ul><li>try token insertions and deletions (编辑距离)</li><li>exhaustive search</li></ul></li><li>Disadvantages:<ul><li>hard to impl</li><li>slows down parsing of correct programs</li><li>"nearby" is not necessarily "the intended" program</li></ul></li></ul></li></ul><p>Past:</p><ul><li>Slow recompilation cycle (even once a day)</li><li>rind as many errors in one cycle as possible</li></ul><p>Present:</p><ul><li>Quick recompilation cycle</li><li>users tend to correct one error/cycle</li><li>Complex error recovery is less compelling</li></ul><h2 id="another-clean-parse-tree-form-ast">Another Clean Parse Tree Form—— AST</h2><p>Parser跟踪(trace)一个token序列的推导过程，并由此产生Parse tree</p><p>🌰：</p><p>Grammar: E -&gt; int | (E) | E + E</p><p>After lexical analysis: [Int(2), '+', '(', Int(1), '+', 'Int(5),')']</p><p>Parse Tree:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">E<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) (E)<br>E + E<br><span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>AST：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">2</span>)  <span class="hljs-selector-attr">[Plus, leftO, rightO]</span><br><span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">Int</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>被称之为AST，因为它从具体语法中抽象出来，煎炒了具体语法的细节；而ParseTree展示了具体的推导规则和相关结构，对于编译器来水说，有很多不必要的内容</p><h3 id="递归下降解析">递归下降解析</h3><p>解析树一般按照如下方式构建：</p><ul><li>自上至下</li><li>从左到右</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span><br><span class="hljs-built_in">t2</span>. <span class="hljs-number">3</span>.  <span class="hljs-built_in">t9</span><br>   <span class="hljs-number">4</span>. <span class="hljs-number">7</span> <br>  <span class="hljs-built_in">t5</span>. <span class="hljs-built_in">t6</span>.  <span class="hljs-built_in">t8</span><br></code></pre></td></tr></table></figure><p>Tokens: [t2, t5, t6, t8, t9]</p><p>看一个详细的递归下降解析的🌰：</p><p>考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>输入：<span class="math inline">\((int_5)\)</span></p><p>步骤：</p><p>从起始菲终结符开始，依次尝试关于E的推导式</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-type">E</span> -&gt; <span class="hljs-type">T</span> -&gt; <span class="hljs-built_in">int</span> (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; [<span class="hljs-built_in">int</span> * <span class="hljs-type">T</span>] (mismatch: <span class="hljs-built_in">int</span> does not <span class="hljs-keyword">match</span> (, backtrack) =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符<span class="hljs-built_in">int</span> =&gt;<br> <span class="hljs-type">T</span> -&gt; ( <span class="hljs-type">E</span> -&gt; <span class="hljs-built_in">int</span> ) (<span class="hljs-keyword">match</span>: 继续下一个输入字符) =&gt;<br></code></pre></td></tr></table></figure><p>递归下降解析算法的一般定义如下：</p><p>首先定义几个关于是否符合某个匹配的函数：</p><ul><li><p>是否为终结符：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">bool</span> <span class="hljs-title function_">term</span>(<span class="hljs-params">TOKEN</span> <span class="hljs-params">tok</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-operator">*</span><span class="hljs-variable">next</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">==</span> <span class="hljs-variable">tok</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S第n个推导式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Sn</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>是否为lfs为S的推导式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">S</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>🌰：</p><ul><li><p>E -&gt; T: bool E1() { return T() }</p></li><li><p>E -&gt; T + E: bool E2() { return T() &amp;&amp; term(PLUS)&amp;&amp; E() }</p></li><li><p>对于整个E来说：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">bool E() &#123;<br>TOKEN *<span class="hljs-built_in">save</span> = <span class="hljs-built_in">next</span>;<br>return (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E1()) || (<span class="hljs-built_in">next</span> = <span class="hljs-built_in">save</span>, E2());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>同样的对于上面的非终结符T，有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T1</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T2</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(INT) &amp;&amp; term(TIMES) &amp;&amp; T();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T3</span>()</span> &#123;<br><span class="hljs-keyword">return</span> term(OPEN) &amp;&amp; E() &amp;&amp; term(CLOSE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">T</span>()</span> &#123;<br> TOKEN *save = next;<br><span class="hljs-keyword">return</span> (next = save, T1()) || (next = save, T2() || (next = save, T3()));<br>&#125;<br></code></pre></td></tr></table></figure><p>整个步骤：</p><ul><li>初始化next为第一个token</li><li>调用E()</li></ul><p><strong>Conslusion</strong>:</p><p>递归下降过程中，不断地递归合回溯所产生的函数调用结构其实就是解析树的体现，所以在递归下降的同时构建AST。</p><h3 id="上面的递归下降算法的限制">上面的递归下降算法的限制：</h3><p>对于E -&gt; T | T | T +E，一旦递归到了T，并且从继续向下递归，一旦不符合了，只会在当前层级尝试其他的推导式，但是不会基于T的同层级去尝试T和T+E</p><p>所以上面的普通的递归下降只适用于一部分语法，对于有些不符合的语法，可以采用左因子(left-factor)进行改写：</p><h3 id="左递归">左递归</h3><p>考虑产生式：S -&gt; S a</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">bool <span class="hljs-built_in">S1</span>() &#123; return <span class="hljs-built_in">S</span>() &amp;&amp; <span class="hljs-built_in">term</span>()&#125;<br>bool <span class="hljs-built_in">S</span>() &#123; return <span class="hljs-built_in">S1</span>()&#125;<br></code></pre></td></tr></table></figure><p>如果使用递归下降，会产生如下的调用链条：S =&gt; S1 =&gt; S =&gt; S1=&gt; ...</p><p>这就是左递归语法</p><p>以下是左递归语法更一般的定义： <span class="math display">\[S \mathop{\rightarrow}^+ S\alpha (+表示至少有一次推导)\]</span> 再看这个🌰： <span class="math display">\[S \rightarrow S\alpha | \beta\]</span> 将会产生以<span class="math inline">\(\beta\)</span>开头的且<span class="math inline">\(\beta\)</span>后面紧跟任意数量(&gt;=0)<spanclass="math inline">\(\alpha\)</span>的字符串。</p><p>既然已经知道了会产生什么样的字符串，可以通过把文法改写成右递归避免递归下降产生的左递归问题：<span class="math display">\[S \rightarrow \beta S&#39; \\S&#39; \rightarrow \alpha S&#39; | \epsilon\]</span> Conclusion：</p><p>一般的递归下降是从左到右解析，由于该算法的性质，遇到做递归文法会导致无穷递归；可以通过把左递归文法改成特殊(这里的右递归文法也仅仅适用于部分语法)的右递归文法避免这个问题，因为这个时候非终结符在最右边，不会有右边字符存在一直饥饿(一直访问不到)的现象。</p><p>更一般的，可以改写成如下特殊的右递归文法： <spanclass="math display">\[S&#39; \rightarrow S\alpha_1 | ... | S\alpha_n | \beta_1|...|\beta_m\]</span></p><p><span class="math display">\[S \rightarrow \beta_1 S&#39;| ... | \beta_m S&#39; \\S&#39; \rightarrow \alpha_1 S&#39; | ... | \alpha_nS&#39; | \epsilon\]</span></p><p>但是有些语法，如： <span class="math display">\[S \rightarrow A\alpha | \beta \\A \rightarrow S \beta\]</span> 这个语法也是左递归语法，写成如下形式更好理解： <spanclass="math display">\[S \mathop{\rightarrow}^+ S \beta \alpha\]</span> 可以通过其他方式消除左递归。</p><p>继续top-down</p><h3 id="预测">预测</h3><p>Predicive Parsers like recursive-descent but parser can<strong>"predict"</strong> which production to use:</p><ul><li>By looking at the next few tokens</li><li>No backtracking</li></ul><p>Predicive Parsers accept LL(k) grammars (1st L: left 2 right, 2nd L:left-most derivation, k: k tokens look ahead)</p><p>在递归下降算法里：</p><ul><li>每一步，有很多产生式可以使用，如：E -&gt; T | T | T +E，对于E，有3种选择</li><li>需要通过回溯撤销bad choices</li></ul><p>LL(1):</p><ul><li>通过改写成合适的文法（一般是左因子分解，左因子分解可以理解为公共左因子提取，这里的因子值终结符）每一步，仅有一步选择：</li></ul><blockquote><p>Hint:其实就是根据当前预测字符决定选择使用哪个推导式，而这个预测字符和推导式的关系需要用一张表来记录</p></blockquote><p>继续考虑语法Grammar:</p><p>E -&gt; T | T | T + E</p><p>T -&gt; int | int * T | (E)</p><p>难以产生预测字符：</p><ul><li>对于T，有两个int开头的推导式，所以即使当前有预测字符int，也无法选择哪一个是最优的推导</li><li>对于E，更不容易看出预测字符是什么</li></ul><p>需要左因子语法改写：</p><p>E -&gt; TX</p><p>X -&gt; +E | </p><p>T -&gt; intY | (E)</p><p>Y -&gt; *T | </p><p>根据新语法可以计算得到LL(1) parse table:其中表头为下一个输入的token，每一行是非终结符，单元格里的内容就是当前使用哪个推导式的rfs，这里暂时没有讲如何构造这张表的</p><table><thead><tr class="header"><th></th><th>int</th><th>*</th><th>+</th><th>（</th><th>）</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td></tr><tr class="even"><td>X</td><td></td><td></td><td>+E</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="odd"><td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td></tr><tr class="even"><td>Y</td><td></td><td>*T</td><td><span class="math inline">\(\epsilon\)</span></td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>比如：[Y, +] entry，表示当前非终结符Y，遇到了当前输入token +</p><p>那么Y就可以按照<span class="math inline">\(Y \rightarrow\epsilon\)</span> 推导，</p><p>[E, *] entry，表示当前非终结符X，遇到了当前输入token*，没有合适的推导式可以使用</p><p>这里我们再提一个额外的知识点：</p><p>我们不想采用递归的方式去做解析，而是利用栈解析：</p><ul><li>非终结符仍然是扩展替换的</li><li>终结符也仍然会输入进行比较匹配</li><li>栈顶=最左边的待处理的非终结符或非终结符</li><li>Reject on reaching error state</li><li>Accepy on end of input &amp; empty stack</li></ul><p>形式化定义如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">initialize stack = &lt;S $&gt; and <span class="hljs-keyword">next</span><br>repeat<br><span class="hljs-keyword">case</span> stack of<br>&lt;X, rest&gt;: <span class="hljs-keyword">if</span> T[X, *<span class="hljs-keyword">next</span>] = Y1...Yn<br>then stack &lt;- &lt;Y1...Yn rest&gt;;<br><span class="hljs-keyword">else</span> error(); <span class="hljs-comment">// 不存在推导动作则直接报错</span><br>&lt;t, rest&gt;: <span class="hljs-keyword">if</span> t == *<span class="hljs-keyword">next</span>++<br>then stack &lt;- &lt;rest&gt;;<br><span class="hljs-keyword">else</span> error();<br>until stack == &lt;&gt;<br><br>初始化的时候栈顶是其实非终结符S,<br>后续，如果当前栈顶是非终结符X，且根据预测表执行的推导动作是X -&gt; Y1...Yn,则<span class="hljs-keyword">pop</span> X <span class="hljs-keyword">from</span> stack and <span class="hljs-keyword">push</span> Y1...Yn <span class="hljs-keyword">into</span> stack<br>否则：如果栈顶是终结符且和当前输入相同（说明栈顶的这个元素直接可以使用其本身进行推导），则<span class="hljs-keyword">pop</span> t <span class="hljs-keyword">from</span> stack<br></code></pre></td></tr></table></figure><p>看一个🌰：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619230522565.png"alt="image-20230619230522565" /><figcaption aria-hidden="true">image-20230619230522565</figcaption></figure><h3 id="first">first</h3><h3 id="follow">follow</h3><h3 id="ll1-parse-table">ll1-parse-table</h3><p>构建预测表的步骤：</p><p>For each production <span class="math inline">\(A \rightarrow\alpha\)</span> in G do:</p><ul><li>For each terminal <span class="math inline">\(t \inFirst(\alpha)\)</span> do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>for each t $t Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li><li>If <span class="math inline">\(\epsilon \in First(\alpha)\)</span>and t $$ Follow(A) $ do<ul><li><span class="math inline">\(T[A, t] = \alpha\)</span></li></ul></li></ul><p>First() = { $, ) }</p><p>Follow(X) = { +, $, ) }</p><p>所以上面的语法形成的预测表如下</p><table><thead><tr class="header"><th></th><th>(</th><th>)</th><th>+</th><th>*</th><th>int</th><th>$</th></tr></thead><tbody><tr class="odd"><td>E</td><td>TX</td><td></td><td></td><td></td><td>TX</td><td></td></tr><tr class="even"><td>T</td><td>(E)</td><td></td><td></td><td></td><td>intY</td><td></td></tr><tr class="odd"><td>X</td><td></td><td>+E</td><td></td><td></td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr><tr class="even"><td>Y</td><td></td><td><span class="math inline">\(\epsilon\)</span></td><td><span class="math inline">\(\epsilon\)</span></td><td>*T</td><td></td><td><span class="math inline">\(\epsilon\)</span></td></tr></tbody></table><p>上述表格每个表格内的条目最多只有一条，当唯恐的时候，表示解析遇到错误，下面看一个表格内不止一个条目的例子：</p><p>语法：<span class="math inline">\(S -&gt; Sa | b\)</span></p><p>First(S) = { b }</p><p>Follow(S) = { $, a }</p><table><thead><tr class="header"><th></th><th>a</th><th>b</th><th>$</th></tr></thead><tbody><tr class="odd"><td>$</td><td>b / Sa</td><td></td><td></td></tr></tbody></table><p>正如上面的例子，如果一个表的内容是多个，则该语法不是LL(1)，当燃判断是否为LL(1)还有其他方法：</p><ul><li>非左因子语法不是LL(1)</li><li>左递归不是LL(1)</li><li>二义性也不是</li><li>其他的，如LL(k), k &gt; 1也不是</li></ul><p><strong>网页知识点：</strong></p><p>LL和LR：</p><p>概念梳理：</p><p>首先说明，Context-freegrammar与无二义性文法不是一个层级的概念。CFG的意思是：我们用产生式设计的一组文法，对于每一个推导，其中的NT可以任意地被产生式右部替换而合法（这并不限制对于一个文本，只能推理出一棵树）。也就是每个NT之下的产生式是等价的，比如对于Verb-&gt;吃/睡/飞，在具体解析时，不论前面的主语/后面的宾语是什么，都合法。二义性是在CFG之下的概念。</p><p><ahref="https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html">LLand LR Parsing Demystified (reverberate.org)</a></p><p>LL表示从左到右扫描输入并执行最左推导，LL和LR相比哪个适用范围更广呢？</p><p>为简单讨论，我们只讨论LL(1)和LR(1)，1代表向前查看的字符数量（预测1个字符），1表示任何时刻我们提前查看当前输入字符的下一个字符，再根据这个提前查看的字符决定使用哪一个规约行为。</p><ul><li>In LL(1) we see the first symbol of the input and see the productionto apply. So, if there is two productions with the same ‘first’ symbolas in the input parser gets a conflict and fails.</li><li>在LL(1)里，我们自左到右进行规约，查看当前字符和采用对应的推导式进行规约。所以，如果如果有两个推导式有着相同的fiestsymbol，就会产生冲突</li><li>在 LR（1）中，我们看到从左边开始的输入，直到我们得到一个handle。在此之后，我们再看到一个前瞻符号并确定解析器操作.即，解析器比LL（1） 中有更多的信息来决定其操作，这使得它比 LL（1）更强大。更强大的手段是，任何可以被 LL（1） 解析的语法也可以被 LR（1）解析。</li><li>这种情况在更一般的场景下也成立，对于任何k，LL（k）语法集是LR（k）语法集的适当子集</li></ul><p>这里我们所说的解析器的能力指的是其可以解析的语法的范围，并不是说它能够生成的语言。所以什么是LL(1)语言呢，它们是不是都可以被LL(1)生成呢？</p><p>实际上LL(k)的能力和k成正比，k越大，LL(k)的能力越强，LL(k)是LL(k+1)的子集</p><p>那LR(k)?</p><p><span class="math inline">\(First(\alpha)\)</span> 是从<spanclass="math inline">\(\alpha\)</span>推导的handle的起始终结符的集合</p><p><spanclass="math inline">\(Follow(A)\)</span>(这里大写表示A是一个非终结符)，是紧跟在A后面的终结符的集合</p><p>当且仅当一个语法G满足如下条件，G才被称之为LL(1):</p><ol type="1"><li>G not unambiluous</li><li>G not left-recursive</li><li>If there is a production <span class="math inline">\(A→\alpha |\beta\)</span>, then<ol type="1"><li><span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> 否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span> contains <span class="math inline">\(\epsilon\)</span>,<span class="math inline">\(First(\beta)\)</span>不应该包含<spanclass="math inline">\(\epsilon\)</span>,否则解析器不知道使用哪个推导式</li><li>if <span class="math inline">\(First(\alpha) \cup First(\beta) =empty\)</span>, <span class="math inline">\(First(\beta) \cupFirst(\alpha) = empty\)</span>, 否则解析器不知道使用哪个推导式</li></ol></li></ol><p>下面是LR部分:</p><p>item：文法的一个产生式G加上其右部某一位置的一个点，这个点表示了分析过程中的状态。</p><p>产生式A-&gt;XYZ 产生的四个项：</p><p>A-&gt;·XYZ A-&gt;X·YZ A-&gt;XY·Z A-&gt;XYZ·以第二个项为例，其表示已经接收了一个可以由X推导的串，如果希望能归约，那么接下来要识别一个能够由YZ推导的串。</p><p>Dcfl is a superset of regular. But dcfl with prefix property isnot.</p><h1 id="viable-prefixes-and-handle-in-lr-parsing">Viable Prefixes andHandle in LR Parsing</h1><h3 id="bottom-up-parsing">Bottom-up Parsing</h3><p>Consider the grammar</p><ul><li><span class="math inline">\(S -&gt; XX\)</span></li><li>$X -&gt; aX | b $</li></ul><p>Now, consider a string in <span class="math inline">\(L(S)\)</span>say aabb. We can parse it as follows by left most derivation – replacingthe left most non-terminal in each step, or right most derivation –replacing the rightmost non-terminal in each step.</p><p>考虑一个符合该文法的字符串aabb，我们可以按照最左推导解析它（每一步替换最左边的非终结符）或者也可以按照最右推导解析它（每一步替换最右边的非终结符）</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230619000054295.png"alt="image-20230619000054295" /><figcaption aria-hidden="true">image-20230619000054295</figcaption></figure><p><strong>上面的最右推导被用在bottom-up parsing</strong></p><blockquote><ul><li><em>Any string derivable from the start symbol is a sentential form— it becomes a sentence if it contains only terminals</em></li><li><em>A sentential form that occurs in the leftmost derivation of somesentence is called left-sentential form</em></li><li><em>A sentential form that occurs in the rightmost derivation ofsome sentence is called right-sentential form</em></li></ul></blockquote><p>再次考虑字符串aabb，我们可以按照如下方法解析：</p><p>从左至右扫描输入，如果存在子串匹配任何推导式的<strong>右侧</strong>(RHS,right hand of string), 用该推导式的<strong>左侧</strong>替换该字符串</p><p>具体步骤如下：</p><ol type="1"><li>‘a’ “abb” – 不存在RHS匹配'a'</li><li>‘aa’ “bb” – 不存在RHS匹配'a' 或者 'aa'</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as</li></ol><p>Consider the string aabb again. We will see a method to parsethis:</p><ol type="1"><li>Scan the input from left to right and see if any substring matchesthe RHS of any production. If so, replace that substring by the LHS ofthe production.</li></ol><p>So, for “aabb” we do as follows</p><ol type="1"><li>‘a’ “abb” – No RHS matches ‘a’</li><li>‘aa’ “bb” – No RHS matches ‘a’ or ‘aa’</li><li>‘aab’ “b” – RHS of <span class="math inline">\(X→b\)</span> matches‘b’ (first b from left) and so we write as aaXb</li><li>‘aaX’ “b” – RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and so we write as</li><li>aXb – Again RHS of <span class="math inline">\(X→aX\)</span> matches“aX” and we get</li><li>Xb – RHS of <span class="math inline">\(X→b\)</span> matches “b” andwe get</li><li>XX – RHS of <span class="math inline">\(S→XX\)</span>matches XX andwe get</li><li>S – the start symbol.</li></ol><p>Now what we did here is nothing but a bottom-up parsing. Bottom-upbecause we started from the string and not from the grammar. Here, weapplied a sequence of reductions, which are as follows: <spanclass="math display">\[aabb → aaXb → aXb → Xb → XX → S\]</span> If we go up and see the Rightmost derivation of the string“aabb”, what we got is the same but in REVERSE order. i.e., our bottomup parsing is doing reverse of the RIGHTMOSTderivation(仔细观察上述的替换过程和最开始的最右推导的顺序是相反的).<strong>So, we can call it an <span class="math inline">\(LR\)</span>parser –$ L$ for scanning the input from Left side and <spanclass="math inline">\(R\)</span> for doing a Rightmostderivation.</strong></p><p>In our parsing we substituted the RHS of a production at each step.This substituted “substring” is called a HANDLE and are shown in<strong>BOLD</strong>below(在推导过程中，我们在每一步替换了子串，这些子串称为Handle，在下面被加粗了).<span class="math display">\[aa\bold bb → a\bold a \bold Xb → \bold a \bold Xb → X\bold b → \bold X\bold X → S\]</span> Formally a handle is defined as (Greek letters used to denotea string of terminals and non-terminals)</p><blockquote><p>"<em>A handle of a right sentential form ‘</em>γ<em>’</em>(γ=αδβ<em>) is a production</em> E→δ <em>and a position in</em> γ<em>where</em> δ <em>can be found and substituted by</em> E <em>to getthe</em> <strong>previous step</strong> <em>in the right most derivationof</em> γ <em>— previous and not “next” because we are doing rightmostderivation in REVERSE. Handle can be given as a production or just theRHS of a production.</em></p></blockquote><p>The handle is not necessarily starting from the left most position asclear from the above example(从上面的例子可以看到handle不一定开始于RHS的最左边). There is importanceto the input string which occurs to the left of the handle(所谓的可行前缀就是当前handle的所有前缀). For example for the handles of“aabb”, we can have the following set of prefixes</p><table><tbody><tr class="odd"><td>aa<strong>b</strong>b</td><td>{a, aa, aab}</td></tr><tr class="even"><td>aa<strong>X</strong>b</td><td>{a, aa, aaX}</td></tr><tr class="odd"><td>a<strong>X</strong>b</td><td>{a, aX}</td></tr><tr class="even"><td>X<strong>b</strong></td><td>{X, Xb}</td></tr><tr class="odd"><td><strong>XX</strong></td><td>{X, XX}</td></tr></tbody></table><p>These set of prefixes are called Viable Prefixes(这些前缀集合被称为可行前缀). Formally</p><blockquote><p>" Viable prefixes are the prefixes of right sentential forms that donot extend beyond the end of its handle.</p><p>i.e., a viable prefix either has no handle or just one possiblehandle on the extreme RIGHT which can be reduced.</p></blockquote><p>We will see later that viable prefixes can also be defined as the setof prefixes of the right-sentential form that can appear on the stack ofa shift-reduce parser. Also, the set of all viable prefixes of the rightsentential forms of a grammar is a REGULAR LANGUAGE. i.e., viableprefixes can be recognized by using a FINITE AUTOMATA. Using this FINITEAUTOMATA and a stack we get the power of a Push Down Automata and thatis how we can parse context-free languages.</p><p>在后面，可行前缀也可以被定义为出现在shift-reduce解析器的最右推导式的前缀集合。当然，所有的可行前缀是正则语言，所以，可行前缀可以被有限自动机识别。使用有限自动机和stack就可以PushDown Automata，这本质上就是在解析上下无关文法。</p><p><strong>参考文献</strong>：https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/100%20Bottom-Up%20Parsing.pdf</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 12 Conclusion</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>运行时和编译时的划分及概念（广义和狭义）？</p><p>compile: The instructions or <strong>source code written usinghigh-level language is required to get converted to machine code for acomputer to understand.</strong> During compile time, the source code istranslated to a byte code like from <ahref="https://www.baeldung.com/java-classes-objects">.java to.class</a>. During compile time the compiler check for the syntax,semantic, and type of the code.</p><h3 id="inputs-and-outputs">Inputs and Outputs</h3><p>Inputs and outputs during compile time are the following:</p><ul><li><strong>Inputs –</strong> Source code, dependent files, interfaces,libraries required for successful compilation of the code</li><li><strong>Outputs –</strong> On successful compilation, a compliedcode (<ahref="https://www.sciencedirect.com/topics/computer-science/assembly-code">assemblycode</a> or <ahref="https://www.cs.tufts.edu/comp/40/calendar/lectures/05-CompilationSteps.pdf">relocatableobject code</a>), otherwise <ahref="https://student.cs.uwaterloo.ca/~cs133/Resources/Java/Debugging/compile.shtml">compiletime error</a> messages</li></ul><p>Errors: <strong>During compile time errors occur because of syntaxand semantic.</strong> The syntax error occurs because of the wrongsyntax of the written code. Semantic errors occur in reference tovariable, function, type declarations and type checking.</p><p>简单来说，就是把源代码编译成计算器可以理解的语言，就是编译，注意这里计算机可以理解的语言不一定是汇编和机器码什么的，也可以是与特定操作系统无关的中间语言(字节码)，这个时候可以把这些执行字节码的解释器或者虚拟机理解一个小型的操作系统。</p><p>Runtime:</p><p><strong>A program’s life cycle is a runtime when the program is inexecution.</strong> Following are the different types of runtimeerrors:</p><ul><li><strong>Division by zero</strong> – when a number is divided by zero(0)</li><li><strong>Dereferencing a null pointer</strong> – when a programattempts to access memory with a NULL</li><li><strong>Running out of memory</strong> – when a computer has nomemory to allocate to programs</li></ul><figure><imgsrc="https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-25c5794ab97de69a698576bf136da63a_l3.svg"alt="Rendered by QuickLaTeX.com" /><figcaption aria-hidden="true">Rendered by QuickLaTeX.com</figcaption></figure><p>静态作用域和动态作用域的实现有什么不同？</p><p>静态类型检查和动态类型检查:</p><p>首先得先明确什么是编译时什么是运行时，</p><p>一般的运行时表示从上至下执行汇编代码，但还有些运行时包含中间代码执行时的运行时，举个例子：</p><p>Python =&gt; (编译) pyc(中间代码文件) =&gt; (解释器解释执行) 结果</p><p>这里的pyc =&gt;结果就是运行时，这一步其实包含了把中间代码转为汇编or机器指令的过程，以及优化和类型检查，垃圾回收等，但其实用户感知不到这些过程，感觉好像字节码直接被运行了，所以这些也被包含在运行时里，</p><p>思考：编译+AI优化？</p><p>上下有关文法的理解，什么语言会用上下有关文法，上下无关文vs上下有关文法的比较，各有什么特点</p><p>题主的主要疑惑应该在于：什么是上下文，上下文在哪里？为什么说这个文法上下文无关？</p><p>答案就是：在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关的意思的，只要文法的定义里有某个产生式，不管一个<ahref="https://www.zhihu.com/search?q=非终结符&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">非终结符</a>前后的串是什么，就可以应用相应的产生式进行推导。（从形式上来看，就是产生式的左边都是单独一个非终结符，即形如S-&gt; ...，而不是非终结符左右还有别的东西，例如 aSb -&gt; ...）</p><p>作者：Quokka链接：https://www.zhihu.com/question/21833944/answer/307309365来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>这么描述有点儿抽象，我举一个<ahref="https://www.zhihu.com/search?q=自然语言&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">自然语言</a>的例子：</p><p><strong><ahref="https://www.zhihu.com/search?q=上下文无关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文无关文法</a>：</strong></p><p>产生式：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>V -&gt; 吃 | 下</p><p>O -&gt; 雨 | 雪 | 饭 | 肉</p><p>其中英文字母都是非终结符（SVO 分别表示<ahref="https://www.zhihu.com/search?q=主谓宾&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">主谓宾</a>），汉字都是终结符。</p><p>这个文法可以生成如下句子（共 2<em>2</em>4=16种组合，懒得写全了，简单写 7 种意思意思）：</p><p>｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝</p><p>可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=天VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">天VO</a>-&gt; 天吃O -&gt; 天吃肉</p><p>但是上下文无关文法里，因为有“V -&gt; 吃 | 下”这样一条产生式，V就永远都可以推出“吃”这个词，它并不在乎应用“V -&gt; 吃 |下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V左右两边的字符串”天“和”O“）。事实上，在 V推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。</p><p>那<strong><ahref="https://www.zhihu.com/search?q=上下文有关文法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">上下文有关文法</a></strong>呢？产生式可以定义为（其中前两条产生式仍是上下文无关的，后四条则是上下文有关的）：</p><p>Sent -&gt; S V O</p><p>S -&gt; 人 | 天</p><p>人V -&gt; 人吃</p><p>天V -&gt; 天下</p><p>下O -&gt; 下雨 | 下雪</p><p>吃O -&gt; 吃饭 | 吃肉</p><p>可以看到，这里对 V 的推导过程施加了约束：虽然 V还是能推出”吃“和”下“两个词，但是仅仅当 V左边是”人“时，才允许它推导出”吃“；而当 V左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含O 的产生式也约束了动宾搭配的一致性。</p><p>这样一来，这个语言包含的句子就只有｛<ahref="https://www.zhihu.com/search?q=人吃饭，天下雨，人吃肉，天下雪&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人吃饭，天下雨，人吃肉，天下雪</a>｝这四条，都是语义上合理的。</p><p>以”人吃饭“为例，推导过程为：</p><p>Sent -&gt; SVO -&gt; <ahref="https://www.zhihu.com/search?q=人VO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A307309365%7D">人VO</a>-&gt; 人吃O -&gt; 人吃饭</p><p>其中第三步推导是这样的：非终结符 V 的上文是“人”，因此可以应用“人V-&gt; 人吃”这条产生式，得到“人VO -&gt; 人吃O”。第四步也类似。</p><p>而</p><p><ahref="http://www.zhihu.com/people/20529960b7c64153695a7488fb49aeab"><spanclass="citation" data-cites="范彬">@范彬</span></a></p><p>回答的是语法的歧义性，这和 CFG 无关。最简单的例子：</p><p>假设有如下上下文无关文法：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">S -&gt; S1 | <span class="hljs-type">S2</span><br>S1 -&gt; ab<br>S2 -&gt; AB<br>A -&gt; a<br>B -&gt; b<br></code></pre></td></tr></table></figure><p>那么对于 "ab" 这个串，一种推倒方式是 S -&gt; S1 -&gt; ab，另一种是 S-&gt; S2 -&gt; AB -&gt; aB -&gt; ab。前一种要把 "ab"合起来，后一种要分开，这只是说明该文法有歧义，而不能说这是一个上下文有关文法。事实上，还有一些上下文无关语言是固有歧义的（能产生该语言的每一种上下文无关文法都有歧义）。</p><p>上下文无关文法就是说这个文法中<strong>所有的产生式左边只有一个非终结符</strong>，比如：</p><p>S -&gt; aSb</p><p>S -&gt; ab</p><p>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>比如：</p><p>aSb -&gt; aaSbb</p><p>S -&gt; ab</p><p>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法</p><p>在替换的时候，不是直接替换，还要考虑左边符号的左右环境</p><p>现代编译器和字节码？</p><p>typescript？</p><p>编译的概念是什么？</p><p>为什么正则语言不能用于文法解析？因为正则语言无法处理递归的嵌套结构，不信你用正则写一个嵌套任意层级的if-else试试？</p><p>为什么要有空转换：A -&gt; epsilon ?主要是未来消耗某个非终结符哈，以预测一个字符为例：</p><p>T[E, t] = a,t是一个预测字符，<strong>有一个特殊的情况，epsilon用于消耗某个非终结符</strong>，如X-&gt; E | epsilon</p><p>LL和LR差异</p><p>什么是LL(1),是语言还是解析器？其性质是什么，什么样的文法才是LL(1)</p><p>如何避免左递归</p><p>名次辨识：语言，语法，production， item，viableprefix，handle，解析器</p><p>LL1指的是文法</p><p>language:</p><p>grammar</p><p>Production:</p><p>Handle:句柄（handle）是一个来自编译原理的术语，指的是一个句子中最先被规约的部分，所以带有一个「句」字。</p><p>Viable prefix:</p><p>Parser:</p><p>Item:</p><p><a href="https://www.zhihu.com/question/20607178">(2 封私信 / 34条消息) 运行时（runtime）是什么意思？应该怎样深入且直观地理解？ - 知乎(zhihu.com)</a></p><p>运行时库不仅包含include的，也包含编译器自动插入的；</p><p>https://zhuanlan.zhihu.com/p/71718231</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 4 Parsing Analysis 2 (LR Analysis)</title>
    <link href="/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/"/>
    <url>/emocoder/2023/06/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>WIP</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network-CS144 の 1 Introduction</title>
    <link href="/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/emocoder/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>网络应用：</p><ul><li>基于网络读取和写数据</li><li>常见通信模型：双向的可靠的字节流（为什么是字节流）<ul><li>通信双方一边写入数据，一变读取数据</li><li>可靠的（除非连接中断）</li></ul></li></ul><h2 id="四层网络模型">四层网络模型</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt; Rout<span class="hljs-symbol">er:</span> 路由从链路层解析网络层的数据，获取target，根据路由转发标寻找下一跳，包装好后形成新的Link数据包，继续转发<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br><br><br>=&gt;<br><span class="hljs-number">1</span>. Application<br><span class="hljs-number">2</span>. Transport<br><span class="hljs-number">3</span>. Network：[Data, headd<span class="hljs-symbol">er:</span> [from, to]]<br><span class="hljs-number">4</span>. Li<span class="hljs-symbol">nk:</span> 数据组织形式：Packet, Link层，是在路由之间的数据传递，<span class="hljs-symbol">eg:</span> wifi <span class="hljs-built_in">and</span> 以太网<br></code></pre></td></tr></table></figure><p>网络层是特殊的：因为必须要使用 <code>Internet Protocol</code></p><ul><li>IP尽最大努力转发数据报，但是不能保证</li><li>IP数据报可能会丢失，会无需，会损坏，这些都是没办法保证的</li></ul><p>IP是最重要的，IP是瘦身层，因为其他协议都有很多种类，<strong>但是IP就一种，为什么呢</strong>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>, smtp, ssh, ftp<br><span class="hljs-attribute">tcp</span>, udp, rtp<br><span class="hljs-attribute">IP</span><br><span class="hljs-attribute">Ethernet</span> Wifi DSL <span class="hljs-number">3</span>G <span class="hljs-number">5</span>G<br></code></pre></td></tr></table></figure><p>传输层：</p><ul><li>TCP：虽然IP不保证，但是TCP保证</li><li>UDP</li></ul><p>七层OSI模型：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Application</span> <span class="hljs-operator">=</span>&lt; http<br><span class="hljs-attribute">Presention</span> <span class="hljs-operator">=</span>&gt; ASCII<br><span class="hljs-attribute">Session</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Transport</span> <span class="hljs-operator">=</span>&gt; TCP<br><span class="hljs-attribute">Network</span> <span class="hljs-operator">=</span>&gt; IP<br><span class="hljs-attribute">Link</span>    <span class="hljs-operator">=</span>&gt; Link<br><span class="hljs-attribute">Physical</span> <span class="hljs-operator">=</span>&gt; Link<br></code></pre></td></tr></table></figure><p>IP模型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Application<br>Transport: <span class="hljs-meta">[</span><span class="hljs-built_in">Data</span><span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Network    <span class="hljs-meta">[</span>   IP <span class="hljs-built_in">Data</span>  <span class="hljs-meta">]</span><span class="hljs-meta">[</span>IP <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br>Link   <span class="hljs-meta">[</span>   <span class="hljs-keyword">Link</span> <span class="hljs-built_in">Data</span>           <span class="hljs-meta">]</span><span class="hljs-meta">[</span><span class="hljs-keyword">Link</span> <span class="hljs-keyword">Header</span><span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><p>​</p><table><thead><tr class="header"><th>性质</th><th>行为</th></tr></thead><tbody><tr class="odd"><td>Datagram</td><td>独立的路由包，包是一跳一跳的转发</td></tr><tr class="even"><td>不可信</td><td>包可能会丢失</td></tr><tr class="odd"><td>尽力</td><td>尽最大里交付数据</td></tr><tr class="even"><td>Connectionless</td><td>No per-flow state（连接是无状态的） 包可能乱序</td></tr></tbody></table><p>为什么IP模型如此简单？</p><ul><li>快</li><li>端到端原则</li><li>更方便自定义在其上封装一些定制的协议（可信的or不可信的）</li><li>实现的简单，能够适用于各种链路层协议</li></ul><p>IP模型的特点：</p><ul><li>防止循环转发（套娃）</li><li>如果数据太长，将会分割数据报</li><li>使用checksum减少错误分发的机会</li><li>允许更多的IP版本，ipv4, ipv6</li><li>允许自定义header</li></ul><p>Ipv4数据报格式：网上有自己查</p><ul><li>version</li><li>header len</li><li>Toatl Packet len</li><li>Packet ID</li><li>flags</li><li>flags offset</li><li>TTL</li><li>protocol ID</li><li>checksum</li><li>src ip addr</li><li>dest ip addr</li><li>options</li><li>padding</li><li>Data</li></ul><p>整体流程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Client =&gt;<span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 171.67.76.157<br>TCP port: 80<br><br><br>Server:<span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>addr: 128.148.252.129<br>TCP port: 56567<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">Client </span>=&gt; router1 =&gt; router2 =&gt; <span class="hljs-built_in"> Server </span>(<span class="hljs-literal">No</span>, 么有直接连接)，一般是通过路由转发，每个路由里面都有路由表，如果没有找到则从默认路由转发<br></code></pre></td></tr></table></figure><h2 id="网络中的设计模式">网络中的设计模式</h2><h3 id="分组交换原理">分组交换原理</h3><p>将数据切割成小块（Packet）</p><blockquote><p>Packet: A self-contained unit of data that carries infomation for itto reach its destination</p></blockquote><p>分包转发(packetswitching)：每个到达的包都是相互独立的，如果这条链路是availble的，则服用；否则缓存数据包后，继续等待。</p><p>分包转发相当于让路由自己去做转发动作，可不可以在每个Packet里携带转发目的地信息呢？可以的，但是这种没有必要，占用了一定的数据，以及存在一定安全问题（会被诱导到不安全的网络）</p><p>分包转发的好处：</p><ul><li>交换机为每个数据包做单独的本地决策，不需要在数据包中指明路由</li><li>高效的链路共享</li><li>分包转发不需要为每个流量保存自己的状态，每个包都是自包含的</li></ul><h3 id="分层原则">分层原则</h3><p>将大系统切分成多个独立功能的部分</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">layer1</span> <span class="hljs-operator">=</span>&gt; layer2 <span class="hljs-operator">=</span>&gt; ... <span class="hljs-operator">=</span>&gt; layern<br></code></pre></td></tr></table></figure><p>好处：</p><ul><li>独立</li><li>顺序通信，从上到下，从下到上通信</li><li>上层为下层提供定义完整的服务，不需要了解下层是什么</li></ul><p>为什么要分层：</p><ul><li>Modularity</li><li>Well defined service</li><li>Reuse</li><li>Seperation of concerns</li><li>Continuous improvement</li></ul><h3 id="封装原则">封装原则</h3><p>Layer N data is payload to layer N - 1, eg:</p><ul><li>Http application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a wifi link frame</li></ul><p>分层的好处：Encapsulation Flexibility</p><p>Encapsulation allows you to layer recursively</p><p>VPN:</p><ul><li>HTTP application payload in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>a secured TLS presentation message in</li><li>a TCP transport segment in</li><li>an IP network packet in</li><li>an Ethernet link frame</li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">[link, ip, tcp, tls, ip, tcp, http]<br><br><span class="hljs-keyword">to</span> <span class="hljs-keyword">next</span> hop <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> vpn gateway, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span>, <span class="hljs-keyword">to</span> web <span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><h2 id="字节顺序">字节顺序</h2><h2 id="ipv4-vs-ipv6">IPv4 vs IPv6</h2><h2 id="最长前缀匹配">最长前缀匹配</h2><h2 id="地址解析协议">地址解析协议</h2><h2 id="总结">总结</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络，计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <url>/emocoder/2023/06/06/WebAssembly%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 5 Semantic Analysis</title>
    <link href="/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/"/>
    <url>/emocoder/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="type-checking-rules-and-how-to-implement"><strong>Type CheckingRules and How to Implement ?</strong></h2><p>Cool type can be implemented in a single traversal over the AST</p><ul><li>Type environment is passed down the tree (From parent tochild)，环境自上而下是在不断扩增的</li><li>Types are passed up the tree from (From child toparent)，类型是自底向上推导和检查的</li></ul><p>🌰： <span class="math display">\[\frac{O,M,C\vdash e_1:Int \quad O,M,C\vdash e_2:Int }{O,M,C\vdash e_1 +e_2:Int }\]</span></p><blockquote><p>Environment(Object, Method, Class),环境包括当前对象，当前方法及当前类</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">TypeCheck(Envirment, e1 + e2) = &#123;<br>T1 = TypeCheck(Envirment, e1)<br>T2 = TypeCheck(Envirment, e2)<br><span class="hljs-built_in">check </span>T1 == T2 == Int<br><span class="hljs-built_in">return </span>Int<br>&#125;<br></code></pre></td></tr></table></figure><p>🌰： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O,M,C\vdash e_0:T_0 \quadO[T/x],M,C\vdash e_1:T_1  \quadT_0 &lt;= T}{O,M,C\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">let</span> <span class="hljs-params">x</span>: T &lt;- <span class="hljs-params">e0</span> <span class="hljs-params">in</span> <span class="hljs-params">e1</span>)</span> = &#123;<br>T0 = <span class="hljs-constructor">TypeCheck(Envirment, <span class="hljs-params">e0</span>)</span><br>T1 = <span class="hljs-constructor">TypeCheck(Envirment.<span class="hljs-params">add</span>(&#123;<span class="hljs-params">x</span>: T&#125;)</span>, e1)<br>check <span class="hljs-constructor">SubType(T0, T)</span><br>return T1<br>&#125;<br><br>自上而下，environment不断扩增，自底向上检查类型<br></code></pre></td></tr></table></figure><h2 id="introduction-to-semantic-analysis">Introduction to SemanticAnalysis</h2><ul><li><p>Lexical analysis</p><ul><li>Detects inputs with illegal tokens</li></ul></li><li><p>Parsing</p><ul><li>Detects inputs with ill-formed parse trees</li></ul></li><li><p>Semantic analysis</p><ul><li>Last. Front end phase</li><li>Catched all remaining errors</li></ul></li></ul><p>Why do semantic analysis ?</p><ul><li>Parsing can't catch some errors</li><li><strong>Some langaguage constructs not context-free</strong></li></ul><blockquote><p><a href="https://www.zhihu.com/question/21833944">(2 封私信 / 25条消息) 应该如何理解「上下文无关文法」？ - 知乎 (zhihu.com)</a></p></blockquote><p>Semantic analysis will do ?</p><ul><li>All identifiers are declared</li><li>Type checking</li><li>Inheritance relationships checking</li><li>Classes defined ony once</li><li>Methods in a class defined only once</li><li>Reserved identifiers are not misused</li><li>...</li></ul><h2 id="静态作用域">静态作用域</h2><p>Matching static declarations with uses</p><ul><li>Important static analyisis step in most language</li><li>including COOL</li></ul><p>🌰：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> y: String &lt;- <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">3</span> <span class="hljs-comment">// 在后面的语句里y为string类型</span><br><br><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span> x + <span class="hljs-number">3</span> <span class="hljs-comment">// 没有看到x的定义，将会报错</span><br></code></pre></td></tr></table></figure><blockquote><p>The scope of an identifier is the portion of a program in which thatidentifier is accessible</p></blockquote><p>计算机领域里变量作用域指的是程序中变量的起作用(可以get)的一段范围</p><p>不同作用域里可存在同名变量，同一个作用域不可出现不同名变量</p><p>一个变量的作用域范围是有限的</p><p>许多语言都是静态作用域：</p><p>作用域仅仅依赖程序文本，根据变量在程序文本的位置决定变量的作用域，没有任何运行时决定的行为，eg:Cool</p><p>动态作用域：</p><p>Lisp: Lisp has changed to mostly static scoping</p><p>Scope depends on execution of the program</p><p>🌰：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">0</span> in<br>&#123;<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>let <span class="hljs-keyword">x</span>: Int &lt;- <span class="hljs-number">1</span> in<br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt; 2</span><br><span class="hljs-keyword">x</span><span class="hljs-comment">; =&gt;&gt;&gt;&gt;&gt;&gt; 1</span><br>&#125;<br><br>上面<span class="hljs-number">1</span>号<span class="hljs-keyword">x</span>和<span class="hljs-number">2</span>号<span class="hljs-keyword">x</span>是不同的作用域里<span class="hljs-keyword">x</span><br><br>动态作用域里的变量总是指向离它最近的变量<br><br>g(y) <span class="hljs-operator">=</span> let a &lt;- <span class="hljs-number">4</span> in f(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>f(<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> a <span class="hljs-operator">=</span>&gt;&gt;&gt;&gt;&gt; a <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Cool identifier bindings are introduced by:</p><ul><li>Class declarations (introduce class names)</li><li>Method declarations (introduce method names)</li><li>Let declarations (introduce object id's)</li><li>Formal declarations (introduce object id's)</li><li>Attribute declarations (introduce object id's)</li><li>Case declarations (introduce object id's)</li></ul><p>Cool 的标识符并不都是允许嵌套的</p><p>比如类定义不允许嵌套，类名使用前必须定义</p><h2 id="静态作用域实现符号表">静态作用域实现（符号表）</h2><p>Much of semantic analysis can be expressed as a recursive descent ofon an AST</p><ul><li>Before: Process an AST node n</li><li>Recurse: Process the children of n</li><li>After: Finish processing the AST node n</li></ul><p>When performing semantic analysis on a portion of the AST, we need toknow which identifiers are defined</p><p>当在AST的某部分上执行语义分析时，需要知道哪些标识符已经被定义了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> x: Int &lt;- <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">in</span> e</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">let</span> <span class="hljs-title">x</span>(<span class="hljs-params">sym</span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">init</span></span> = <span class="hljs-number">0.</span>(sym)     e(sym + x)<br><br>x <span class="hljs-keyword">is</span> defined <span class="hljs-keyword">in</span> subtree e<br></code></pre></td></tr></table></figure><p><code>Recall: let x: Int &lt;- 0 in e</code></p><p>Idea:</p><ul><li>Before processing e, add definition of x to current definitions,overriding any other definition of x</li><li>Recurse</li><li>After processing e, remove definition of x and restore olddefinition of x</li></ul><p>a symbol table is a data structure that tracks the current bindingsof identifiers</p><p>简单的实现可以使用stack</p><ul><li><code>Add_symbol(x)</code></li><li><code>Find_symbol(x) search stack, starting from top fro x, return x or NULL if none found</code></li><li><code>Remove() pop from ths stack</code></li><li><code>exit_scope() exit current scope</code></li><li><code>Check_scope(x) true if x defined in current scope</code></li></ul><p>在COOL里使用stack即可对let声明的变量进行处理</p><p>每次用let声明一个变量，即push入stack，而且也允许嵌套，每次退出当前let范围，即pop出变量；</p><p>但是对于函数确不好使用，比如函数参数，一次有多个参数，并且有重名的参数，所以得一次push多个变量，但是多个变量是在同一个层级里，而stack的解决方案默认一个变量一个层级</p><blockquote><p>class names can be used before being defined in COOL</p><p>solution：two passes to tranversal on AST</p><ul><li>Pass1: Gather all class names</li><li>Pass2: Do the checking</li></ul></blockquote><h2 id="类型">类型</h2><p>什么是类型，不同的语言对于类型定义不同，但通常意义上，一致认为被定义如下：</p><ul><li>一些值的集合（数据）</li><li>可操作这些值的一些操作（算法/函数/方法）</li></ul><p>必须确保在转化为机器语言之前做好类型检查哦，因为机器语言执行指令不会做任何检查。语言类型系统知名里在哪些类型上的哪些操作是合法的。语言的类型检查目的就是确保在正确的类型上执行正确的操作。</p><p>类型检查时期：</p><ul><li>编译时期执行类型检查：C, COOL, Java</li><li>运行时类型检查：程序执行的时候执行类型检查, Python, Lisp, Perl</li><li>无类型检查：machine code</li></ul><p>静态类型检查 vs 动态类型检查</p><ul><li>静态检查可以在编译时期捕获错误</li><li>避免运行时错误</li></ul><p>动态检查：</p><ul><li>静态类型检查是有局限性的，有些语句在静态类型不好检查出来，比如继承的时候，子类调用父类的方法</li></ul><p>现代编程语言很多结合了两者，如：</p><p>C，java可以使用unsafe逃脱静态检查</p><p>People retrofit static typing to dynamically typed languages fordebugging or optimization</p><p>类型检查：验证类型的合法性</p><p>类型推断：自动推断和填充缺失的类型信息</p><p>之前已经见过一些formal notions，比如：</p><ul><li>Regular expressions</li><li>Context-free grammars</li></ul><p>类型检查也有一套标准的逻辑推导规则：</p><p>推导规则具有如下形式：</p><p><em>If Hypothesis is true, then Conclusion is true</em></p><p>类型检查就是通过这样的推理：</p><p><em>If E1 and E2 have certain types, then E3 has a certaintype</em></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">^ =&gt; <span class="hljs-built_in">and</span><br>=&gt; <span class="hljs-built_in">if</span>-then<br><span class="hljs-symbol">x:</span> <span class="hljs-built_in">T</span> =&gt; x has <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>if e1 has type int and e2 type int, then e1 + e2 has type int=======&gt;</p><p>e1 has type ^ e2 has type int =&gt; e1 + e2 has type int=======&gt;</p><p>(E1: int ^ e2 : int) =&gt; e1 + e2: int</p></blockquote><p>the statement <code>(E1: int ^ e2 : int) =&gt; e1 + e2: int</code> isa special case of<code>hypothesis1 ^ ... ^ hypothesisn =&gt; Conclusion</code></p><p>一般情况下，上面的推导规则写出如下符号形式： <spanclass="math display">\[\frac{\vdash hypothesis1 \vdash hypothesis2 ... \vdashhypothesisn}{\vdash Conslusion}\]</span> <span class="math inline">\(\vdash\)</span> means ''it isprovable that ..."</p><p>看几个简单的推导规则： <span class="math display">\[\frac{i \quad is \quad an \quad interger \quad literal}{\vdash i: int}\]</span></p><p><span class="math display">\[\frac{e1: int \quad e2: int}{\vdash e1 + e2: int}\]</span></p><p>类型检查可以很好的基于AST来做：</p><p>如果已经证明了子表达式的类型，那么父节点的类型也就很好地得到，所以类型检查和推断是自底向上做的</p><h2 id="类型环境">类型环境</h2><p>在类型推导/检查中，有的时候一个变量的类型信息需要更多的信息才能获得该变量的类型，所以在我们的推导规则里需要加入更多的类型信息——类型环境，类型环境给予了自由变量更多的相关类型信息</p><p>类型环境：a fucntion from object identifiers to Types(即标识符到类型的映射)</p><p>自由变量：如果一个表达式里存在一个变量没有被定义，那么该变量就是自由变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">int</span> &lt;- <span class="hljs-number">0</span> <span class="hljs-keyword">in</span> x + y<br>这里<span class="hljs-keyword">let</span>限定下，x是未定义的，而y是<span class="hljs-built_in">int</span>类型且初始化为<span class="hljs-number">0</span>，在进行类型检查的时候，我们只有拥有了前面关于x的信息，才能知道x的类型<br></code></pre></td></tr></table></figure><p>let O be function from Object idenfiers to types, notion as follow:<span class="math display">\[O\vdash e: T\]</span> 读作：在环境O下，可以证明e是T类型</p><p>单点修改： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O[T/x]\vdash e_1:int  \quad}{O\vdash e_1 + e_2:Int }\end{aligned}\end{equation}\]</span></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">表示<br>O[T/<span class="hljs-keyword">x</span>](<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> int<br>O[T/<span class="hljs-keyword">x</span>](y) <span class="hljs-operator">=</span> y (<span class="hljs-keyword">x</span> !<span class="hljs-operator">=</span> y)<br></code></pre></td></tr></table></figure><p>实际上类型环境O可以由之前的Symbol table实现，因为</p><ul><li>类型环境给予当前作用域内部标识符类型（和作用域类型，只不过作用域是记录标识符）</li><li>类型环境也是自上向下不断扩增和单点修改</li><li>但是类型检查和推断是自底向上的</li></ul><h2 id="subtypings">Subtypings</h2><p>subtypings 主要用于继承类型1判断 <span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quad}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span> 在类上定义关系：&lt;=</p><ul><li>X &lt;= Y</li><li>X &lt;= Y if X inherits from Y</li><li>X &lt;= Z if X &lt;= Y and Y &lt;= Z</li></ul><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO[T_0/x]\vdash e_1:T_1  \quadT_0 &lt;= T}{O\vdash let \quad x: T_0 = e_0 \quad in \quad e_1: T_1 }\end{aligned}\end{equation}\]</span></p><p>属性初始化： <span class="math display">\[\begin{equation}\begin{aligned}\frac{O_c(x) = T_0  \quadO_C\vdash e_1:T_1  \quadT_1 &lt;= T0}{O\vdash x: T_0 = e_1 }\end{aligned}\end{equation}\]</span></p><p>考虑 <code>if e0 then e1 else e2 fi</code></p><p>表达式的结果要么e1要么e2，对应的类型要么是e1的类型要么是e2的类型</p><p>那么整个if-else表达式返回什么类型？</p><p>最好的方法是返回e1和e2的最小上界类型（least upper type）</p><p>least upper bound: lub(X, Y)，表示X和Y的最小上界类型，</p><p>if X &lt;= Z ^ Y &lt;= Z: Z is an upper bound</p><p>If X &lt;= Z' ^ Y &lt;= Z', Z &lt;= Z': Z is an upper bound</p><p>COOL里，两个类型的最小上界是它们继承树里最近公共祖先</p><p><span class="math display">\[\begin{equation}\begin{aligned}\frac{O\vdash e_0:Bool  \quadO\vdash e_1:T_1  \quadO\vdash e_1:T_2  \quad}{O\vdash if \quad e_0 \quad then \quad e_1 \quad else \quad e_2 \quadfi \quad fi: lub(T_1, T_2) }\end{aligned}\end{equation}\]</span></p><h2 id="typing-methods">Typing Methods</h2><p><span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quad}{O\vdash e_0.f(e_1, ... e_n): ? }\end{aligned}\end{equation}\]</span></p><p>不知道任何关于f的信息，如何知道f的返回值类型？</p><p>In cool, method and object identifiers live in different namespaces</p><ul><li>A method foo and an object foo can coexisted in the same scope</li></ul><p>In the type rules, this is reflected by a seperate mapping M formethod signatures <span class="math display">\[M(C, f) = (T_1, ... T_n, T_{n+1}) means \quad in \quad Class \quad C\quad there \quad is \quad \\ a \quad method \\ f: \quadf(x_1: T_1, ... x_n: T_n): T_{n+1}\]</span></p><p>dispatch <span class="math display">\[dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span></p><p>静态dispatch <span class="math display">\[static dispatch:\begin{equation}\begin{aligned}\frac{O\vdash e_0:T_0  \quadO\vdash e_1:T_1  \quad... \quadO\vdash e_n:T_n  \quadT_0 &lt;= T \quadT_i &lt;= T_{i&#39;} 1 &lt;= i &lt;= n \quadM(T_0, f) = (T_{1&#39;}, ... T_{n&#39;}, T_{n+1})}{O\vdash e_0@T.f(e_1, ... e_n): T_{n+1} }\end{aligned}\end{equation}\]</span> 最终结合方法环境，变量环境和类， <span class="math display">\[\begin{equation}\begin{aligned}\frac{O, M, C\vdash e_1:int  \quadO, M, C\vdash e_2:int  \quad}{O, M, C\vdash e1 + e2: int }\end{aligned}\end{equation}\]</span> 上面的规则仅适用于COOL</p><blockquote><p>General themes:</p><ul><li>Type rules are defined on the structure of expressions</li><li>Types of varaibles are modeled by an environment</li></ul></blockquote><h2 id="static-type-vs-dynamic-type">Static Type vs Dynamic Type</h2><p>静态类型检查：</p><p>可以在编译时期发现一些常见的错误，但是也有一些不是错误的代码被识别出来，报告错误，这个时候需要动态类型检查，但是实际上为了让有些不是错误的代码能够通过静态类型检查，需要一些特殊的方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">interits</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>x: <span class="hljs-type">A </span>&lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>; <span class="hljs-comment">// 静态检查可以通过，左右类型一致</span><br>...<br>x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">V</span>; <span class="hljs-comment">// 静态检查通不过，左右类型不一致</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>理想情况下，对于所有的表达式：dynamic_type(E) &lt;=static_type(E)</p><p>对于任意表达式E，dynamic_type(E) &lt;=static_type(E)，表示表达式E的静态类型检查得到的类型是对应表达式动态检查得到得类型的父类</p><p>All operations that can be used on an object if type C can also beused on an object of type C' &lt;= C</p><ul><li><p>Such as fetching the value of attribute</p></li><li><p>Or invoking a method on the object</p></li><li><p>Subclass only add attributes or methods</p></li><li><p>```</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br><br><br>## Self Type<br><br>考虑如下代码：<br><br>```java<br><span class="hljs-keyword">class</span> Count &#123;<br>    i : int &lt;- <span class="hljs-number">0</span>;<br>    inc () : Count &#123;<br>        &#123;<br>            i &lt;- i + <span class="hljs-number">1</span>;<br>            self;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>类Count包含一个计数器。</p></li><li><p>inc方法适用于任何子类。</p></li><li><p>考虑Count的子类Stock</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> inherits Count &#123; <br>name : String; -- name of item<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    Stock a &lt;- (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stock</span>).inc();<br>    ... a.name ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述用法在已有的类型系统会报错，因为inc返回的类型是Count，但但是赋值的对象是Stock对象</p><ul><li><p>(new Stock).inc()具有动态类型Stock；</p></li><li><p>因此如下语句是合法的;</p><p>Stock a &lt;- (new Stock).inc()；</p></li><li><p>但这不是很好的类型系统，因为(newStock).inc()的静态类型为Count；</p></li><li><p>类型检查器“丢失”类型信息</p><ul><li>这使得继承inc毫无用处 ；</li><li>因此，我们必须为每个子类重新定义inc，并使用专门的返回类型 。</li></ul></li></ul><p>解决上述问题需要引入SELF_TYPE</p><p>我们将使用self type扩展类型系统：</p><ul><li>inc返回self；</li><li>因此，返回值与“self”具有相同的类型；</li><li>可以是Count或Count的任何子类型！</li></ul><p>引入关键字SELF_TYPE以用于此类函数的返回值，SELF_TYPE允许在继承inc时更改inc的返回类型</p><p>修改inc的声明：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">inc(): <span class="hljs-type">SELF_TYPE</span> <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>类型检查系统现在可以证明：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-built_in">Count</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Count</span><br><span class="hljs-built_in">O</span><span class="hljs-operator">,</span> <span class="hljs-variable">M</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">|-</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">new</span> <span class="hljs-variable">Stock</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">inc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <span class="hljs-variable">Stock</span><br></code></pre></td></tr></table></figure><p>注意SELF_TYPE不是动态类型</p><ul><li>它也不是类名；</li><li>它是静态类型；</li><li>帮助类型检查器更好地跟踪类型；</li><li>使类型检查器接受更正确的程序</li></ul><p>简而言之，拥有SELF_TYPE可以提高类型系统的表达能力。</p><p>What can be the dynamic type of the object returned by inc?（inc将返回什么样的动态类型）</p><ul><li>Answer: whatever could be the Count or any subclass of Count of'self'</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">C</span> <span class="hljs-symbol">inherits</span> <span class="hljs-symbol">Count</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>In genreral, if SELF_TYPE appears textually in the class C as thedeclared type of E then</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dynamic_type</span><span class="hljs-params">(E)</span></span> &lt;= C<br></code></pre></td></tr></table></figure><blockquote><p>Note: The meaning of SELF_TYPE depends on where it appears , <spanclass="math inline">\(SELF\_TYPE_c\)</span> refers to an occurence ofSELF_TYPE in the body of C</p></blockquote><p><span class="math display">\[SELF\_TYPE_c &lt;= C\]</span></p><p>In type checking it is always safe to replace <spanclass="math inline">\(SELF\_TYPE_c\)</span> by C <spanclass="math display">\[SELF\_TYPE_c &lt;= SELF\_TYPE_c\]</span> in cool, we never compare SELF_TYPEs coming from differentclasses <span class="math display">\[SELF\_TYPE_c &lt;= T \quad if \quad C &lt;= T\]</span></p><ul><li><span class="math inline">\(SELF\_TYPE_c\)</span> can be any subtypeof c</li><li>This includes C itself</li><li>Thus this is the moe flexible rule we can allow</li></ul><p>let T and T' be any types but SELF_TYPE</p><ol type="1"><li><span class="math inline">\(lub(SELF\_TYPE_c, SELF\_TYPE_c) =SELF\_TYPE_c\)</span></li><li><span class="math inline">\(lub(SELF\_TYPE_c, T) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, SELF\_TYPE_c) = lub(C,T)\)</span></li><li><span class="math inline">\(lub(T, T&#39;) defined asbefore\)</span></li></ol><p><strong>哪里使用SELF_TYPE</strong></p><p><strong>self type checking</strong></p><h2 id="错误恢复">错误恢复</h2><p>与解析一样，从类型错误中恢复也很重要</p><p>目标：</p><ul><li>What type is assigned to an expresson with no legitimate type ?</li><li>This type will influence the typing of the enclosing expression</li></ul><p><strong>方法1：</strong></p><p>assign type Object to ill-typed expressions</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">let y: Int &lt;- x + 2 in y + 2<br><span class="hljs-keyword">error: </span>x is undefind: =&gt; x is Object<br><span class="hljs-keyword">error: </span>+ applied to Object =&gt; x + 2 is Object <br><span class="hljs-keyword">error: </span>bad assimend =&gt; ... (Int and Object is incompatible)<br></code></pre></td></tr></table></figure><p><strong>方法2:</strong></p><p>introduce <code>No_type</code> for use with ill-typed expressions</p><ul><li>DefineNo_type &lt;= C for all types C</li><li>Every operation os defined for No_type<ul><li>With a. No_type result</li></ul></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> y: Int &lt;- x + <span class="hljs-number">2</span> <span class="hljs-keyword">in</span> y + <span class="hljs-number">2</span><br>x <span class="hljs-keyword">is</span> No_type =&gt; x + <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> No_type =&gt; <span class="hljs-literal">no</span> error becuse No_type <span class="hljs-keyword">is</span> subtype <span class="hljs-keyword">of</span> any type<br></code></pre></td></tr></table></figure><p>总结：</p><p>实际编译器也会使用类似No_type的东西</p><p>然而，引入No_type会带来跟多复杂性：类的继承结构将不再是树状，因为每个类都有一个子类</p><blockquote><p>cool里使用了第一种方案</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 7 Cool Gode Generation</title>
    <link href="/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/"/>
    <url>/emocoder/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="代码生成简介">代码生成简介</h2><p>将ast转换为汇编代码，具体这里是mips汇编指令，cool里使用了累加寄存器<code>$a0</code></p><p>堆栈在内存中，，堆栈由高地址像低地址扩增</p><p>堆栈指针：<code>$sp</code> or <code>$29</code></p><p>具体的mips指令可以参考：misp文档</p><p>定义简单函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = if x = <span class="hljs-number">1</span> then <span class="hljs-number">0</span> else <br> <span class="hljs-attribute">if</span> x = <span class="hljs-number">2</span> then <span class="hljs-number">1</span> else<br> <span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>对于每一个表达式e，可以生成如下MISP代码：</p><ul><li>Computes the value of e in<code>$a0</code>（计算表达式e的值，并存储在<code>$a0</code>寄存器中）</li><li>Preservers <code>$sp</code> and the contents of stack(维护<code>$sp</code> 指针)</li></ul><p>这样我们可以定义<code>cgen(e)</code>表示为e的代码生成，并在最后将e的值存于<code>$a0</code> 中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(i)</span></span> = <span class="hljs-selector-tag">li</span> <span class="hljs-variable">$a0</span> i<br></code></pre></td></tr></table></figure><blockquote><p>代码生成是在编译阶段</p><p>汇编代码的执行是在运行时</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其实也就是输出对应的汇编代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">cgen(e1 + e2) = <br>cgen(e1)<br>cout &lt;&lt; <span class="hljs-string">&#x27;sw <span class="hljs-subst">$a0</span> 0(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$sp</span> <span class="hljs-subst">$sp</span> -4;&#x27;</span><br>cgen(e2)<br>cout &lt;&lt; <span class="hljs-string">&#x27;lw <span class="hljs-subst">$t1</span> 4(<span class="hljs-subst">$sp</span>)&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;add <span class="hljs-subst">$a0</span> <span class="hljs-subst">$t1</span> <span class="hljs-subst">$a0</span>&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&#x27;addiu <span class="hljs-subst">$a0</span> <span class="hljs-subst">$sp</span> 4&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>上面为+生成汇编代码的过程，可以理解为是一个模板，其中cgen(e1)和cgen(e2)就是插槽</li><li>代码生成是递归的，e1和e2也可继续向下生成代码</li><li>代码生成可以是沿着AST自顶向下递归的，至少对于表达式是可以的</li></ul><p>下面看一个函数的例子，函数有调用和函数定义两部分，这两者都依赖于AR(Activerecord or function frame)</p><p>简单的栈zhen满足如下规则即可：</p><ul><li>结果总是存储在<code>$a0</code>中，比如两者之和就可以存于<code>$a0</code> 中</li><li>栈zhen包含实际参数，也就是<code>f(x1, x2, ... xn)</code> 将会push<code>xn, ... x1</code> 入栈</li><li>在这个简单的例子只设计参数，不包含局部变量</li><li>另外，对于mips架构，需要在栈zhen内记录函数的返回地址</li><li>记录函数栈zhen起始地址：<code>fp</code></li><li>mips跳转指令：<code>jal label</code></li></ul><p>对于函数调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(f(e1, ... en)) = <br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">fp</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>cgen(en)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br>...<br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> -<span class="hljs-number">4</span><br><span class="hljs-keyword">jal </span>f_entry<br></code></pre></td></tr></table></figure><ul><li>函数调用的时候，保存了fp</li><li>逆序保存了实际参数</li><li>函数跳转的时候，返回地址<code>$ra</code>是自动保存的，这是底层实现的，我们不用管</li><li>一个使用了多少空间：4*n + 4 bytes,n是参数个数，+4是一个<code>fp</code> 指针</li></ul><p>对于函数定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(def f(x1, ... xn) = e) = <br>move <span class="hljs-variable">$fp</span> <span class="hljs-variable">$sp</span> <span class="hljs-regexp">//</span> 新的函数起始地址<br><span class="hljs-variable">$w</span> <span class="hljs-variable">$ra</span> <span class="hljs-number">0</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 保存返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> -<span class="hljs-number">4</span> <span class="hljs-regexp">//</span> 扩增<br>cgen(e) <span class="hljs-regexp">//</span> 递归生成e<br>lw <span class="hljs-variable">$ra</span> <span class="hljs-number">4</span>(<span class="hljs-variable">$sp</span>) <span class="hljs-regexp">//</span> 加载返回地址<br>addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> z <span class="hljs-regexp">//</span> 恢复栈空间<br>jal <span class="hljs-variable">$ra</span> <span class="hljs-regexp">//</span> 跳转回去<br></code></pre></td></tr></table></figure><ul><li>fp在高地址处</li><li>callee（被调用者）</li><li>z = 4 * n + 8，n是实际参数，8是<code>$ra</code> 和<code>$fp</code></li></ul><p>上面的实现方式可以实现简单函数：</p><ul><li>函数不存在局部变量，仅仅有参数</li><li>实际参数是caller push入栈的</li></ul><p>存在问题：计算的中间结果放在栈内，变量(参数)并不能基于$sp进行偏移量查询，因为不好确定使用了多少中间变量</p><p>解决方法：使用fp查询变量(参数)</p><ul><li>fp始终指向返回地址，这样不管栈怎么扩增，fp是不变的，我们可以始终基于fp查询变量（参数）</li></ul><p>xi表示第i个实际参数，那么关于xi的代码生成如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">cgen</span><span class="hljs-params">(xi)</span> = </span><br><span class="hljs-function"><span class="hljs-title">lw</span> $<span class="hljs-title">a0</span> <span class="hljs-title">z</span><span class="hljs-params">($fp)</span> <span class="hljs-params">(z = <span class="hljs-number">4</span> * i)</span></span><br></code></pre></td></tr></table></figure><p>🌰：<code>def f(x, y) = e</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[<br>old <span class="hljs-built_in">fp</span>,<br>y,<br>x,<br>return <span class="hljs-keyword">addr, </span>&lt;= <span class="hljs-built_in">fp</span><br>? &lt;= <span class="hljs-built_in">sp</span><br>]<br>X is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">4</span><br>Y is <span class="hljs-built_in">at</span> <span class="hljs-built_in">fp</span> + <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>现实中的寄存器：</p><ul><li>尽量将值保存在寄存器中，因为更快</li><li>中间值是被设计在AR中，有着一定的排列方式，可以在后续章节中看到如何使用临时变量，并把临时变量存在AR中，而非一味地push和pop</li></ul><p>来看一个完整的例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span>) = <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-number">0</span> <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-variable">x</span> + <span class="hljs-title">sumto</span>(<span class="hljs-variable">x</span> – <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><p>为以上函数生成代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#x in ra</span><br>sumto_entry:<br>move<span class="hljs-variable">$fp</span><span class="hljs-variable">$sp</span>#<span class="hljs-attribute">fp</span>=sp<br>sw<span class="hljs-variable">$ra</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=ra<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(sp+4)(a0=x)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(sp+4)(t1=a0=x)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>+4#sp+=4<br>beq<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span>true1#<span class="hljs-keyword">if</span> <span class="hljs-attribute">a0</span>=t1, goto true1<br>false1:#x <span class="hljs-keyword">in</span> sp - 4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>sw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=fp<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>lw<span class="hljs-variable">$a0</span>4(<span class="hljs-variable">$fp</span>)#<span class="hljs-attribute">a0</span>=*(4+fp)<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>li<span class="hljs-variable">$a0</span>1#<span class="hljs-attribute">a0</span>=1<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br>sub<span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1-a0(a0=x-1)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>sw<span class="hljs-variable">$a0</span>0(<span class="hljs-variable">$sp</span>)#*<span class="hljs-attribute">sp</span>=a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>-4#<span class="hljs-attribute">sp-</span>=4<br>jalsumto_entry#goto sumto_entry<br>lw<span class="hljs-variable">$t1</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">t1</span>=*(4+sp)<br><span class="hljs-built_in">add</span><span class="hljs-variable">$a0</span><span class="hljs-variable">$t1</span><span class="hljs-variable">$a0</span>#<span class="hljs-attribute">a0</span>=t1+a0<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>4#sp+=4<br>jalendif1<br>true1:<br>li<span class="hljs-variable">$a0</span>0#<span class="hljs-attribute">a0</span>=0<br>endif1:#恢复调用前的状态<br>lw<span class="hljs-variable">$ra</span>4(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">ra</span>=*(4+sp)<br>addiu<span class="hljs-variable">$sp</span><span class="hljs-variable">$sp</span>12#sp+=12<br>lw<span class="hljs-variable">$fp</span>0(<span class="hljs-variable">$sp</span>)#<span class="hljs-attribute">fp</span>=*sp<br>jr<span class="hljs-variable">$ra</span>#goto<span class="hljs-built_in"> address </span><span class="hljs-keyword">in</span> ra<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>AR必须和代码生成器一同设计</li><li>代码生成可以通过遍历AST递归做到</li><li>推荐使用堆栈机生成代码，比较简单，大多数语言都是如此</li></ul><p>运行时组织：主要是为了组织运行时代码(狭义指运行时代码生成)</p><p>代码生成的目标：准确和快</p><p>代码生成的两个假设：</p><ul><li>代码执行是串行的，即从上至下一个语句接着一个语句按照既定的顺序执行</li><li>当程序被调用结束后，控制权应该交给执行本次调用的后一条语句</li></ul><p>当然有些语言违背了这两条假设，比如说并行</p><p>变量x的生命周期：变量x起作用的一段范围（生命周期是一个动态（运行时）概念，而作用域是一个静态概念）</p><h2 id="rutime-organization">Rutime Organization</h2><p>主要是组织代码生成的设计及相关计算模型，涉及以下内容：</p><ul><li>运行时的资源管理</li><li>存储管理</li><li>运行时的计算模型</li></ul><p>前面已经讲述三部分内容：</p><ul><li>Lexical analysis</li><li>parsing</li><li>semantic analysis</li></ul><p><strong>这三部分都是加强语言定义的方式</strong></p><p>程序的执行方式：</p><ol type="1"><li>OS为该程序分配空间</li><li>代码北加州到这部分空间</li><li>OS跳转到程序的入口</li></ol><p>程序的内存布局： <imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042401.jpg?raw=true"alt="img" /></p><p>如上，按照传统方式，程序的内存布局如下，上面图片是简化的，实际情况下内存不一定是连续的：</p><ul><li><p>顶部的低地址是代码段</p></li><li><p>底部的高地址</p></li></ul><p>代码生成的目标：</p><ul><li>生成正确的代码</li><li>生成的代码快</li></ul><p>传统意义上里生成的代码基于以下两个假设：</p><ul><li>执行是顺序的，控制流从程序中的一个位置按定义好的顺序移动到另一个位置。</li><li>调用过程时，控制流总是返回到调用后的位置。</li></ul><blockquote><p>当然有的程序语言违背了这两个假设，比如可并行运行的语言</p></blockquote><p><strong>程序的激活</strong></p><p>激活：对子程序P的调用，称之为对P的激活，P的激活的生命周期为执行P的所有步骤（变量x的生命周期是定义x的执行部分）</p><blockquote><p>生命周期是一个动态的运行时概念，而作用域是一个静态概念</p></blockquote><p>对于非并行程序，激活是线性的</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Class</span> <span class="hljs-variable">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">g</span>() : <span class="hljs-variable">Int</span> &#123; <span class="hljs-number">1</span> &#125;;</span><br><span class="hljs-function">    <span class="hljs-title">f</span>(<span class="hljs-variable">x</span>:<span class="hljs-variable">Int</span>): <span class="hljs-variable">Int</span> &#123; <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> = <span class="hljs-number">0</span> <span class="hljs-variable">then</span> <span class="hljs-title">g</span>() <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-title">f</span>(<span class="hljs-variable">x</span> - <span class="hljs-number">1</span>) <span class="hljs-variable">fi</span>&#125;; </span><br><span class="hljs-function">    <span class="hljs-title">main</span>(): <span class="hljs-variable">Int</span> &#123;&#123;<span class="hljs-title">f</span>(<span class="hljs-number">3</span>); &#125;&#125;;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>以上代码生成的激活记录如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">main -&gt; f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> f<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> g<br></code></pre></td></tr></table></figure><p>基于此，因此堆栈可以跟踪整个激活记录的过程</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>激活记录（栈zhen）</strong></p><p>管理一个过程激活所需的信息称为激活记录（AR）或栈帧（frame）</p><p>如果过程F调用G，则G的激活记录包含F和G的混合信息。</p><ul><li>F被“暂停”，直到G完成，此时F恢复。</li><li>G的AR包含如下内容所需的信息<ul><li>完成G的执行</li><li>恢复执行F</li><li>G返回值的空间</li><li>实际参数</li><li>指向上一个激活记录的指针<ul><li>控制链接； 指向G的caller的AR</li></ul></li><li>调用G之前的机器状态<ul><li>寄存器和程序计数器的内容</li><li>局部变量</li></ul></li><li>其他临时值</li></ul></li><li>将返回值放在第一个栈帧中的优点是，调用方可以在与自己的帧相距固定偏移量的位置找到它；</li><li>这个组织没有什么特殊的地方<ul><li>可以重新排列栈帧元素的顺序；</li><li>可以不同地划分caller/call的职责；</li><li>如果组织能够提高执行速度或简化代码生成，那么它会更好。</li></ul></li><li>真正的编译器将尽可能多的栈帧保存在寄存器中<ul><li>特别是方法的结果和参数。</li></ul></li><li>编译器必须在编译时确定激活记录的布局，并生成可正确访问激活记录中位置的代码。</li><li>因此，AR布局和代码生成器必须一起设计！</li></ul><h2 id="全局变量和堆">全局变量和堆</h2><ul><li>所有对全局变量的引用都指向同一个对象<ul><li>所以无法在激活记录中存储全局变量，因为当前AR结束后，全局变量依旧存在</li></ul></li><li>因此需要为全局变量分配一次固定地址<ul><li>具有固定地址的变量是“静态分配的”。</li></ul></li><li>根据语言，可能还有其他静态分配的值</li></ul><p>动态分配的值不能存放在AR中，Bar值必须在foo的AR释放后依然存在，因为foo的调用者可能使用Bar。：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; new Bar &#125;</span><br></code></pre></td></tr></table></figure><ul><li>具有动态分配数据的语言使用堆来存储动态数据。</li><li>代码区域包含目标代码<ul><li>对于许多语言，目标代码是固定大小和只读的。</li></ul></li><li>静态区域包含具有固定地址的数据（非代码）（例如，全局数据）<ul><li>固定大小，可能是可读或可写的。</li></ul></li><li>堆栈包含每个当前活动过程的AR<ul><li><strong>每个AR通常固定大小，并且包含局部变量。</strong></li></ul></li><li>堆包含所有其他数据<ul><li>在C中，堆由malloc和free管理。</li></ul></li><li>堆和堆栈都会增长</li><li>必须注意不要互相影响</li><li>解决方案：<ul><li>将堆和堆栈顶在内存的两端，然后让它们彼此靠近：</li></ul></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="对齐">对齐</h2><p>大多数现代机器：32/64 bit</p><p>1 byte = 8 bits</p><p>1 word = 4 or 8 bytes</p><p>一般机器要么是按字节要么按字寻址</p><p>按字对齐：</p><p>example：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta">[h e l l o ? ? ?][<span class="hljs-keyword">next</span> data]<br>add <span class="hljs-number">3</span> padding characters to the string<br><br>[<span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">byte</span> ?    ?   ?]<br><span class="hljs-keyword">this</span>, word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br>      <span class="hljs-keyword">this</span>, not word aligned <span class="hljs-keyword">if</span> <span class="hljs-keyword">next</span> data begin <span class="hljs-keyword">from</span> here,<br></code></pre></td></tr></table></figure><h2 id="计算模型堆栈机寄存器">计算模型：堆栈机&amp;寄存器&amp;</h2><p>堆栈机唯一的存储就是堆栈</p><ul><li>指令 $ r = F(a_1, a_2, ..., a_n) $<ul><li>从堆栈中弹出n个操作数</li><li>使用操作数计算操作F</li><li>将结果r压入堆栈</li></ul></li><li>考虑如下两条指令<ul><li>push i: 将整数i堆入堆栈</li><li>add: 相加两个整数</li></ul></li></ul><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs none">push 1<br>push 2<br>push 3<br>add<br></code></pre></td></tr></table></figure><figure><imgsrc="https://upload-images.jianshu.io/upload_images/18574033-6cbe4fae0a21d2f2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1090/format/webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>累加器机，英文为“AccumulatorMachine”，是一种寄存器，用来存储计算产生的中间结果。累加器机模型是一种古老的计算模型，仅能够支持单一值的累加寄存器单元，因此，基于累加器机模型设计的指令都只支持一个操作数</p><p>寄存器机，英文为 RegisterMachine，也译为暂存器机，这种计算模型的机器，使用特定的 CPU寄存器组，来作为指令执行过程中数据存储和交换的容器。</p><p>在寄存器中，由于每一条参与到数据交换和处理的指令，都需要显示地标记操作数所在的寄存器，相较于堆栈机和累加器机，指令更长，但也更加灵活。</p><p>堆栈机使用栈结构作为数据存储与交换的容器，由于其“先进后出”的特性，无法直接操作位于栈底的数据，因此，在特殊情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失一定的执行效率。但另一方面，堆栈机模型实现简单，指令代码长度适中。</p><p>累加器机由于只有一个累加器寄存器可用于存储数据，因此在指令的执行过程中，可能会频繁请求机器的线形内存，从而导致一定的性能损耗。但另一方面，该模型最多只能有一个操作数，因此对应的指令代码较为精简。</p><p>寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，因此，指令代码的长度较长。寄存器机拥有更多的数据暂存容器，一方面，灵活的数据操作导致寄存器的分配和使用规则变得复杂，另一方面，在使用得当的情况下，同样的计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。</p><p>纯堆栈机和纯寄存器机之间有一个中间点：n寄存器堆栈机</p><p>从概念上讲，将纯堆栈机堆栈的前n个位置保留在寄存器中。当n=1的时候，该寄存器演变成了累加器机</p><ul><li><p>在纯堆栈机中</p><ul><li>一次add执行三次内存操作；</li><li>两次读取，一次写入堆栈。</li></ul></li><li><p>在1寄存器堆栈计算机中，add运算符只要使用如下方式即可：</p><ul><li>acc &lt;- acc + top_of_stack，acc即累加器寄存器</li></ul></li><li><p>考虑一个表达式op(e1,…,en)</p><ul><li>注意e1,…,en是子表达式。</li><li>对于每个ei(0&lt;i&lt;n)<ul><li>计算ei；</li><li>将结果压入堆栈。</li></ul></li><li>从堆栈中弹出n−1个值，计算op</li><li>将结果存储在累加器中。</li></ul></li><li><p>对表达式e求值后，累加器将保留e的值，并且堆栈剩余部分不变。</p></li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week6%20P1/2021042413.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/"/>
    <url>/emocoder/2023/06/03/%E5%9B%9B%E5%B1%82%EF%BC%9A%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E4%B8%BA%E4%B8%8A%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>四层：每一层都为上层提供了服务</p><p>Application：双向可靠的字节流(using application-specificsemantics)</p><p>Transport: 保证了数据正确，有序，以及拥塞控制</p><p>Network: 不能保证数据的有序正确，不损坏，from ,to</p><p>Link: 节点之间的数据传播</p><p>IP：瘦身层，因为底层可以有很多（http, smtp, ssh,ftp），上层也是，比如网络层（tcp, rtp, udp），应用层（ethernet, wifi,dsl, sg）,但是网络层只有一种协议: IP</p><p>OSI7层标准</p><p>网络层（最重要）：主要是Internet protocol（IP）</p><p><strong>路由器：</strong></p><p>每个端口都有自己的mac地址</p><p>具有存储局部路由的功能</p><p>具有转发数据包的功能</p><p><strong>交换机：</strong></p><p>没有mac地址</p><p>只能存储全局的mac映射表，随着网络的接入，会越来越大</p><p>可以根据mac映射表，转发给指定主机</p><p><strong>集线器：</strong></p><p>为了解决只有电脑的简单网络时代的互联网之间的连接问题</p><p>没有mac地址，</p><p>没有存储任何表</p><p>仅仅通过广播寻找目的地址</p><p><ahref="https://blog.csdn.net/qq_44807642/article/details/103054914">(306条消息)【动图讲解】计算机网络之回退N步与选择重传_选择重传和回退n步_岳麓山下你和我的博客-CSDN博客</a></p><p>​</p><ul><li>Introduction<ul><li>引言</li><li>网络中的设计模式</li><li>字节顺序</li><li>IPv4</li><li>最长前缀匹配</li><li>地址解析协议</li><li>总结</li></ul></li><li>传输层协议<ul><li>TCP</li><li>UDP</li><li>端到端原则</li><li>错误检测</li><li>网络中的确定性有限状态机</li><li>停止等待协议</li><li>滑动窗口</li><li>可靠策略一(重传)</li><li>可靠策略二(TCPh header)</li><li>可靠策略一(连接与拆卸)</li><li>总结</li></ul></li><li>分组交换</li><li>拥塞控制</li><li>应用层协议</li><li>路由</li><li>物理层协议</li><li>网网络安全与加密</li><li>前沿话题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 10 Register Allocation</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>中间代码使用了无限制的临时变量</p><ul><li>简化了代码生成和优化</li><li>复杂了向汇编转换的过程</li></ul><p>实际情况寄存器是有限的，不能无限制的使用，所以在向汇编转换的时候使用有限的寄存器。</p><blockquote><p>Register allocation is as old as compilers</p><ul><li>Register allocation was used in the original FORTRAN compiler in the‘50s</li><li>Very crude algorithms</li></ul><p>A breakthrough came in 1980 – Register allocation scheme based ongraph coloring – Relatively simple, global and works well inpractice</p></blockquote><p><strong>思路：</strong></p><ul><li>将多个临时变量分配给同一个寄存器</li><li>同时不改变原来的语义</li></ul><p>考虑如下程序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := c + d<br>e := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br>f : = e - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果仅仅使用三个寄存器的话，这里假设a和e在使用完之后立马dead：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r2</span> + <span class="hljs-built_in">r3</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> + <span class="hljs-built_in">r4</span><br><span class="hljs-built_in">r1</span> := <span class="hljs-built_in">r1</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给众多的临时变量分配有限的寄存器并且相互不冲突这是重中之重：</p><ul><li>如果在程序在某个运行点临时变量t1和t2不同时存活，那么t1和t2可以共享相同的寄存器</li><li>否则，t1和t2不能同时分配给一个寄存器</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152040397.png"alt="image-20230520152040397" /><figcaption aria-hidden="true">image-20230520152040397</figcaption></figure><p>基于之间的活跃变量分析构建无向图(寄存器干扰图, RIG)：</p><ul><li>节点是临时变量</li><li>边表示这两个节点对应的变量同时在某个时刻存活</li><li>如果节点之间没有边，说明节点可以共享一个寄存器</li></ul><p>如下：</p><ul><li>例如，b和c不能在同一寄存器中</li><li>例如，b和d可以在同一寄存器中</li></ul><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050602.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>RIG构建完成后，寄存器分配算法与体系架构无关，不依赖任何机器属性</p></blockquote><h2 id="图染色">图染色</h2><p>图着色是对节点的颜色分配，使得通过边连接的节点具有不同的颜色</p><p>如果一个图可以用k种颜色按照上述规则着色，则该图形为k−colorable（这里的颜色就是寄存器，k为寄存器数量）</p><p>进一步的，如果RIG是k−colorable，则存在不超过k个寄存器的寄存器分配。</p><p>图染色算法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The following works well <span class="hljs-keyword">in</span> practice:<br>  – Pick <span class="hljs-keyword">a</span> node t <span class="hljs-keyword">with</span> fewer than k neighbors<br>  – Put t <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">stack</span> <span class="hljs-title">and</span> <span class="hljs-title">remove</span> <span class="hljs-title">it</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">RIG</span><br>  – Repeat <span class="hljs-keyword">until</span> <span class="hljs-keyword">the</span> graph has <span class="hljs-literal">one</span> node<br>Assign colors <span class="hljs-built_in">to</span> nodes <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">stack</span><br>  – Start <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> node added<br>  – At <span class="hljs-keyword">each</span> step pick <span class="hljs-keyword">a</span> color different <span class="hljs-built_in">from</span> those assigned<br>  <span class="hljs-built_in">to</span> already colored neighbors<br></code></pre></td></tr></table></figure><p>下面这张图里第四个才符合题意</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050704.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="变量溢出">变量溢出</h2><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152930506.png"alt="image-20230520152930506" /><figcaption aria-hidden="true">image-20230520152930506</figcaption></figure><p>在这种情况下，我们无法将所有值都保存在寄存器中，这个时候会选择一些变量放入内存；其他变量继续图染色，这些溢出的变量将会有以下操作：</p><p><strong>选择哪些变量溢出呢？</strong></p><p>可能的启发式方法：</p><ul><li>spill冲突最多的临时变量（这个时候边比较多）</li><li>spill定义和用途很少的临时变量（因为很少用，放到内存里，也无伤大雅）</li><li>在内部循环中避免spill（因为循环里一直会复用缓存或者寄存器，如果spill了变量到内存，可能会很大程度降低运行速度，见下面缓存部分）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Before</span> <span class="hljs-keyword">each</span> operation that reads f, <span class="hljs-keyword">insert</span><br>f := <span class="hljs-keyword">load</span> fa<br><span class="hljs-keyword">After</span> <span class="hljs-keyword">each</span> operation that writes f, <span class="hljs-keyword">insert</span><br>store f, fa<br></code></pre></td></tr></table></figure><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520152957854.png"alt="image-20230520152957854" /><figcaption aria-hidden="true">image-20230520152957854</figcaption></figure><p>重新计算活跃变量：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153015201.png"alt="image-20230520153015201" /><figcaption aria-hidden="true">image-20230520153015201</figcaption></figure><blockquote><p>New liveness information is almost as before</p><p>​ – Note f has been split into three temporaries</p><p>fi is live only</p><p>​ – Between a fi := load fa and the next instruction</p><p>​ – Between a store fi, fa and the preceding instr.</p><p>Spilling reduces the live range of f</p><p>​ – And thus reduces its interferences</p><p>​ – Which results in fewer RIG neighbors</p></blockquote><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520153209988.png"alt="image-20230520153209988" /><figcaption aria-hidden="true">image-20230520153209988</figcaption></figure><h2 id="管理缓存">管理缓存</h2><p>缓存的速度介于寄存器和内存中间，可作为缓冲存在，如果没有缓冲的话，寄存器和内存直接交互，由于访问内存的速度远远小于访问寄存器的速度，这样整个程序会是相对较慢的，所以缓存很重要；</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520151753508.png"alt="image-20230520151753508" /><figcaption aria-hidden="true">image-20230520151753508</figcaption></figure><p>通常情况下，寄存器和内存交互的值，会放在缓存里，每次寄存器访问数据先去缓存里查找，如果没有，才去内存里查找，如果缓存一直没有命中，那么缓存也就失去了它的价值。</p><ul><li>编译器非常擅长管理寄存器<ul><li>比程序员要好得多</li></ul></li><li>但是编译器不善于管理缓存<ul><li>这个问题仍然留给程序员</li><li>尚有一个未解决的问题，编译器可以做些什么来提高缓存性能</li></ul></li></ul><p>考虑如下程序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>上面的代码由于内部循环很大，而且每次i都会变化，如果缓存没有足够的大小，那么a[i]和b[i]就一直命中不了缓存；相反，下面的代码在10次以内，一定都是可以缓存的，速度至少比上面代码快10倍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span>(i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">1000000</span>; i++)<br><span class="hljs-attribute">for</span>(j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) <br><span class="hljs-attribute">a</span>[i] *= b[i]<br></code></pre></td></tr></table></figure><p>像这种交换for循环的优化，很少有编译器实现，因为难以发现什么样的循环可以优化，事实上，大部分情况下，还是需要程序员自己去优化这种case的。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 11 Automatic Memory Management</title>
    <link href="/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/"/>
    <url>/emocoder/2023/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%8D%81%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="引出">引出</h2><p>自动内存管理也称之为垃圾回收(garbage collection)</p><p>手动管理内存有很多出乎意料的bug：</p><ul><li>忘记释放没有被使用的内存</li><li>忘记去掉一些无用引用，或者是野指针</li><li>偶然的内存覆盖</li><li>...</li></ul><p>内存相关bug很难发现(比如内存溢出，就需要排查很长时间)</p><p>🌰：</p><p>某个对象没有被引用了，但是对应的指针还在；突然后面该对象被覆盖了，但是指针仍然引用这块内存，这个时候使用这个指针的读写还是按照原来的类型进行读写，就很容易出现错误(原类型是8bit大小，现在的类型是16bit大小这种情况)</p><p>如何自动管理内存呢？</p><p>思路：当一个对象被创建的时候就会同时分配空间；但是当没有足够的空间可用的时候，是否可以复用那些没有被使用(引用)的对象的空间呢？</p><p>我们如何得知一个对象"没有被再次使用呢"</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> x: A &lt;- new A <span class="hljs-keyword">in</span> &#123; x &lt;- y; ... &#125;<br></code></pre></td></tr></table></figure><p>上面的代码里newA生成的A对象后面被覆盖了，这个A对象就是没有被再次使用的对象(这里不考虑其他代码，仅考虑本行代码)，x和y共同引用一个对象。这个A对象被称作为不可达对象</p><p>不可达对象定义，当且仅当：</p><ul><li>存在寄存器指向了对象x，或者</li><li>存在某一个可达对象y指向这个x</li></ul><p>考虑如下代码：if分支始终为True</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>;<br>y &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>;<br>x &lt;- y;<br><span class="hljs-keyword">if</span> alwaysTrue() then x &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">A</span> <span class="hljs-keyword">else</span> x.foo() fi<br></code></pre></td></tr></table></figure><p>假设在<code>x &lt;- y</code> 之后，y是非活跃变量，这里：</p><ul><li>A是不可达的</li><li>B是可达的，通过x，但是B之后再也没有被使用过；</li></ul><p>所以，判断可达和不可达只是一种近似手段；</p><p>可以通过以寄存器为起点遍历引用链，寻找所有可达对象(为什么以寄存器为起点，因为只有保存在寄存器的变量才说明是参与计算的活跃的对象)，总的来说，有以下几种比较常见的垃圾回收算法：</p><ul><li>标记清除(mark and sweep)</li><li>复制转移(stop and copy)</li><li>引用计数(reference count)</li></ul><p>前两种都是内存耗尽的时候，才垃圾回收；引用计数不是等待内存耗尽的才开始进行，在没有指针指向该对象时尝试收集该对象</p><h2 id="mark-and-sweep标记清除">mark and sweep(标记清除)</h2><p>标记清除有两个步骤：</p><ul><li>the mark phase: 找到可达对象(rearchable objects)</li><li>the sweep phase: 收集可回收对象</li></ul><p>实现方式：</p><p>每个对象有一个额外的标记是否可回收的bit位</p><ul><li>该bit位初始化为0</li><li>在mark phase期间，对于所有的可达对象设置为1</li></ul><p><strong>mark phase:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> todo = &#123;<span class="hljs-keyword">all</span> roots&#125;<br><span class="hljs-keyword">while</span> todo != 空集 <span class="hljs-keyword">do</span><br>pick v 属于 todo<br>todo &lt;- todo - &#123;v&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">mark</span>(v) == <span class="hljs-number">0</span> then<br><span class="hljs-keyword">mark</span>(v) &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> v1, v2, ..., <span class="hljs-keyword">vn</span> <span class="hljs-keyword">be</span> the pointers contained in v<br>todo &lt;- todo 并集 &#123;v1, v2, ..., <span class="hljs-keyword">vn</span>&#125;<br>fi<br>od<br></code></pre></td></tr></table></figure><p><strong>sweep phase:</strong></p><p>清除阶段扫描堆空间里可以清除的对象(也就是比特标记仍为0的对象)，这些对象是不可达的，可以被视作"垃圾"。这些垃圾对象可以在清除阶段形成一段链表(可以避免堆内存碎片)</p><p>清除阶段过后，之前被设置为1的对象应该重置为0，方便下一次垃圾回收。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">siseof</span><span class="hljs-params">(p)</span></span> is the size of block starting at p，<span class="hljs-built_in">sizeof</span>(p)表示p对象所占据的大小，这里默认大部分情况下对象的内存布局是连续的<br><br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-attribute">bottom</span> of heap<br>while <span class="hljs-selector-tag">p</span> &lt; <span class="hljs-attribute">top</span> of heap fp<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">mark</span>(p) == <span class="hljs-number">1</span> then<br><span class="hljs-selector-tag">mark</span>(p) &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span><br>add block <span class="hljs-selector-tag">p</span>...(<span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p) - <span class="hljs-number">1</span>) to freelist<br>fi<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-built_in">sizeof</span>(p)<br>od<br><br>这一段代码的大概意思就是从堆的起点开始出发，直到堆的终点，如果发现p为<span class="hljs-number">1</span>，则重置为<span class="hljs-number">0</span>；否则，说明是垃圾对象，把<span class="hljs-selector-attr">[start, start + sizeof(p)]</span>的内存串到freelist链表里，在每一轮结束后，别忘了对p增加本次对象的偏移量<br></code></pre></td></tr></table></figure><p>🌰：这里假设只有一个寄存器，初始的时候寄存器指向A对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>标记阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br><br>清除阶段后:<br>root -&gt; A<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> F(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>以上普通标记-清除的缺点：</p><p>由于一旦使用该算法的时候，已经是内存不够用了，然而在<strong>标记阶段</strong>还要借用内存去维护todo这样一个数据结构，并且这个结构的大小是不受控制的，有可能有许多垃圾需要回收，这是和垃圾回收的目的相悖的</p><p><strong>改进：</strong></p><p>todo这样的数结构可否不开辟新的空间？</p><p>todo这个数据结构是为了寻找可达对象，那么可否直接遍历对象引用图，把可达对象的bit标志位设置为呢？</p><p>对图dfs遍历，但是引用是大部分情况下是单向的，如何在图里回溯(在遍历的同时反转链表，这样回溯的时候沿着反转指针即可)，这里实际操作的时候需要注意借用临时变量(寄存器)去存储当前遍历节点，以便下一个节点使用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cur.next</span> = tmp(反转) // 连接上一个节点<br><span class="hljs-attr">tmp</span> = cur<span class="hljs-comment">; // 现在tmp是当前节点，给下一个节点使用</span><br><span class="hljs-attr">cur</span> = cur.next<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>对象在被分配的时候一般按如下规则进行分配：</p><ul><li>挑选尽量大的空间块</li><li>按需分配</li><li>顺序且连续分配，比如有100个bit大小的自左向右的连续内存空间，现在要分配50bit给某个对象，那么分配的就是前50bit</li></ul></blockquote><p>标记—清除的优势：</p><ul><li>碎片化内存，更多的使用内存碎片，减少空间利用率</li><li>对象在垃圾回收的时候不需要移动，也就是对应的指针也不会变化(这在一些允许自己手动管理内存的语言很重要，如C，C++，不会引起歧义)</li></ul><h2 id="stop-and-copy">stop and copy</h2><p>内存被划分为两块：</p><ul><li>old space: 用于分配内存</li><li>new space: 为垃圾回收备用</li></ul><p>另外有一个heap pointer, 总是指向oldspace的下一个可用空间，所以，分配内存仅仅在增加heap pointer</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520103417917.png"alt="image-20230520103417917" /><figcaption aria-hidden="true">image-20230520103417917</figcaption></figure><p>stop and copy的特点：</p><ul><li>仅仅从old space copy可达对象到newspace(所以当垃圾很多的时候，这种算法效率很高)</li><li>垃圾被留在了old space</li><li>在copy之后，new space比垃圾回收之前的old space占用的空间更少</li><li>在copy结束之后，old space和new space交换</li><li>由于需要移动scan pointer和allocpointer，和标记-清除一样，需要知道对象的大小</li><li>由于对象被移动了，函数堆栈里的相关指针必须更新</li></ul><p>每次copy之后，需要更新被copy对象内部的指针，因为其指向后续也会发生copy才对，如何让其指针引用的对象指向最新的已经copy的对象？可以在每个对象增加一个关于转移指针的字，如果对象发生了copy，那么转移指针有值且指向最新的地址，</p><blockquote><p>总结：转移指针就是存在于旧对象里指向新拷贝对象的一个指针，作用是方便后续引用该对象的指针能够根据转移指针正确更新，另外就是标记旧的对象已经被拷贝了</p></blockquote><p>所以stop and copy的目标是寻找到所有的可达对象并copy至newspace，对于当前copy对象，还需要更新其内部的所有指针</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520111956200.png"alt="image-20230520111956200" /><figcaption aria-hidden="true">image-20230520111956200</figcaption></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">while</span> scan &lt;&gt; alloc <span class="hljs-keyword">do</span><br><span class="hljs-keyword">let</span> O be the <span class="hljs-type">object</span> at scan pointer<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> pointer p contained <span class="hljs-keyword">in</span> O <span class="hljs-keyword">do</span><br>find O<span class="hljs-comment">&#x27; that p points to</span><br><span class="hljs-keyword">if</span> O<span class="hljs-comment">&#x27; is without a forwarding pointer</span><br>copy O<span class="hljs-comment">&#x27; to new space (update alloc pointer)</span><br><span class="hljs-keyword">set</span> a word <span class="hljs-keyword">of</span> old O<span class="hljs-comment">&#x27; to point the new copy (这一步就是标记旧的对象已经被拷贝了)</span><br>change p <span class="hljs-keyword">to</span> point <span class="hljs-keyword">to</span> the <span class="hljs-built_in">new</span> copy <span class="hljs-keyword">of</span> O<span class="hljs-comment">&#x27;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">set</span> p <span class="hljs-keyword">in</span> O equal <span class="hljs-keyword">to</span> the forwarding pointer<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">for</span><br>increment scan pointer <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> <span class="hljs-type">object</span><br>od<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>相对比较快，尤其垃圾比较多的时候，因为只需要处理可达对象</li><li>分配内存是简单且快速的，因为只需要增加heap pointer</li></ul><p>缺点：</p><ul><li>一些语言，如C和C++不允许对象拷贝，以及指针转移，<strong>因为指针作为对象语义的一部分在程序中公开</strong></li></ul><p>针对C和C++不允许对象拷贝，以及指针转移，有一些Conservativecollection技术</p><h2 id="引用计数">引用计数</h2><p>在没有耗尽内存的时候就开始对对象的引用数（每个分配操作都会引起引用计数），进行计数，一旦计数为0，说明该对象需要被回收了。</p><p><code>rp(x)为x的引用计数</code></p><p>每个赋值<code>x &lt;- y</code> ，这里假设x,y对象分别指向o和p：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(p)</span></span> &lt;- <span class="hljs-built_in">rc</span>(p) + <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">rc</span><span class="hljs-params">(o)</span></span> &lt;- <span class="hljs-built_in">rc</span>(o) + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rc</span>(o) == <span class="hljs-number">0</span>) then free o<br>x &lt;- y<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>易于实现</li><li>增量收集垃圾，而不会在执行过程中出现大量的停顿，因为它在没有耗尽内存的时候就开始对对象的引用数，每次赋值语句都可能会引起垃圾回收，但是每次的垃圾都是增量变化的，并不会占据很多时间。</li></ul><p><strong>缺点：</strong></p><ul><li>无法处理循环引用</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">x -&gt; A <span class="hljs-operator">=</span>&gt; B <span class="hljs-operator">=</span>&gt;A<br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> null<br></code></pre></td></tr></table></figure><p>上面语句里，x是一个指针引用了A，而A又引用了B，当x不再指向A的时候，由于A和B的引用计数始终不为0，所以没有办法回收A和B</p><ul><li>在每次分配时处理引用计数有的时候比较慢，如果一个赋值一句牵连到了很多对象，那么引用计数就会计算这些对象，可以在编译的时候优化这些赋值语句，比如如果有一个对象的两次更新，可以优化成一次，这样就会计算一次引用计数了。</li></ul><h2 id="总结">总结</h2><p>自动内存管理可防止严重的存储错误</p><p>But，也减少了程序员对内存的控制：</p><ul><li>例如，内存中的数据布局</li><li>例如，何时重新分配内存</li></ul><p>常见的自动内存管理问题：</p><ul><li>实时应用里可能由于垃圾回收时间过长出现短暂的程序停止</li><li>内存泄漏，一般多是程序员没有及时回收"野"对象</li></ul><p>有一些更高级的垃圾回收算法：</p><ul><li>concurrent: 垃圾回收的同时允许程序运行</li><li>generational：不会扫描长期存活对象（v8里就有）</li><li>real time: 减少因为垃圾回收引起的程序停止的下界</li><li>parallel: 允许多个垃圾回收器同时运行；</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 9 Optimization</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><hr /><h2 id="中间代码">中间代码</h2><p>什么是中间代码？一般常指介于高级语言(源语言)和低级语言(汇编语言)的一种语言</p><ul><li>Provides an intermediate level of abstraction<ul><li>More details than the source</li><li>Fewer details then the target</li></ul></li></ul><p>source lang =&gt;intermediate lang =&gt; target lang</p><p>intermediate lang = high-level assembly</p><ul><li>uses register names, but has unlimited number</li><li>Uses control structures like assemblly language</li><li>uses opcodes but some are higher level<ul><li>Eg: push translates to serveral assembly instructions</li><li>most opcodes correspond directly to assembly opcodes</li></ul></li></ul><p>每个指令都是以下两种形式之一(三地址码)：</p><ul><li>x := y op z</li><li>x := op y</li></ul><p>🌰：表达式 x + y * z可以转换成如下中间代码形式(每一个子表达式都有一个(寄存器)名称)：</p><ul><li><p>t1 := y * z</p></li><li><p>t2 := x + t1</p></li></ul><p><strong>总结</strong></p><p>中间代码的好处：与机器无关，可以在中间代码实现优化，提高了程序在不同系统架构之间迁移的可能性</p><h2 id="优化">优化</h2><p>Optimization is complex and largest phase</p><p>Parsing =&gt; Semantic =&gt; Opt =&gt; Gen</p><p>什么时候做优化？</p><ul><li>On AST ?<ul><li>Pro: Machine independent</li><li>Cons: Too high level</li></ul></li><li>On assembly lang ?<ul><li>Pro: Exposes optimization oppotunities</li><li>Cons: Machine dependent</li><li>Cons: Must reimplement optimizations when retargetting</li></ul></li><li>On intermediate lang ?<ul><li>Pro: machine independent</li><li>Pro: Exposes optimization oppotunities</li></ul></li></ul><p><strong>Basic Block:</strong> is a maximal sequence of instructionswith:</p><ul><li>no labels (except at the first instructions), and</li><li>no jumps (except at the last instructions)</li></ul><blockquote><p>其实就是指一段除了起始入口和末尾跳转(退出)指令没有其他跳转(退出)指令的一段指令集</p></blockquote><p>A basic block is a single-entry, single-exit, straight-line codesegment</p><blockquote><p>单一入口，单一出口，一行一行执行的程序段</p></blockquote><p><strong>control-flow graph</strong>：is a directed graph with:</p><ul><li>Basic blocks as nodes</li><li>An edge from block A to block B if the execution can pass from thelast instruction in A to the first instruction in B</li></ul><p>​ eg:</p><ul><li>the last instruction in A is <code>jump LabelB</code></li><li>execution can fall through from block A to block B (在blockA执行失败了后跳转到了block B)</li></ul><p>优化的好处：</p><ul><li>提高执行时间</li><li>减小代码体积</li><li>减少网络传输量</li><li>减小内存的使用</li><li>减小硬盘的使用（存储汇编代码文件）</li><li>减少硬件使用的电量 (这也可以，...)</li></ul><p>优化的三个粒度：</p><ul><li>local optimizations (局部优化)<ul><li>Apply to a basic block isolation</li></ul></li><li>global optimizations (全局优化)<ul><li>Apply to a control-flow in isolation</li></ul></li><li>Inter-procedural optimizations<ul><li>Apply across method boundaries</li></ul></li></ul><p>实际情况下：很难实现一个非常理想化的优化算法</p><ul><li>为什么？<ul><li>某些优化难以实现</li><li>某些优化会花费大量的编译时间</li><li>一些优化的回报很低</li><li>很多花哨的优化同时满足这三点</li></ul></li></ul><h2 id="局部优化">局部优化</h2><p>优化基本block，不涉及整个代码，比较简单</p><p><strong>algebra optimization (代数优化)</strong></p><p>有些运算可以被另一些更快的运算代替：</p><p>x := x * 8 =&gt; x := x &lt;&lt; 3</p><p><strong>Constant fold（常数折叠）</strong></p><p>Operations on constants can be computed at compile time:</p><ul><li>if there is a statement x := y op z</li><li>and y and z constants</li><li>then y op z can be computed at compile time</li></ul><p>Eg: x := 2 + 2 =&gt; x := 4; if 2 &lt; 0 jump L can be deleted</p><p>常数折叠也并不安全，因为会存在交叉编译的情况：</p><p>在X架构上编译到架构Y上运行，编译后的产物在X上运行和在Y上运行可能会产生不同的结果</p><p>X: a : = 1.2 + 6.9 经过常数折叠后=&gt; a := 8.1</p><p>Y: a: = 8</p><p><strong>单一赋值形式</strong>：每一个寄存器名称仅仅出现在一次在赋值语句的左侧</p><p>x := z + b := z + y</p><p>a := x =&gt; a := b</p><p>x := 2 * x x := 2 * b</p><p>这里有一个很重要的概念，和变量活跃度有关：Single assigment form</p><p>基于这个假设：如果基本块是以单一赋值形式出现的，即 <code>x:=</code>是在该块内仅有的一次为x赋值</p><p>那么当块内出现了相同的右侧表达式，这个表达式就是重复的（<strong>Commonsubexpression elimination</strong>）</p><p>🌰: 这个例子里x，y和z的值在省略号里是不会改变的</p><p>x := y + z x := y + z</p><p>... =&gt; ...</p><p>w := y + z w := x</p><p><strong>Copy propagatation（拷贝传播）</strong></p><p>假设基本块是以单一赋值形式存在的：</p><p>if w := x appears in a block, replace subsequent uses of w with usesof x</p><p>🌰:</p><p>b := z + y b := z + y</p><p>a := b =&gt; a := b</p><p>x := 2 * a x := 2 * b</p><p><strong>Dead code elimination</strong></p><p>上面的<code>a := b</code>对代码结果没什么恭喜，可以删除</p><p><strong>Unresearchable code delete</strong></p><p>删除不可达代码，减小代码体积</p><p>Eg:不可能走的条件分支语句；导入了一个包里所有的工具，但是有没有用(有点类似treeshaking)</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050404.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>代数优化后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050407.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>拷贝传播后：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050410.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>常数折叠：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050411.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>公共子表达式删除：</p><p>最终：</p><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week7%20P2/2021050416.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="peephole-optimization">Peephole Optimization</h2><h2 id="全局优化">全局优化</h2><p>为了在基本块之间用常数k代替变量x，编译器必须知道每条使用变量x路径的最后一个关于x的赋值语句<code>x := k</code>～～</p><p>对于全局优化，全局常量传播应该在～～处执行</p><p>所以全局优化的目标就是找到所有的～～</p><p>定义如下形式化符号：</p><table><thead><tr class="header"><th>value</th><th></th></tr></thead><tbody><tr class="odd"><td>$ $</td><td>This statement never executes（还没执行，一般用于初始化）</td></tr><tr class="even"><td>$ C $</td><td>X = C (C is constant)</td></tr><tr class="odd"><td>$$</td><td>X is not a constant（已执行，但是不确定具体值）</td></tr></tbody></table><p><strong>常数拷贝：</strong>常数拷贝是很有用的因为它可以使得一些变量直接转换成常量，从而减少寄存器的使用，但是在控制图里，判断一个变量是否可以被替换成常量是困难的</p><p>一种思路是一个变量的信息和它的上下文有关（前后语句） <spanclass="math display">\[C(s, x, in) = value \quad of \quad x \quad before \quad s  \quad在语句s之前变量x的信息\]</span></p><p><span class="math display">\[C(s, x, out) = value \quad of \quad x \quad after \quad s \quad在语句s之后变量x的信息\]</span></p><p>由于课本上的规则过于复杂，本人总结了以下规则rules：</p><ul><li>针对某个节点的入度，有以下几种情况：<ol type="1"><li>如果其入度节点其中有一个是T，则该节点信息为T</li><li>如果其入度节点存在常量，但是均不相等，则该节点信息为T</li><li>如果其入度节点存在节点固定为某个常量，且其入度节点不为T，则该节点也为该常量</li><li>如果其入度节点均为unknown，则该节点为unknown</li></ol></li><li>针对某个节点的出度，<ol start="5" type="1"><li><p>入度为unknown，则出度也为unknown</p></li><li><p>在s语句赋值为某个常量，则出度为该常量</p></li><li><p>在s语句赋值为某个非常量表达式，则出度为T</p></li><li><p>s语句如果没有对入度节点做任何更改，则出度=入度</p></li></ol></li></ul><p><strong>伪代码描述常量传播：</strong></p><blockquote><p>For every entry s to the program,，set C(s, x, in) = <spanclass="math inline">\(\top\)</span> set C(s, x, in) = C(s, x, out) =<span class="math display">\[\perp\]</span> everywhere else repeat utilall points satisfy 1-8： Pick s not satisfying 1-8 and update using theappropriate rule</p></blockquote><p><strong>为什么要引入$ $？</strong></p><p>由于循环，循环的每个点都需要值存在</p><p>直觉上，分配一些初始值去打破循环</p><p>$ $表示直到目前为止，控制流程还没有到达当前点；</p><p><spanclass="math inline">\(\top\)</span>事一种抽象值，因为不知道运行的时候具体的值，</p><p>C之间是不可比较的</p><p><span class="math inline">\(\top\)</span>是最大的，$ $是最小的</p><p><strong>符号形式化：</strong></p><p>对是$ ,, C$进行排序： <span class="math display">\[\perp &lt; C &lt; \top\]</span> 可以形象化如下：</p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230520134741534.png"alt="image-20230520134741534" /><figcaption aria-hidden="true">image-20230520134741534</figcaption></figure><p>定义 <code>lub</code> 运算： 在这个层级规则下的最小上界</p><p><code>lub(x, y, z, ..)</code>：大于等于x,y,z,...的最小值</p><p>部分可以写作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">C(<span class="hljs-params">s</span>, <span class="hljs-params">x</span>, <span class="hljs-params">in</span>)</span> = lub &#123; <span class="hljs-constructor">C(<span class="hljs-params">p</span>, <span class="hljs-params">x</span>, <span class="hljs-params">out</span>)</span> <span class="hljs-pattern-match">| p is a predecessor <span class="hljs-keyword">of</span> s &#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure><p>🌰：</p><p><code>Lub(到, 1) = 1</code></p><p><code>Lub(T, 1) = 1</code></p><p><code>Lub(1, 2) = T</code></p><p>之前简单的说一直重复直到没什么东西发生变化才停止是不准确，不规范的；</p><p>正式描述应该使用lub，lub为什么是正确的？</p><ul><li>values start as 到 and only increase</li><li>$ $ can change to a constant, and a constant to <spanclass="math inline">\(\top\)</span></li><li>Thus, <code>C(s, x, _)</code> can change at most twice</li></ul><p>常量拷贝算法是的时间复杂度和程序大小成正比</p><blockquote><p>Number of steps =</p><p>Number of C(...) values computed * 2 =✖️2是因为每个语句的最多算两次</p><p>Number of program statements * 4 ✖️2是因为每个语句的in and out</p></blockquote><p><strong>变量生存分析：</strong></p><p>从程序退出节点开始分析，向上回溯节点，</p><ol type="1"><li>如果当前节点包含出度的活跃变量的赋值语句，则当前节点的入度，就不会在有这个活跃变量(因为重新赋值了，之前的相当于是deadcode，可以被视为dead variable)；</li><li>如果当前节点的rfs（右表达式）包含某个变量，则这些变量是活跃变量；</li></ol><figure><imgsrc="https://github.com/Doraemonzzz/md-photo/blob/master/Compiler/Week8%20P2/2021050601.jpg?raw=true"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">有两个exit节点，initNode = </span><span class="hljs-template-variable">&#123; a, b &#125;</span><span class="language-xml">, lives = </span><span class="hljs-template-variable">&#123; b &#125;</span><span class="language-xml">，开始自底向上分析</span><br><span class="language-xml"></span><br><span class="language-xml">b = f + c 使用了f和c，产生了b，根据规则2，入度里f和c是活跃变量，根据规则1入度里b不是活跃变量 </span><span class="hljs-template-variable">&#123;f, c&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">f = 2 * e 使用了e，根据规则2，入度里e是活跃变量，f是新的赋值，根据规则1入度里f不是活跃变量，格局规则3，c的活跃不发生变化 </span><span class="hljs-template-variable">&#123;c, e&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">b = d + e，使用了d和e，根据规则2，d和e是活跃变量，而b被赋值了，c和f未出现1在左侧，所以</span><span class="hljs-template-variable">&#123;c,d,e,f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = e + 1, 使用了e，根据规则1，e是活跃变量，而c和f以及b都是其后续节点需要的，所以</span><span class="hljs-template-variable">&#123;b, c, e, f &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于分支处，取并集得：</span><span class="hljs-template-variable">&#123;b, c, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">对于f = 2 * e的入度，f被重新赋值，而e是被用的，所以</span><span class="hljs-template-variable">&#123; c, e &#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">同理对于 b = d + e和e = e + 1的入度，其活跃变量已经计算过：</span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">取并集的e = d + f的出度 </span><span class="hljs-template-variable">&#123;c, d, e, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">e = d + f的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, d, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">d = -a 的入度 =&gt; </span><span class="hljs-template-variable">&#123;c, a, f&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">a = b + c的入度 =&gt; </span><span class="hljs-template-variable">&#123;f, c, b&#125;</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>变量分析是自底向上，从程序的退出节点回溯的，因为程序退出的时候，可能希望某些变量依旧保存</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 6 Cool Operational semantics</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出。</p><h2 id="引言">引言</h2><p>类比：</p><p>parser阶段，我们要给每种token设置对应的action</p><p>语法分析阶段，有一系列的文法式，要在每个文法式规约的时候设置action，规定对应的行为</p><p>类型分析阶段：对每一种表达式设置对应的语义动作，进行语义分析</p><p>同样的优化阶段：对每一种表达式设置对应的代码生成及优化动作。</p><p>如何形式化表示这些表达式对应动作（语义，我理解就是表达式的动作）</p><blockquote><p>Denotational semantics: 数学函数表示</p><p>Axiomatic semantics: 通过逻辑公式描述程序行</p><p>Operational sematics: 通过执行规则描述程序评估</p></blockquote><h2 id="操作语义">操作语义</h2><p>在类型推断和检查的时候，引进过这样一种符号： <spanclass="math display">\[Context \vdash e: C在给定大的上下文context里，表达式是类型C\]</span>同样的，评估阶段(代码生成阶段之前的准备工作)，也会用类似的符号： <spanclass="math display">\[Context \vdash e: v在给定大的上下文context里，表达式会被评估为值v\]</span> 🌰： <span class="math display">\[\frac{Context \vdash e1: 5 \quadContext \vdash e2: 7}{Context \vdash e1 + e2: 12}\]</span> &gt;在语境Context下e1被评估为5，e2被评估为7，那么e1+e2就是12，当然这种是常量比较简单哈，没什么用处，实际情况下有变量的情况下就复杂了；&gt;</p><p>考虑评估：y &lt;- x + 1</p><p>由于存在局部作用域，所以评估一个值，需要：</p><p>Environment: where in memory a variable is</p><p>Store: what is in the memory</p><p>简单来说就是两个映射表：</p><p>Enviroment：va r =&gt; loc</p><p>Store: loc =&gt; value</p><p>形式化表示：</p><p><span class="math display">\[E = [a: l1, b: l2] \quad 变量a在内存中的l1处，b在内存的l2处 \\S = [l1 =&gt; 5, l2 =&gt; 7] \quad l1处存储的值是5，l2处存储的值是7 \\S&#39; = S[l2/l1] \quad defines \quad a \quad store \quadS&#39;\quad  such \quad that \\ S&#39;(l1) = 12 \quad and\quad  S&#39;(l) = S(l) \quad  if \quad l \neq l1 \\简单理解下S&#39;就是S在l1处做了单点修改\]</span></p><h2 id="cool里的语义">cool里的语义</h2><p>cool里面值都是对象（cool是面向对象的语言）</p><p><code>X(a1 = l1, ..., an = ln)</code> 表示为一个cool 对象，其中</p><ul><li><p>X是类</p></li><li><p>ai是其属性，包含继承的属性</p></li><li><p>li是对应ai被存储的内存位置</p></li></ul><p><strong>cool内置类：</strong></p><ul><li>Int(5),</li><li>Bool(true)</li><li>String(4, "cool") the string "Cool" of length 4</li><li>特殊值：void，该对象上没有方法，如果调用isvoid将会抛出异常，cool里对void的具体实现时NULL（Cpp里的空指针，因为cool是用cpp实现的）</li></ul><p>考虑如下评估式： <span class="math display">\[{so, E, S \vdash e: v, S&#39;}\]</span> so(self object)， E 是当前的变量环境，S是当前Store；</p><p>e获得了评估结果后值是v，并且新的store是S‘</p><p>评估的结果实际是值v和新的Store，新的Store是有副作用(副作用是值引用修改，而不是copy)</p><p>但是在评估后有一些事不会改变的：</p><ul><li><p>变量环境</p></li><li><p>self</p></li><li><p>操作语义允许递归</p></li></ul><p>下面具体介绍了cool的一些操作语义评估，我就简单那几个比较经典的：</p><hr /><p><strong>变量使用</strong>：在E中找到id的位置，然后在S中找对应的值<span class="math display">\[\frac{E(id) = I_{id} \quadS(I_{id}) = v}{so, E, S \vdash id: v, S}\]</span> ------</p><p><strong>self:</strong> <span class="math display">\[{so, E, S \vdash self: so, S}\]</span> ------</p><p><strong>变量赋值：</strong>就是对id处做单点修改返回新的Store，id的评估结果就是e的评估结果v<span class="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadE(id) = I_{id} \quadS_2 = S_1[v/id]}{so, E, S \vdash id=e: v, S2}\]</span> e1+e2：先递归对e1评估，评估后e1的值是v1，并产生新的StoreS1，接着对e2递归进行评估，评估后e2的值是v2，并产生新的StoreS2，最终e1+e2的评估结果就是值为v1 + v2，新的Store S2 <spanclass="math display">\[\frac{so, E, S \vdash e: v, S_1 \quadso, E, S1 \vdash e: v2, S_2}{so, E, S \vdash e1 + e2: v1 + v2, S2}\]</span> ------</p><p>🌰：{ X = 7 + 5; 4;}</p><p>先对一个表达式X=7+5评估 <span class="math display">\[{so, [X&lt;-1], [l&lt;-0] \vdash x=7+5: ?, ?}\]</span> 继续递归对7+5进行评估 <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: ?, ?}\]</span> 继续递归对7评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7: Int(7), [l&lt;-0]}\]</span> 同样的对5评估： <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 5: Int(5), [l&lt;-0]}\]</span></p><p>返回到上一层7+5: <span class="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash 7+5: Int(12), [l&lt;-0]}\]</span> 继续返回到上一层x=7+5：</p><p>这个时候已经处理完了7+5，继续处理x，这是声明变量，得到单点更新后的Store：<span class="math display">\[[l&lt;-0](12/l) =&gt; [l/12]\]</span> 这个时候子表达式都处理完了，继续处理最外层的第一个表达式 <spanclass="math display">\[{so, [X&lt;-l], [l&lt;-0] \vdash x=7+5: 12, [l&lt;-12]}\]</span> 继续处理同级别的表达式4 <span class="math display">\[{so, [X&lt;-l], [l&lt;-12] \vdash 4: Int(4), [l&lt;-12]}\]</span></p><p><span class="math display">\[\frac{...}{so, [X&lt;-1], [1&lt;-0] \vdash \{X=7+5;4;\}: Int(4),[1&lt;-12]}\]</span></p><hr /><p><strong>if-else</strong></p><p><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173710435.png"alt="image-20230514173710435" /> <span class="math display">\[\frac{so, E, S \vdash e1: Bool(false), S1}{so, E, S \vdash while \quade1 \quad loop \quad e2 \quad pool: void, S1}\]</span> ------</p><p><strong>while</strong></p><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173719883.png"alt="image-20230514173719883" /><figcaption aria-hidden="true">image-20230514173719883</figcaption></figure><hr /><p><strong>声明变量：</strong> <span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad so, ?, ? \vdash v, S2}{so, E, S\vdash let \quad id: T = e1 \quad in \quad e2: v2, S2}\]</span> e2应该在什么环境下评估呢（问号处应该填什么呢）？</p><p>—仍然是E，但是E里应该新增映射<code>id =&gt; Inew</code>，表示为id新分配了一块内存，同样的Store应该是有新的映射<code>Inew =&gt; v1</code></p><p>新增符号：Inew =newloc(S)，表示Inew是一个新分配的内存，newloc可以理解为是一个内存分配函数<span class="math display">\[\frac{so, E, S \vdash e1: v1, S1 \quad I_{new} = newloc(S1) \quad  so,E[I{new}/id], S1[v1/I_{new}] \vdash v2, S2}{so, E, S \vdash let \quadid: T = e1 \quad in \quad e2: v2, S2}\]</span></p><hr /><p><strong>new对象的评估语义：</strong></p><ul><li><p>首先，为对象的所有参数分配内存（本质上就是分配对象）</p></li><li><p>为对象设置缺省值</p></li><li><p>评估对象的初始化语句，并重新设置属性值</p></li><li><p>返回被分配的对象</p></li></ul><p>每个对象都有默认值</p><ul><li><p>int： Int(0)</p></li><li><p>bool: Bool(false)</p></li><li><p>String: String(0, '')</p></li></ul><p>类A的形式化表示：</p><p><code>class(A) = (a1: T1 &lt;-e1, ..., an: Tn &lt;- en)</code>，其中：</p><ul><li><code>ai</code>是属性，包含继承属性</li><li><code>Ti</code>是属性的类型</li><li><code>ei</code>是初始化表达式</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514173910377.png"alt="image-20230514173910377" /><figcaption aria-hidden="true">image-20230514173910377</figcaption></figure><p>在评估初始化表达式阶段：</p><ul><li><p>self is the current object</p></li><li><p>only the attributes are in scope()，作用域内只有属性</p></li><li><p>属性的初始值都是默认值，主要是防止在初始化语句里面会用到这些初始值，比如:<code>Class A &#123; a &lt;- a &#125;</code>，用a初始化a，如果a没有默认值，可能会有异常；</p></li></ul><p>Informal semantics of class e0.f(e1, ..., en)：</p><ul><li><p>首先，依次评估参数e1, ..., en，</p></li><li><p>评估e0，获得e0的值</p></li><li><p>假设X是e0评估结果的动态类型</p></li><li><p>从dispatch table中获取f</p></li><li><p>为n个参数分配内存空间，更新Enviroment</p></li><li><p>为分配的空间初始化值</p></li><li><p>set selft to the target object and evaluate f's body</p></li></ul><p>For a class <code>A</code> and a method f of <code>A</code> (possibleinherited)</p><p><code>impl(A, f) = (X1, ..., Xn, ebody)</code>，其中：</p><ul><li><code>Xi</code>是形式参数</li><li><code>ebody</code>是方法体(函数体)</li></ul><figure><imgsrc="/Users/bytedance/Library/Application%20Support/typora-user-images/image-20230514174645616.png"alt="image-20230514174645616" /><figcaption aria-hidden="true">image-20230514174645616</figcaption></figure><p><u>impl</u>有没有可能获取不到方法？不可能，因为类型检查以已经通过了，倘若没有类型检查，这一阶段会更复杂</p><p>当然也有一些runtime error类型检查检查不到：</p><ul><li>A dispathc on void</li><li>Division by zero</li><li>Substring out of range</li><li>Heap overflow</li></ul><p>这些异常情形下，编译器必须抛出错误，并中断，而不是崩溃(not with asegfault)</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯坦福cs231(编译原理)の 8 Cool Object Layout</title>
    <link href="/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/"/>
    <url>/emocoder/2023/05/14/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p>本文是斯坦福cs143编译原理的笔记，内容大部分来自于课件和自己的理解，笔者能力和精力有限，如果有错误欢迎指出</p><ul><li>Introduction to code gen</li><li>code gen 1</li><li>code gen 2</li></ul><h2 id="temporaries">Temporaries</h2><p>之前介绍的汇编代码比如两个表达式相加：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">a0</span> (<span class="hljs-number">0</span>)$<span class="hljs-built_in">sp</span><br>li $<span class="hljs-built_in">t0</span> ?<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s0</span> $<span class="hljs-built_in">sp</span><br></code></pre></td></tr></table></figure><p>这里把其中一个加数放在了stack里，然后取出来，再把计算的中间结果放在了stack里，这就是临时变量</p><p>最普通的<strong><code>堆栈机</code></strong>需要在函数栈帧暂存这些临时变量（虽然这并不高效，后面会讲解关于临时变量分配到寄存器的算法）</p><p>考虑下面代码使用了多少临时变量：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> fib(x) = <br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">1</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">0</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if</span> (x == <span class="hljs-number">2</span>) ==&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">then</span> <span class="hljs-number">1</span> ==&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">fib</span>(x-<span class="hljs-number">1</span>) + fib(x-<span class="hljs-number">2</span>) ==&gt; x-<span class="hljs-number">1</span>是一个，x-<span class="hljs-number">2</span>是一个，两式相加，会产生一个，所以共两个<br><span class="hljs-attribute">fi</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>定义NT(e)为表达式e需要多少个临时变量</p><p>对于一个函数定义：<code>f(x1, ..., fn) = e</code>，the AR has<code>2 + NT(e)</code> elements:</p><ul><li>Return</li><li>Frame pointer</li><li>n arguments</li><li>NT(e)</li></ul><p>以下是一些常见的规则：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NT(<span class="hljs-params">e1</span> + <span class="hljs-params">e2</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>)<br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e1</span>)</span><br>Needs at least <span class="hljs-keyword">as</span> many tempories <span class="hljs-keyword">as</span> <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span><br>Of course, space used <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e1 can be reused <span class="hljs-keyword">for</span> temporaies <span class="hljs-keyword">in</span> e2<br><br><span class="hljs-constructor">NT(<span class="hljs-params">if</span> <span class="hljs-params">e1</span> = <span class="hljs-params">e2</span> <span class="hljs-params">then</span> <span class="hljs-params">e3</span> <span class="hljs-params">else</span> <span class="hljs-params">e4</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e2</span>)</span> + <span class="hljs-number">1</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e3</span>)</span>, <span class="hljs-constructor">NT(<span class="hljs-params">e4</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>(<span class="hljs-params">e1</span>, <span class="hljs-operator">...</span>, <span class="hljs-params">en</span>)</span> = <span class="hljs-constructor">Max(NT(<span class="hljs-params">e1</span>)</span>, ..., <span class="hljs-constructor">NT(<span class="hljs-params">en</span>)</span>)<br><span class="hljs-constructor">NT(<span class="hljs-params">int</span>)</span> = <span class="hljs-number">0</span><br><span class="hljs-constructor">NT(<span class="hljs-params">id</span>)</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在没有使用临时变量之前：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cgen(e1 + e2) = <br>cgen(e1)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">a0</span> <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">sp</span> $<span class="hljs-built_in">sp</span> - <span class="hljs-number">4</span><br>cgen(e2)<br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">a0</span><br><span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">a0</span> $<span class="hljs-built_in">sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>使用了临时变量之后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">cgen(e1 + e2, nt) = <br>cgen(e1, nt)<br>sw <span class="hljs-variable">$a0</span> nt(<span class="hljs-variable">$fp</span>) <span class="hljs-regexp">//</span> 在偏移量处做压入栈<br><span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$sp</span> <span class="hljs-variable">$sp</span> - <span class="hljs-number">4</span> 这样就不用了频繁执行addiu了<br>cgen(e2, nt + <span class="hljs-number">4</span>)<br>lw <span class="hljs-variable">$t1</span> nt(<span class="hljs-variable">$fp</span>)<br>add <span class="hljs-variable">$a0</span> <span class="hljs-variable">$t1</span> <span class="hljs-variable">$a0</span><br>  <span class="hljs-regexp">//</span> addiu <span class="hljs-variable">$a0</span> <span class="hljs-variable">$sp</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="object-layout-and-dynamic-dispatch">Object Layout and dynamicdispatch</h2><p>OO(Objetc Oriented) Implementation = Basic code generation + morestuff(面向对象的实现其实就是之前所介绍的基本代码生成+本次要讲的内容)</p><p>OO Slogan：如果A是B的子类，那么B类对象可以用于任何A类的地方：</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b</span> <span class="hljs-title">extends</span> <span class="hljs-title">A</span> &#123;</span>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span> <span class="hljs-params">(A a)</span> &#123;<br><br>&#125;<br><br>函数f的入参可以是A及其子类<br></code></pre></td></tr></table></figure><p>这就意味着在代码生成的时候，在已经生成完了A类的代码，那么B类(A的子类)可以不用修改其父类(A)的代码，而只是在其基础上进行扩展。</p><p>再介绍对象的代码生成之前，需要考虑以下问题：</p><p><code>对象在哪村里如何表示？</code></p><ul><li><p>Objects are laid out int contiguous memory;</p></li><li><p>Each attribute stored at a fixed offset in the object;</p></li><li><p>The attribute is in the same place in every object of thatclass;</p></li><li><p>When a method is invoked, the object is self and the fields arethe object's attributes;</p></li></ul><blockquote><p>为什么对象每个属性都是固定的偏移量呢？这要归结于同一个类可以new多个对象，但这些对象的数据内存是各自独有的，每个对象同一个属性在固定偏移量的内存处，方便获取；而方法是共享的，所以方法单独维护在了一张methodstable中，每个对象都都持有指向这个methods table的指针dispatchpointer，不然不同的对象还要维护各自的方法，这样太费内存了。</p></blockquote><p><code>如何实现动态分配?</code></p><p>Method table and dispatch ptr</p><p>关于动态分配和静态分配的概念：https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/</p><p>其实node里也有静态分配和动态分配的概念：</p><p>wip</p><p><strong>首先介绍下对象布局</strong></p><p>考虑如下🌰，以下内容均围绕该🌰展开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">class <span class="hljs-selector-tag">A</span> &#123;<br><span class="hljs-selector-tag">a</span>: Int &lt;- <span class="hljs-number">0</span>;<br>d: Int &lt;- <span class="hljs-number">1</span>;<br>f(): Int &#123; <span class="hljs-selector-tag">a</span>&lt;- <span class="hljs-selector-tag">a</span> + d &#125;;<br>&#125;<br><br>class <span class="hljs-selector-tag">B</span> &#123;<br> <span class="hljs-selector-tag">b</span>: Int &lt;- <span class="hljs-number">2</span>;<br> f(): Int &#123; <span class="hljs-selector-tag">a</span> &#125;;<br> g(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span> &#125;;<br>&#125;<br><br>class C &#123;<br>c: Int &lt;- <span class="hljs-number">3</span>;<br>h(): Int &#123; <span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-selector-tag">a</span> * c &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>cool objects layout: (下面内存是连续的)</p><table><thead><tr class="header"><th style="text-align: center;">Class tag(int) 类标识符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Object size(int)</td></tr><tr class="even"><td style="text-align: center;">Dispatch ptr</td></tr><tr class="odd"><td style="text-align: center;">Attribute 1</td></tr><tr class="even"><td style="text-align: center;">Attribute 2</td></tr><tr class="odd"><td style="text-align: center;">...</td></tr></tbody></table><p>其中前3个称为header infomation</p><p>关于继承的子类的内存布局：考虑父类A，其子类B可以通过在A布局之上进行扩展得到，如下：</p><blockquote><p>B is an extension， just leaves the layout of A unchanged</p></blockquote><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th><th>8</th><th>12</th><th>16</th><th>20</th></tr></thead><tbody><tr class="odd"><td>A</td><td>Atag</td><td>5(word)</td><td>dispatch ptr1</td><td>a</td><td>d</td><td></td></tr><tr class="even"><td>B</td><td>Btag</td><td>6(word)</td><td>dispatch ptr2</td><td>a</td><td>d</td><td>b</td></tr><tr class="odd"><td>C</td><td>Ctag</td><td>6(word)</td><td>dispatch ptr3</td><td>a</td><td>d</td><td>c</td></tr></tbody></table><p>The offset for an attribute is the same in a class and all of itssubclass</p><p><strong>介绍下动态分配</strong></p><p>考虑e.f(), 这个表达式e生成之后，该如何调用对象上的方法呢？</p><p>和属性布局一样，对象的方法同样在内存上有着固定的偏移量(包含继承的方法)，只不过这些方法是存在一张dispatchtable里的(其实我个人喜欢称之为methodtable)，这张表提供了索引这些方法的能力，表里存储的是函数地址，如，方法f就是在其附属类的表里的固定偏移量处，当然在其子类也是同样的偏移量；</p><p>为什么同一方法在类和其子类中设计成固定的偏移量呢？wip</p><table><thead><tr class="header"><th>Class</th><th>0</th><th>4</th></tr></thead><tbody><tr class="odd"><td>A</td><td>fa</td><td></td></tr><tr class="even"><td>B</td><td>fb</td><td>g</td></tr><tr class="odd"><td>C</td><td>fa</td><td>h</td></tr></tbody></table><p>注：如果fa中海定义了其他方法，则可以</p><p>类的每个方法f都在编译期被分配在dispatch table的固定偏移量O_f处，换句话说，编译器的工作就是找出类的所有方法然后给每个方法分派一个固定的位置。</p><p>综上，为了实现dynamic dispatch<code>e.f()</code>，编译器应该走以下两个步骤：</p><ol type="1"><li>评估表达式e，得到一个对象x；</li><li>call <code>D[Of]</code><ul><li>D is the disptatch table for x</li><li>in the call ,self is bound to x</li></ul></li></ol><h2 id="总结">总结</h2><p>在学习完之后，我们考虑下如果是我们该如何为以下代码设计代码生成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>a: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">1</span>;<br>f(): <span class="hljs-type">Int</span> &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">1</span>) &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>b: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">10</span>;<br>g(): int &#123; b;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>m: <span class="hljs-type">Int</span> &lt;- <span class="hljs-number">2</span>;<br>f(): int &#123; <span class="hljs-type">Int</span>(<span class="hljs-number">2</span>)&#125;;<br>&#125;<br><br>b: <span class="hljs-type">B</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br>b.g();<br><br>c: <span class="hljs-type">C</span> &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>();<br>c.f();<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">评估b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new B();</span><br><span class="hljs-attribute">初始化</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table1</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><span class="hljs-attribute">g</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__g</span><br><br><br><span class="hljs-attribute">dispath table1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br><span class="hljs-attribute">评估c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">A &lt;- new C();</span><br><span class="hljs-attribute">初始化c</span><br><span class="hljs-attribute">classTag</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br><span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">0f4888 =&gt; dispath table2</span><br><span class="hljs-attribute">a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">m</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><br><br><span class="hljs-attribute">dispath table2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">f</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rcsv__f</span><br><br>b.g();<br>获取b对象的dispatch table1<br>拿到g方法<br>调用即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础，cool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug</title>
    <link href="/emocoder/2023/05/07/debug/"/>
    <url>/emocoder/2023/05/07/debug/</url>
    
    <content type="html"><![CDATA[<h2 id="日志工具">日志工具</h2><p>开发者使用： trace：打印调用堆栈debug：不仅打印调用堆栈，还打印变量信息</p><p>用户使用： info warn：只是警告，但是不影响运行error：报错，但是不影响整个应用程序的继续运行 fatal:中断整个应用程序的执行</p><p>首先</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，node，调试，debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hacktech</title>
    <link href="/emocoder/2023/05/06/hacktech/"/>
    <url>/emocoder/2023/05/06/hacktech/</url>
    
    <content type="html"><![CDATA[<p>内网渗透+爆破：https://blog.csdn.net/m0_46684679/article/details/117854834</p><p>安全集锦：https://www.zhihu.com/column/c_1334810805263515648</p><p>网络防火墙：https://zhuanlan.zhihu.com/p/159088465</p><p>格式: echo -e "\033[字背景颜色;字体颜色m字符串\033[0m"</p><p>-e对特殊字符做转义</p><p>eg: echo -e "\033[41;36m something here \033[0m"</p><p>其中41的位置代表底色, 36的位置是代表字的颜色</p><p>正则通配符和linux通配符是不一样的，<em>（星号）是linux中的通配符，代表一个或一个以上的所有字符。linux的隐藏文件和隐藏文件夹都是以.（点号）开头，所以.</em>应该是代表当前目录下的所有隐藏目录和隐藏文件夹。如果是./*则表示当前目录下的所有文件和所有目录，因为.（点号）还有代表当前目录的意思</p><p>https://zhuanlan.zhihu.com/p/96272363，日志应该是最初开发的一部分其次，结束调试不要删除日志</p><p>写日志的地方： 关键方法调用：时间和调用参数 上下游对接处可能存在异常的地方</p><p>其他console方法： console.count: 用于计算函数被调用的次数console.log.countReset</p><p>console.group: 用于折叠 console.groupCollapsed() console.groupEnd</p><p>consoel.time() console.timeEnd()</p><p>console.table()</p><p>console.dir(obj, { depth: })</p><h2 id="chrome-devtools">Chrome Devtools</h2><p>Network: 查看，过滤网络请求列表，查看请求详情 模拟弱网环境搜索headers以及response内容 使用requeset block</p><p>Source 查看加载的资源文件 编辑css和js，修改css和js snippets管理断点调试 通过workspace关联到本地</p><ol type="1"><li><p>如何让source里的文件树看起来更清晰——查看author-deployed，但是项目必须有source-map</p></li><li><p>如何让call stack中仅出现关心的文件 ——debug ignore list在实际操作里，在stepin的过程中，如果遇到了一个不想调试的文件直接右击文件的代码区域，addignore list，下一次step in的时候就不会出现这个文件了，</p></li></ol><p>如何恢复？ ——顶级settings，找到ignore list</p><ol start="3" type="1"><li><p>如何对js的修改，reload之后还可以生效——overrides，选择本地目录添加到overrides中，</p></li><li><p>如何找出哪一行代码影响了我的元素 ——dom change breakponits比如找到哪一行删除了某个dom节点：右击某个dom节点——》break on-》noderemoval</p></li><li><p>如何找出哪一行代码发起了请求 ——source面板找到xhr/fetchbreakpoints，输入拦截的url即可</p></li><li><p>异常断点：source面板找到break points，勾选pause oncaught/uncaught points 捕获的or未捕获的</p></li><li><p>事件断点 全局事件：source面板找到event listener breakpoints，选择相应的事件即可</p></li><li><p>如何打断点，不会中断？ source 面板，某一行，右击选择edit breakpoints =》选择log points，输入想打印的语句即可</p></li></ol><p>字颜色:30-----------37 30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色36:深绿 37:白色</p><p>字背景颜色范围:40----47 40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色46:深绿 47:白色</p><p>字体加亮颜色:90------------97 90:黑 91:红 92:绿 93:黄 94:蓝色 95:紫色96:深绿 97:白色</p><p>背景加亮颜色范围:100--------------------107 40:黑 41:深红 42:绿43:黄色 44:蓝色 45:紫色 46:深绿 47:白色</p><p>===============================================ANSI控制码的说明\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m反显 \33[8m 消隐 \33[30m -- \33[37m 设置前景色 \33[40m -- \33[47m设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行\33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l隐藏光标 \33[?25h 显示光标</p><p>1b[2J1b[$;1H $表示行位</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透，爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXS</title>
    <link href="/emocoder/2023/05/05/xxs/"/>
    <url>/emocoder/2023/05/05/xxs/</url>
    
    <content type="html"><![CDATA[<p>XSS (Cross-sitescripting)，即跨站脚本攻击，应该是前端同学都应该听过的网络安全相关的名词。它是一种尝试注入恶意脚本代码到网站上的攻击形式。它可以使得恶意使用者的代码在受影响用户的浏览器端执行，并对用户的影响。原本简称css，为了与前端的级联样式表(cascader style sheet)区分，改称 xss。</p><h2 id="xss-类型">XSS 类型</h2><p>XSS 大致可以分为 3 个类型</p><p>反射型 （Reflected XSS Attacks） 此种类型的跨站代码存在于 URL中，所以黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。</p><p>存储型（Stored XSS Attacks） 存储型 XSS 脚本攻击是指 Web应用程序会将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，因此存储型XSS 具有较强的稳定性。</p><p>DOM-based 型（DOM-based XSS Attacks） DOM-based的跨站脚本攻击是通过修改页面 DOM 节点数据信息而形成的跨站脚本攻击。</p><p>为了更加深切的近距离体验xss，可以登陆下https://xss-game.appspot.com/level3，这个游戏是 Google提供的一个 XSS的小游戏，大家可以自己在浏览器里试试看能不能闯过所有的关卡（可以通过研究Target Code 来找到可以注入代码的地方，如果想不出来可以看看页面上的Hints）。建议尽量不要看提示来挑战。这个游戏一共有 6关，每个关卡利用了各种不同的技巧和方式来插入恶意代码，有些方式确实非常取巧。</p><p>level1: 通过在 query 里拼接 script 元素，而前端代码又是会展示这个query 的，所以没有过滤的话，就直接运行脚本了，直接利用了 url插入脚本，属于反射型</p><p>level2: 用户提交 blog 或者评论，前端会展示这些评论或者 blog，虽然script 元素不会展示，但是像 dom 节点，如 a，img 元素还是会展示的，利用了dom，属于 dom 型，也可以理解为存储型，和存储相关。</p><p>level3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chooseTab</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// Dynamically load the appropriate image.</span><br>  <span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;Image &quot;</span> + <span class="hljs-built_in">parseInt</span>(num) + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>  html += <span class="hljs-string">&quot;&lt;img src=&#x27;/static/level3/cloud&quot;</span> + num + <span class="hljs-string">&quot;.jpg&#x27; /&gt;&quot;</span>;<br>  $(<span class="hljs-string">&quot;#tabContent&quot;</span>).<span class="hljs-title function_">html</span>(html);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用了在浏览器直接输入 url 的漏洞，前端代码会用 url 里的参数作为 img元素的属性直接拼接，由于没有对这些参数做转义，所以可能会导致恶意代码插入，由于利用了dom 元素，属于 dom 型</p><p>level4: 服务端模板包含如下代码：<img src="/static/loading.gif" onload="startTimer('');"/&gt;而timer是从url的参数里取的，如果这个timer包含了其他的js脚本代码，就会有问题，如下：https://xss-game.appspot.com/level4/frame?timer=')%3Balert(1)%3Bvarb=('</p><p>=&gt; startTimer('');alert(1);var b=('');</p><p>level5: 前端脚本： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; next &#125;&#125;&quot;</span>&gt;</span>Next &gt;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>前端直接利用url的参数拼接成了a元素的href属性：https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</p><p>level6: 服务端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInnerText</span>(<span class="hljs-params">element, value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">innerText</span>) &#123;<br>    element.<span class="hljs-property">innerText</span> = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element.<span class="hljs-property">textContent</span> = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">includeGadget</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">var</span> scriptEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br>  <span class="hljs-comment">// This will totally prevent us from loading evil URLs!</span><br>  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^https?:\/\//</span>)) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&#x27;Sorry, cannot load a URL containing &quot;http&quot;.&#x27;</span><br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Load this awesome gadget</span><br>  scriptEl.<span class="hljs-property">src</span> = url;<br><br>  <span class="hljs-comment">// Show log messages</span><br>  scriptEl.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>), <span class="hljs-string">&quot;Loaded gadget from &quot;</span> + url);<br>  &#125;;<br>  scriptEl.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setInnerText</span>(<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;log&quot;</span>),<br>      <span class="hljs-string">&quot;Couldn&#x27;t load gadget from &quot;</span> + url<br>    );<br>  &#125;;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(scriptEl);<br>&#125;<br><br><span class="hljs-comment">// Take the value after # and use it as the gadget filename.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGadgetName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;/static/gadget.js&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">includeGadget</span>(<span class="hljs-title function_">getGadgetName</span>());<br></code></pre></td></tr></table></figure><p>这里本来想直接插入script元素的，但是行不通，只有通过script的src外链加载外域脚本：htTps://pastebin.com/raw.php?i=15S5qZs0https://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw.php?i=15S5qZs0</p><h2 id="更进一步地实验">更进一步地实验</h2><p>因为现在大部分的前后端框架都会有 XSS相关的安全策略，且默认是开启的，平时想要测试一下 XSS的漏洞可能还比较麻烦。针对这种情况，可以使用 Damn Vulnerable WebApplication（https://github.com/digininja/DVWA），它是一个主动关闭了各种安全策略的Web 应用，包括了各种各样漏洞，当然也包括 XSS的部分，可以用来测试自己对这些漏洞的掌握。</p><p>防范手段 防御 XSS一大原则就是不要信任用户输入的内容！所有用户输入的内容都可以默认为不可控的、不安全的，包括但不限于表单输入/URL 等可以由用户任意输入的来源。在回显用户的输入时候一定要做XSS 的过滤和相应的编码。</p><h2 id="浏览器内置的安全机制">浏览器内置的安全机制</h2><p>开启 X-XSS-Protection：针对反射型 XSS的一种浏览器防御机制，现在大部分现代浏览器已经废弃了这个属性。</p><p>内容安全策略 CSP：CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS 攻击所依赖的载体。一个 CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本(包括内联脚本和 HTML 的事件处理属性) 浏览器的同源策略。</p><p>Cookie 安全：设置 Cookie 的 HttpOnly 属性，能够最大限度的保证你的Cookie 不会被脚本所读取并发送到其他服务器上。</p><h2 id="使用成熟的框架安全机制">使用成熟的框架安全机制</h2><p>对于前端来说，使用常用的库，React/Vue/Angular等流行框架来渲染数据基本上都不会有太大的问题。需要注意的是，必须非常非常非常慎重使用类似React 的 dangerouslySetInnerHTML 或者 Vue 的 v-html 这类绕过 XSS过滤能力的属性。</p><p>不少后端服务的框架也都在设计时就考虑了 XSS 的安全问题，如 Ruby onRails。当然这类防御措施还是有其局限性的，并不是能一劳永逸的解决所有攻击威胁的。</p><h2id="在没有框架安全机制保证下需要避免的操作">在没有框架安全机制保证下需要避免的操作</h2><p>对于前端来说，主要需要针对处理的是 DOM-based 的 XSS 威胁。</p><p>在使用 Vanilla JavaScript 需要避免那些能够直接修改 HTML 的操作，如innerHTML/outerHTML 属性或者 document.write之类的方法。当需要展示文本的时候，选择如 textContent/innerText之类安全的方法。当需要创建 HTML 标签的时候，选择createElement/appendChild 之类的方法。</p><p>还有就是更加危险的 eval方法，虽然一般不会使用，但是需要避免一些隐式的 eval 使用，比如setTimeout/setInterval 就可以通过 setTimeout(codeAsString, delay)的形式执行任意字符串代码。</p><p>除此之外还有 HTML 标签上的一些事件属性等等。</p><p>如果无可避免的要使用类似方法，一定在渲染前做好过滤和编码工作。</p><h2 id="更加细致的防范-cheatsheet">更加细致的防范 CheatSheet</h2><p>开放式 Web 应用程序安全项目 （ OWASP）提供了针对 XSS 防御的详尽CheatSheet，感兴趣的同学可以作为参考。</p><p>https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.htm</p><p>https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html</p><h2 id="安全检测">安全检测</h2><p>一些工具可以扫描网站存在的 XSS 漏洞，可以方便查缺补漏</p><p>https://github.com/s0md3v/XSStrike</p><p>https://www.zaproxy.org/</p><h2 id="最后的最后">最后的最后</h2><p>需要注意，以上这些防御措施不能详尽描述每个细节和抵御所有 XSS攻击方式。针对 XSS的攻防战没有一劳永逸的银弹，也没有傻瓜式的解决方案。只有严格遵照安全最佳实践来尽量避免，并提升安全防范的意识，加强安全审计的工作。</p><p>钓鱼攻击： 主要是发生在提交的 HTMl内容的时候带有一些其他的域名地址，这些域名地址存在钓鱼的风险。 防范方式通过 securitykit.surl 方法进行校验，该方法对非白名单的地址进行剔除。</p><p>XSS防御方案最好是在编译时合运行时提供相关的预防方案：编译时预防开发人员出现存在安全漏洞的代码；运行时尽量不相信用户的任何输入</p><ul><li>运行时：提供运行时过滤API，能够过滤不在白名单上的标签以及常见的伪协议字符串。</li><li>编译时：提供 Babel 插件进行 AST 风险点识别，在风险点中包裹运行时过滤API，起到自动防御的能力。</li></ul><h2 id="参考文章">参考文章：</h2><p>https://blog.dornea.nu/2014/06/02/googles-xss-game-solutions/</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端，xxs，跨站脚本攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git checkout 妙用</title>
    <link href="/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/"/>
    <url>/emocoder/2023/05/05/git-checkout-%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>当你在 Git中处理一个仓库时，你可能需要从另一个分支中获取（checkout）一个指定的文件。</p><p>幸运的是，Git提供了许多可能的方法来快速完成这项任务。其中一个最简单的解决方案是使用gitcheckout命令，将指定的文件作为一个参数。</p><p>在这篇文章中，我们将分析这个问题的不同解决方案，并介绍每一种解决方案所需要遵循的流程。</p><p>让我们开始吧。😎</p><p>Git Checkout 用例你正在处理一个名为feature/A的分支，其中包含一个名为utils.js的文件。</p><p>你有另一个名为feature/B的分支，里面有一个更新的utils.js文件。</p><p>你想签出该文件，并将其从feature/B分支带到feature/A分支。</p><p>下面是这个任务的三种可行的解决方案。</p><p>解决方案 1：使用 git checkout 命令 gitcheckout命令提供了一个简单的方法来从另一个分支获取文件或文件夹。</p><p>以下是从另一个分支获得（checkout）文件的语法：</p><p>git checkout <other-branch-name> -- path/to/your/folder以下是要遵循的流程：</p><ol type="1"><li>切换（checkout）到你想复制文件的那个分支。</li></ol><p>git checkout feature/A 2. 你在当前分支上，复制该文件。</p><p>git checkout feature/B -- utils.js 3. 使用gitstatus命令来确保文件已经被复制了。</p><ol start="4" type="1"><li>提交并推送到远程。</li></ol><p>在使用 checkout 命令时，你也可以得到：</p><p>一个来自另一个分支的文件夹。 通过指定每一个文件，可以指定多个文件另外，请注意，你可以从 stash 获得一个文件/文件夹。</p><p>解决方案 2：使用 git restore 命令 另一个选择是使用git switch命令和gitrestore命令。</p><p>如果你从未听说过这两个命令，那也没关系。它们是比较新的。Git 在 2019年的 2.23 版本中引入了它们。</p><p>这两个命令的目的是减少使用 git checkout命令，以简化用户的工作。</p><p>git restore命令可以恢复工作树。</p><p>git switch命令切换分支。</p><p>下面是从另一个分支获取文件的过程：</p><ol type="1"><li>切换到你想获取（checkout）文件的分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git restore --source feature/B -- utils.js 3. 提交并推送更改。</p><p>解决方案 3：使用 git show 命令 最后，我们可以使用git show命令。</p><p>以下是要遵循的流程：</p><ol type="1"><li>切换到工作分支。</li></ol><p>git switch feature/A 2. 从另一个分支获取文件。</p><p>git show feature/B:path/utils.js &gt; path/utils.js 3.提交并推送更改。</p><p>注意: 这次你需要指定来自你的目录根的相对路径。</p><p>小结正如你所看到的，从另一个分支获取一个文件并不是什么像发射火箭那样困难。</p><p>当我在日常生活中需要这样做时，我通常使用git checkout命令。</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node从头手写一个简单编译器</title>
    <link href="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>使用语言：node本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><p>结果示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来从以下几个方面介绍：</p><ol type="1"><li>parser：包含正则表达式生成和词法token生成</li><li>semantic：文法推导式解析和抽象语义树生成</li><li>check：语法和类型校验</li><li>gen：汇编代码生成</li></ol><h2 id="parser">parser</h2><p>在词法分析阶段，输入是字符串，输出是 token流，一开始设计输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学在构建自动机过程中，自动机把输入流转成token流，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级，这里的优先级比较简单，直接遍历终态节点数组endStates(可以理解为叶子节点)，遇到第一个符合的即返回，所以正则的优先级和前后顺序有关；</p><p>那么如何构建自动机？我们的目标是构建一系列单个正则表达式单元nfa，然后联合成一个大的nfa单元，这个nfa可以解析我们的之前正则单元，再得到联合nfa的邻接矩阵edges，最后根据edges转成dfa，具体步骤如下：</p><p>首先，需要名明确的是，我们的词法分析器支持以下几个单元： +: a+, <em>:a</em>, 连接: ab， 逻辑或: a|b， 字符集: [a-z]支持少部分字符转义，如：, t, </p><p>如何把正则表达式构建为nfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个元外加一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是单个字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack进行存储，类比括号匹配算法。(<code>lib =&gt; parser =&gt; nfa =&gt; flex函数</code>)</p><h3 id="构建基本正则单元">构建基本正则单元</h3><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>: VertexNode, to: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-comment">// from的尾和to的头相互连接,注意circle</span><br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">memo</span>: number[] = [];<br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span> &amp;&amp; !memo.<span class="hljs-title function_">includes</span>(cur.<span class="hljs-property">index</span>)) &#123;<br>    memo.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">index</span>);<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br><br>  graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<br>    to.<span class="hljs-property">index</span>,<br>    graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">index</span>).<span class="hljs-property">firstEdge</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>或</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">or</span>(<span class="hljs-params">a: VertexNode, b: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, a.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(b.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, b.<span class="hljs-property">edgeVal</span> || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeEnd, nodeEnd.<span class="hljs-property">index</span>);<br>  <span class="hljs-title function_">connect</span>(a, nodeEnd);<br>  <span class="hljs-title function_">connect</span>(b, nodeEnd);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">characters</span>(<span class="hljs-params">chars: string[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> nodeEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>, chars);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(nodeEnd.<span class="hljs-property">index</span>, chars);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br><br>  <span class="hljs-keyword">const</span> pre = nodeStart.<span class="hljs-property">firstEdge</span>;<br>  nodeStart.<span class="hljs-property">firstEdge</span> = nodeEnd;<br>  nodeEnd.<span class="hljs-property">next</span> = pre;<br><br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutipliy</span>(<span class="hljs-params">wrapped: VertexNode</span>): <span class="hljs-title class_">VertexNode</span> &#123;<br>  <span class="hljs-keyword">const</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, <span class="hljs-literal">null</span>);<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(wrapped.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = tmp;<br>  <span class="hljs-keyword">let</span> cur = graph.<span class="hljs-title function_">getVertex</span>(wrapped.<span class="hljs-property">index</span>); <span class="hljs-comment">// 获取邻接表</span><br>  <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">firstEdge</span>) &#123;<br>    cur = graph.<span class="hljs-title function_">getVertex</span>(cur.<span class="hljs-property">firstEdge</span>.<span class="hljs-property">index</span>);<br>  &#125;<br>  <span class="hljs-title function_">connect</span>(cur, nodeStart);<br>  <span class="hljs-keyword">return</span> nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">base: VertexNode</span>) &#123;<br>  <span class="hljs-comment">// 基于old新建节点</span><br>  <span class="hljs-keyword">let</span> nodeStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, base.<span class="hljs-property">edgeVal</span>);<br>  nodeStart.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">const</span> res = nodeStart;<br>  graph.<span class="hljs-title function_">addVertexNode</span>(nodeStart, nodeStart.<span class="hljs-property">index</span>);<br>  <span class="hljs-keyword">let</span> cur = base?.<span class="hljs-property">firstEdge</span>;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">const</span> vertexNode = graph.<span class="hljs-title function_">getVertex</span>(cur?.<span class="hljs-property">index</span>);<br>    <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VertexNode</span>(<span class="hljs-title class_">Graph</span>.<span class="hljs-property">node_id</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart.<span class="hljs-property">firstEdge</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(tmp.<span class="hljs-property">index</span>, <span class="hljs-literal">null</span>, vertexNode.<span class="hljs-property">edgeVal</span>);<br>    nodeStart = tmp;<br>    tmp.<span class="hljs-property">firstEdge</span> = base.<span class="hljs-property">firstEdge</span>;<br>    graph.<span class="hljs-title function_">addVertexNode</span>(tmp, tmp.<span class="hljs-property">index</span>);<br>    cur = vertexNode.<span class="hljs-property">firstEdge</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mutipliy</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用邻接表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。</p><p>if对应的nfa: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104727865.png" class=""></p><p>[a-z][a-z0-9]* 的nfa为: <img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104740056.png" class=""></p><p>联合后就变成了一个大的nfa，并在终态节点上放置一些动作：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/image-20230510104921040.png" class=""></p><h3 id="构建邻接矩阵">构建邻接矩阵：</h3><p><code>lib =&gt; parser =&gt; nfa =&gt; build_edges函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;);<br>edges[起始点][终止点] = [边集合]，如果是epsilon，则是<span class="hljs-literal">null</span><br><span class="hljs-title function_">build_edges</span>() dfs + bfs + 集合去重<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   ======&gt; <span class="hljs-number">0</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">1</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, f, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">2</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">3</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">4</span><br>    [<br>       a,  b,  c, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>,<br>      <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>,<br>      <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>, <span class="hljs-number">113</span>, <span class="hljs-number">114</span>,<br>      <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z<br>    ],<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">5</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,======&gt; <span class="hljs-number">6</span><br>    [<br>       a,  b,  c, d, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>,<br>      <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>,<br>      <span class="hljs-number">113</span>, <span class="hljs-number">114</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">117</span>, <span class="hljs-number">118</span>, <span class="hljs-number">119</span>, <span class="hljs-number">120</span>,<br>      <span class="hljs-number">121</span>, z,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,<br>       <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span><br>    ],<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>  ],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">7</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],======&gt; <span class="hljs-number">8</span><br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]======&gt; <span class="hljs-number">9</span><br>]<br></code></pre></td></tr></table></figure><p>可以验证下就是如下节点边值对(行索引对应source节点，列索引对应target节点，矩阵值就是边集合)：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">2</span>: i<br><br><span class="hljs-symbol">1 </span>=&gt; <span class="hljs-number">4</span>: null<br><br><span class="hljs-symbol">2 </span>=&gt; <span class="hljs-number">3</span>: f<br><br><span class="hljs-number">4</span>=&gt;<span class="hljs-number">5</span>: [a-z]<br><br><span class="hljs-number">5</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">6</span>=&gt;<span class="hljs-number">7</span>: [a-z] [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br><br><span class="hljs-number">7</span>=&gt;<span class="hljs-number">8</span>: null<br><br><span class="hljs-number">8</span>=&gt;<span class="hljs-number">6</span>: null<br></code></pre></td></tr></table></figure><h3 id="根据邻接矩阵构建dfa">根据邻接矩阵构建dfa</h3><p><span class="math display">\[Closure(S):S的可达闭包，表示从集合S出发，无需接受任何字符，即只通过epsilon边即可到达的状态组成的集合\\Closure(S) = S \cup(\bigcup_{m\in{S}}edge(m, \epsilon))，其中edge(m, \epsilon)\\表示从状态m出发沿着边c可到达的所有NFA状态的集合\]</span></p><p><span class="math display">\[假设状集合有如下几个状态：S=\{m, n, k\} \\从S的状态出发，沿着某条边c可到达的新的状态集合，表示为DFAedge(S, c) \\DFAedge(S, c) = Closure(\bigcup_{k\in{S}}edge(k, c))\]</span></p><p>有了Closure和DFAedge算法单元，这样从NFA的起点出发，不断的更新DFAedge(S,c)，每次新生成的DFAedge(S,c)，即得到DFA里的状态节点，据此得到dfa状态转移表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">states<span class="hljs-selector-attr">[0]</span> &lt;- <span class="hljs-selector-attr">[]</span> <br>states<span class="hljs-selector-attr">[1]</span> &lt;- <span class="hljs-built_in">Closure</span>(<span class="hljs-selector-attr">[S]</span>)<br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-number">1</span>, j &lt;- <span class="hljs-number">0</span> <br>while j &lt;= <span class="hljs-selector-tag">p</span> <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> 字母集 <br>e &lt;- <span class="hljs-built_in">DFAedge</span>(states<span class="hljs-selector-attr">[j]</span>, c) <br><span class="hljs-keyword">if</span> e == states<span class="hljs-selector-attr">[i]</span> <span class="hljs-keyword">for</span> some <span class="hljs-selector-tag">i</span> &lt;= <span class="hljs-selector-tag">p</span> <br>then trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">i</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-selector-tag">p</span> &lt;- <span class="hljs-selector-tag">p</span> + <span class="hljs-number">1</span><br>states<span class="hljs-selector-attr">[p]</span> &lt;- e<br>trans<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[c]</span> &lt;- <span class="hljs-selector-tag">p</span><br>j &lt;- j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>构建完正则表达式之后就可以对我们的输入处理成token流了。(<code>lib =&gt; scan函数</code>)</p><h2 id="构建抽象语法树">构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,</p><p>理论上上下无关文法所代表的文法范围： LR(1) &gt; LSPR &gt; SLR &gt;LR(0) <strong>LR(0):</strong> 没有提前预测的符号，容易出现 shift-reduce冲突以及 reduce-reduce 冲突，所以需要设计适合的文法；<strong>SLR:</strong> 有简单的预测，可以用follow集解决部分shift-reduce冲突，但是在有些情况下还是 shift-reduce冲突 <strong>LR(1):</strong>可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突<strong>LSPR:</strong> 由于 LR(1)的表特别大，在此基础上做了优化</p><p>看如下文法的 LR(0)生成过程：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">E-&gt; Program $<br>P<span class="hljs-function"><span class="hljs-title">rogram</span> -&gt;</span> Assign == Assign<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Assign + Token<br>A<span class="hljs-function"><span class="hljs-title">ssign</span> -&gt;</span> Token<br>T<span class="hljs-function"><span class="hljs-title">oken</span> -&gt;</span> id<br></code></pre></td></tr></table></figure><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约。</p><p>slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><h2 id="五ast生成">五、AST生成</h2><p>生成好分析表之后，就可以根据分析表进行语法分析了，如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><p>下图简单模拟了<code>int ID (int ID)</code>的token流处理过程，<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/stack.gif" class="" title="这是一张图片">在没有规约动作的时候token一直push进栈，直到有对应的规约动作，这个时候按照指定的规约动作，生成非终结符，再把该非终结符放入栈内，重复进行，直到栈内为空或者遇到了$，当然，如果在这过程中遇到了不合法的字符，直接抛出异常</p><p>以及生成的简单ast如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Program</span>_Class &#123;<br>  <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>    <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>    <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Branch</span>_Class &#123;<br>      <span class="hljs-attr">ifCond</span>: <span class="hljs-title class_">Cond</span>_Class &#123;<br>        <span class="hljs-attr">lExpr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>        <span class="hljs-attr">rExpr</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;0&#x27;</span> &#125;,<br>        <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;==&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">statementTrue</span>: <span class="hljs-title class_">Return</span>_Class &#123; <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125; &#125;,<br>      <span class="hljs-attr">statementFalse</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;m&#x27;</span>,<br>        <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>          <span class="hljs-attr">params_list</span>: [ <span class="hljs-literal">undefined</span> ],<br>          <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>          <span class="hljs-attr">params</span>: <span class="hljs-title class_">Sub</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;<br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>        &#125;,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>          <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>            <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;m&#x27;</span> &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;,<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>      <span class="hljs-attr">formal_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span> ],<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sum&#x27;</span>,<br>      <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Return</span>_Class &#123;<br>        <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Add</span>_Class &#123;<br>          <span class="hljs-attr">lvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>          <span class="hljs-attr">rvalue</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;y&#x27;</span> &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">formals</span>: <span class="hljs-title class_">Formal</span>_Class &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;y&#x27;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-title class_">Formal</span>_Class &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span> &#125;<br>      &#125;,<br>      <span class="hljs-attr">next</span>: <span class="hljs-title class_">Function</span>_Class &#123;<br>        <span class="hljs-attr">formal_list</span>: [],<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br>        <span class="hljs-attr">expressions</span>: <span class="hljs-title class_">Assign</span>_Class &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;x&#x27;</span>,<br>          <span class="hljs-attr">ltype</span>: <span class="hljs-string">&#x27;int&#x27;</span>,<br>          <span class="hljs-attr">r</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;10&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Int</span>_Contant_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;10&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;,<br>          <span class="hljs-attr">next</span>: <span class="hljs-title class_">Caller</span>_Class &#123;<br>            <span class="hljs-attr">params_list</span>: [ <span class="hljs-string">&#x27;x&#x27;</span> ],<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;print&#x27;</span>,<br>            <span class="hljs-attr">params</span>: <span class="hljs-title class_">Indentifier</span>_Class &#123; <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;x&#x27;</span> &#125;,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span><br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">formals</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">next</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>      &#125;,<br>      <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">return_type</span>: <span class="hljs-string">&#x27;int&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：遍历ast自上向下进行利用堆栈机代码生成，由于本语言比较简单，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cgenForSub(e1, e2) &#123;<br>cgen(e1)<br>sw <span class="hljs-variable">$a0</span>, 0(<span class="hljs-variable">$29</span>)<br>addiu <span class="hljs-variable">$29</span>, <span class="hljs-variable">$29</span>, -4<br>cgen(e2)<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$a0</span>, <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$a0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用域获取变量，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="/emocoder/2023/05/05/node%E4%BB%8E%E5%A4%B4%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8/%E9%A3%9E%E4%B9%A620230502-104729.jpg" class="" title="这是一张图片"></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h3 id="项目踩坑点">项目踩坑点</h3><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npm linktypescript，再运行即可</li></ol><h3 id="项目难点">项目难点</h3><p>其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li></ol><h3 id="参考文章">参考文章</h3><p><ahref="https://blog.csdn.net/qq_42977003/article/details/112341427">LL1文法、LR(0)文法、SLR文法、LR(1)文法、LALR文法_不积硅步的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/77663680">栈和栈帧 - 知乎(zhihu.com)</a></p><p><ahref="https://www.cnblogs.com/henuliulei/p/10872483.html">LL(1),LR(0),SLR(1),LALR(1),LR(1)对比与分析- 你的雷哥 - 博客园 (cnblogs.com)</a></p><p><ahref="https://wangwangok.github.io/2020/05/05/bottom2top_syntax_parser_lalr/#:~:text=“规范LR”">语法分析——自底向上语法分析中的规范LR和LALR· 凌云壮志幾多愁 (wangwangok.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理，计算机基础, node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git多账号管理</title>
    <link href="/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <url>/emocoder/2023/05/05/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>为什么提交了代码并推送到github，但是github上的contributions并没有增加呢？</p><p>其中Github官方给出了一个官方文件，告诉我们什么样的Commit可以被记入Contribution，请点击此处查看。</p><p>在官方的帮助文档中，有一条是Commit被记入Contribution中必须满足用于Commit的邮件地址必须与Github账户相关联。其实，这也是为什么我的Commit没有被记入Contribution和不显示头像的原因，也是大多数人也是这个原因</p><p>https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/why-are-my-contributions-not-showing-up-on-my-profile</p><p>我遇到的问题的解决方案是：该仓库的本地的邮箱和github账户的邮箱不是同一个配置：可以修改本地仓库的邮箱和github上一致：git config --local user.name 张三 git config --local user.emailzhansan@996icu.com</p><p>如果拿到一台公司电脑, 那么就请按照下面的最佳实践配置下git的多环境:请先执行命令打开配置文件 vi ~/.ssh/config</p><p>然后输入以下内容： # gitlab Host gitlab User git HostNamegitlab.company.com PreferredAuthentications publickey IdentityFile~/.ssh/gitlab_rsa ServerAliveInterval 300 ServerAliveCountMax 10 #github Host github User git HostName github.com PreferredAuthenticationspublickey IdentityFile ~/.ssh/github_rsa ServerAliveInterval 300ServerAliveCountMax 10</p><p>这里唯一需要替换的gitlab里的HostName部分, 改成你们公司的git地址.</p><p>遇到GitHub报permission denied错就执行：ssh-add -k ~/.ssh/github_rsa遇到gitlab报permission denied错就执行：ssh-add -k ~/.ssh/gitlab_rsa</p><p>推荐阅读：https://zhuanlan.zhihu.com/p/62071906</p>]]></content>
    
    
    <categories>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github, git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/emocoder/2023/05/05/minic/"/>
    <url>/emocoder/2023/05/05/minic/</url>
    
    <content type="html"><![CDATA[<h1 id="node-手写编译器-minicompiler">node 手写编译器-minicompiler</h1><p>使用语言：node, C++本文涉及：编译器的词法分析，抽象语义树生成，语法分析，代码生成本文重点内容：</p><ol type="1"><li>实现正则表达式分析器</li><li>实现简易版 Flex</li><li>实现 LR0 语法，并简单介绍其他语法(LL, LR1, SLR, LSPR)</li><li>实现简易版 Bison</li><li>实现生成汇编代码</li><li>实现简易编译器功能，提供编译时期类型检查和推断，支持加减乘除支持函数的递归调用，以及</li></ol><p>会包含的：</p><ol type="1"><li>实现 nfa，以及联合 nfa =&gt; dfa，进行词法分析</li><li>实现 dfa，进行语法分析，并基于此构建抽象语法树(AST)</li><li>基于 ast 进行语言义分析(类型检查以及是否符合语言规范)</li><li>基于 ast生成汇编代码，虽然本文没有显示的终中间代码生成过程，但是也有类似的思想</li></ol><p>不会包含的：本语言比较简单，不包含复杂数据结构的支持，如数组对象等其他功能；不会涉及复杂的编译器后端知识：如垃圾回收，寄存器染色，数据流分析等等</p><p>minic 语法：</p><ol type="1"><li>运算符：支持+-*/运算，不支持优先级(, )</li><li>类型：支持自然数(int 类型)，字符串，布尔值以及 void</li><li>语句：支持函数调用，嵌套的 if-else语句（if-else必须成对出现，如下的语法是不允许的）</li><li>和 C 一样，必须要有 main 函数</li><li>变量必须声明的时候同时赋值，如下的声明是不允许的</li><li>允许块级作用域</li><li>允许返回值是条件表达式，运算表达式</li><li>运算符左右两侧仅可以是变量或是数字</li></ol><h2 id="一minic-语法">一、minic 语法：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">feb</span><span class="hljs-params">(x: <span class="hljs-type">int</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + feb(x<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我会从以下四个方面依次入手：</p><ol><li>parser</li><pre><code class="hljs">&lt;ul&gt;&lt;li&gt;正则&lt;/li&gt;&lt;li&gt;todo&lt;/li&gt;&lt;/ul&gt;</code></pre><li>sematic</li><ul><li>slr</li><li>语义分析</li><li>todo</li></ul><li>代码生成</li><li>可视化</li><h2 id="二parser">二、parser</h2><p>在词法分析阶段，输入是字符串，输出是 token 流，这里 token流有一个坑，一开始我的输出是枚举值的数组，类似这样:<code>[TYPE, ID, BRACE, ...]</code>，但是这样会有问题，因为词素值没办法保留下来，所以后面改成了如下输出:<code>[(line_num, TYPE, int), (line_num, ID, feb)]</code>，(行号，类型,词素值)三元组 学过编译原理都知道，需要有自动机把输入流，转成一个个token，比如当词法分析器读完 int 的时候，这时候就会返回一个 TYPEtoken，但是如果是 int1，就应该返回一个 IDtoken，所以这里涉及到贪婪读取，另外对于像 if这种关键字，如果同时满足多种终结状态，应该涉及到优先级</p><p>那么如何构建自动机？ 首先我们的目标是对每种特定的 token设置对应的正则表达式，并生成对应的 dfa，用过 flex的同学应该都知道，比如：</p><p>然后我们把这些 dfa 构建为一个大的 nfa，再把 nfa 转为 dfa</p><p>我们的词法分析器支持以下几个单元： +: a+, ?: a?, <em>: a</em>, 连接:ab， 逻辑或: a|b， 字符集: [a-z] 支持少部分字符转义：, t, </p><p>如何把正则表达式构建为dfa：对于每一个单元正则表达式，可以直接生成对应的节点，但是有些问题我们需要注意：我们的输入是一个个正则表达式，正则表达式本身可以理解为是一个个单元，而这些单元又可能是字符或者其他单元和成的，如：a|b 就是一个单元，但是其组成就是 2 个字符 [a-z]|a就是一个单元+一个普通字符另外对于中括号这种还需要特殊处理，思路如下：即使是字符也会抽象成节点的概念，另外在生成自动机的过程中，由于存在[]，+，*等等这样的修饰符号，考虑使用stack 进行存储，一般的，形式化如下：对于正则表达式 xxxxx 其中 X为可能的任意字符，<code>stack = []</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">0</span><br>pattern = <span class="hljs-string">&#x27;XXXX&#x27;</span><br><span class="hljs-keyword">while</span> (i &lt; len(pattern)) &#123;<br>  <span class="hljs-keyword">auto</span> node = getNode(pattern[i]);<br>  <span class="hljs-built_in">stack</span>.push(node);<br>&#125;<br><br>node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;]&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;+&#x27;</span>)<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getNode函数做的事请就是识别特定的符号，然后用对应的正则表达式函数生成即可，比如对于特殊的符号:[],需要收集其包含的字符集，然后构建一个如图的基本正则单元；再比如a+，我们需要从 stack 内 pop 出一个元素，生成对应的基本正则单元。</p><p>最后，所有的特殊符号处理完成，也就意味着栈内只有正则表达式单元这种数据结构，这些节点之间没有任何修饰符(因为修饰符之前都被处理完了，除了连接运算)，然后我们依次连接这些节点即可，另外对于每个正则的叶子节点确定，即当前栈顶元素的最后一个节点(因为栈顶元素对应正则的末尾)。</p><p>我们可以提供相应的函数，我们的词法分析器包含以下几种基本正则单元：</p><ol type="1"><li>连接运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs node">export function connect(from: VertexNode, to: VertexNode): VertexNode &#123;<br>  // from的尾和to的头相互连接,注意circle<br>  let cur = graph.getVertex(from.index); // 获取邻接表<br>  const memo: number[] = [];<br>  while (cur.firstEdge &amp;&amp; !memo.includes(cur.index)) &#123;<br>    memo.push(cur.index);<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br><br>  graph.getVertex(cur.index).firstEdge = new Node(<br>    to.index,<br>    graph.getVertex(cur.index).firstEdge<br>  );<br>  return from;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>逻辑或</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node">export function or(a: VertexNode, b: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  nodeStart.firstEdge = new Node(a.index, null, a.edgeVal || null);<br>  nodeStart.firstEdge.next = new Node(b.index, null, b.edgeVal || null);<br>  const nodeEnd = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeEnd, nodeEnd.index);<br>  connect(a, nodeEnd);<br>  connect(b, nodeEnd);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>字符集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node">export function characters(chars: string[]) &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const nodeEnd = new Node(Graph.node_id, null, chars);<br>  const tmp = new VertexNode(nodeEnd.index, chars);<br>  graph.addVertexNode(tmp, tmp.index);<br><br>  const pre = nodeStart.firstEdge;<br>  nodeStart.firstEdge = nodeEnd;<br>  nodeEnd.next = pre;<br><br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>*修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node">export function mutipliy(wrapped: VertexNode): VertexNode &#123;<br>  const nodeStart = new VertexNode(Graph.node_id, null);<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  const tmp = new Node(wrapped.index, null, null);<br>  nodeStart.firstEdge = tmp;<br>  let cur = graph.getVertex(wrapped.index); // 获取邻接表<br>  while (cur.firstEdge) &#123;<br>    cur = graph.getVertex(cur.firstEdge.index);<br>  &#125;<br>  connect(cur, nodeStart);<br>  return nodeStart;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>+修饰符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs node">export function plus(base: VertexNode) &#123;<br>  // 基于old新建节点<br>  let nodeStart = new VertexNode(Graph.node_id, base.edgeVal);<br>  nodeStart.firstEdge = base.firstEdge;<br>  const res = nodeStart;<br>  graph.addVertexNode(nodeStart, nodeStart.index);<br>  let cur = base?.firstEdge;<br>  while (cur) &#123;<br>    const vertexNode = graph.getVertex(cur?.index);<br>    const tmp = new VertexNode(Graph.node_id, vertexNode.edgeVal);<br>    nodeStart.firstEdge = new Node(tmp.index, null, vertexNode.edgeVal);<br>    nodeStart = tmp;<br>    tmp.firstEdge = base.firstEdge;<br>    graph.addVertexNode(tmp, tmp.index);<br>    cur = vertexNode.firstEdge;<br>  &#125;<br>  return mutipliy(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过比较困扰的是这些节点的数据结构如何存储是一件要考虑周到的事：需要节点id，由于自动机是有向图，并且可能带环，并且节点和节点之间可能存在不止一条边，考虑了下，还是用linjie表存储(主要是第一版的代码是这样的，再加上如果感觉节点之间的连接可能在某些情况下比较少，临界矩阵比较浪费内存)，firstEdge指向其所有的临界边，edgeVal 是边上的值，对于该图的搜索，使用bfs+dfs+检测环。 通过以上流程，我们得到了一个 nfa，由该 nfa可以得到各个节点的边，以及叶子节点(并且叶子节点上放置了相应的动作)</p><p>nfa =&gt; dfa:这一步使用的是虎书上的算法，这里不过多描述，简单来说就是把很多个大的 nfa联合构建成一个 dfa 从而得到一张状态转移表</p><h2 id="三构建抽象语法树">三、构建抽象语法树</h2><p>这里我用的是简单的LR(0)上下无关文法，关于什么是上下无关文什么是有关文，请戳-&gt;,理论上上下无关文法LR(1) &gt; LSPR &gt; SLR &gt; LR(0) LR(0): 没有提前预测的符号，容易出现shift-reduce 冲突以及 reduce-reduce 冲突，所以需要设计适合的文法； SLR:有简单的预测，可以解决 shift-reduce 冲突，但是无法解决 reduce-reduce冲突 LR(1): 可以解决 shift-reduce 冲突，也解决 reduce-reduce 冲突 LSPR:由于 LR(1)的表特别大，在此基础上做了优化</p><p>根据相应文法生成 ast，本质上是利用栈和 nfa，看如下文法的LR(0)生成过程： E-&gt; Program $ Program -&gt; Assign == Assign Assign-&gt; Assign + Token Assign -&gt; Token Token -&gt; id</p><p>LR(0)dfa</p><p><img src="../飞书20230430-125517.jpg" /></p><p>LR(0)对应的状态转移表： <img src="../飞书20230430-124728.jpg" /></p><p>可以看到在状态 9 是存在移位-规约冲突的，这是因为LR(0)默认在所有的终结符号处做规约，slr 语法是比LR(0),更为广泛的一种语法，它只在特定的地方放置规约动作。具体来说，在上面的例子里，在状态9 处，只有规约式 1 的移位指针到达里末尾，所以可以看下规约式 1后面可能会紧接着什么符号，也就是 followSet(Program) ={$}，所以只在$处放置规约动作。 下面是 slr 分析表： <imgsrc="../飞书20230430-163301.jpg" /></p><p>有了这张表就可以基于输入(一般是 token流)去做语法分析了，刷过算法题的都应该猜到了会用栈来作为数据结果，是的，每一次自底向上规约都可以看作是栈的pop动作，并且在这次动作中可以做很多事情，比如生成我们想要的树节点，如：</p><p>在设计 AST 结构的同时需要同时兼顾到 AST的结构方便语义分析和代码生成，该语言的 ast 结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs node">Program_Class &#123;<br>  expr: Function_Class &#123;<br>    formal_list: [ &#x27;x&#x27; ],<br>    name: &#x27;total&#x27;,<br>    expressions: Branch_Class &#123;<br>      ifCond: Cond_Class &#123;<br>        lExpr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>        rExpr: Int_Contant_Class &#123; token: &#x27;0&#x27; &#125;,<br>        op: &#x27;==&#x27;<br>      &#125;,<br>      statementTrue: Return_Class &#123; expr: Indentifier_Class &#123; token: &#x27;x&#x27; &#125; &#125;,<br>      statementFalse: Assign_Class &#123;<br>        name: &#x27;m&#x27;,<br>        ltype: &#x27;int&#x27;,<br>        r: Caller_Class &#123;<br>          params_list: [ undefined ],<br>          id: &#x27;total&#x27;,<br>          params: Sub_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Int_Contant_Class &#123; token: &#x27;1&#x27; &#125;<br>          &#125;,<br>          next: undefined<br>        &#125;,<br>        next: Return_Class &#123;<br>          expr: Add_Class &#123;<br>            lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            rvalue: Indentifier_Class &#123; token: &#x27;m&#x27; &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    formals: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;,<br>    next: Function_Class &#123;<br>      formal_list: [ &#x27;x&#x27;, &#x27;y&#x27; ],<br>      name: &#x27;sum&#x27;,<br>      expressions: Return_Class &#123;<br>        expr: Add_Class &#123;<br>          lvalue: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>          rvalue: Indentifier_Class &#123; token: &#x27;y&#x27; &#125;<br>        &#125;<br>      &#125;,<br>      formals: Formal_Class &#123;<br>        name: &#x27;y&#x27;,<br>        type: &#x27;int&#x27;,<br>        next: Formal_Class &#123; name: &#x27;x&#x27;, type: &#x27;int&#x27;, next: undefined &#125;<br>      &#125;,<br>      next: Function_Class &#123;<br>        formal_list: [],<br>        name: &#x27;main&#x27;,<br>        expressions: Assign_Class &#123;<br>          name: &#x27;x&#x27;,<br>          ltype: &#x27;int&#x27;,<br>          r: Caller_Class &#123;<br>            params_list: [ &#x27;10&#x27; ],<br>            id: &#x27;total&#x27;,<br>            params: Int_Contant_Class &#123; token: &#x27;10&#x27; &#125;,<br>            next: undefined<br>          &#125;,<br>          next: Caller_Class &#123;<br>            params_list: [ &#x27;x&#x27; ],<br>            id: &#x27;print&#x27;,<br>            params: Indentifier_Class &#123; token: &#x27;x&#x27; &#125;,<br>            next: undefined<br>          &#125;<br>        &#125;,<br>        formals: undefined,<br>        next: undefined,<br>        return_type: &#x27;int&#x27;<br>      &#125;,<br>      return_type: &#x27;int&#x27;<br>    &#125;,<br>    return_type: &#x27;int&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其树节点是各种表达式类，源码在 tree.ts 文件里，</p><p>follow集和first集生成： follow集： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs node">_processFollow(_nts: string) &#123;<br>  // 3 若存在一个表达式 X -&gt; ABCD 则 Follow(A) 需要加上 First(B) - ε，若First(B) 包含 ε，则Follow(A) 需要加上 First(C) - ε，向右迭代... 迭代至表达式结束。<br>  for (const nts of this.nonTerminalSymbol) &#123;<br>    for (let grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    <br>      const len = grammarArr.value.length;<br>      let index = -1;<br>      // 找到 B<br>      for (let i = 0; i &lt; len; i += 1) &#123;<br>        const ch = grammarArr.value[i];<br>        if (ch === _nts) &#123;<br>          index = i;<br>          break;<br>        &#125;<br>      &#125;<br>      if (index === -1) continue;<br>      while (index + 1 &lt; len) &#123;<br>        const ch = grammarArr.value[index + 1];<br>        if (this.terminalSymbol.has(ch)) &#123;<br>          // 终结符直接加入<br>          this._followSet[_nts].add(ch);<br>          break;<br>        &#125; else &#123;<br>          const set = this._firstSet[ch];<br>          for (const v of Array.from(set || []))<br>            if (v !== EMPTY) this._followSet[_nts].add(v);<br>          if (!set?.has(EMPTY)) break;<br>          index += 1;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>startBuildFollowSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    this._followSet[nts] = new Set();<br>  &#125;<br>  this._followSet[START].add(END);<br>  while (true) &#123;<br>    let flag = false;<br>    for (let nts of this.nonTerminalSymbol) &#123;<br>      this._processFollow(nts);<br>      if (isEqual(prevFollowSet, this._followSet)) flag = true;<br>      else flag = false;<br>      prevFollowSet = cloneDeep(this._followSet);<br>    &#125;<br>    if (flag) break;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs node">// 求firset集这里做了点改动，一般需要手动消除左递归文法，这里在代码里如果遇到了左递归直接结束<br>_processFirst(nts: string, memo: Set&lt;string&gt;) &#123;<br>  memo.add(nts);<br>  for (const grammarArr of this.lfh2rfh.get(nts)) &#123;<br>    const len = grammarArr.value.length;<br>    for (let i = 0; i &lt; len; i += 1) &#123;<br>      const ch = grammarArr.value[i];<br>      if (this.terminalSymbol.has(ch)) &#123;<br>        this._firstSet[nts].add(ch);<br>        break;<br>      &#125; else &#123;<br>        if (i === 0 &amp;&amp; ch === nts) &#123;<br>          // 避免左递归<br>          break;<br>        &#125;<br>        if (memo.has(ch)) &#123;<br>          // 避免循环递归<br>          break;<br>        &#125;<br>        <br>        this._processFirst(ch, memo);<br>        for (const v of this._firstSet[ch]) this._firstSet[nts].add(v);<br>        if (!this._firstSet[ch].has(EMPTY)) break;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>startuildFirstSet() &#123;<br>  for (let nts of this.nonTerminalSymbol) this._firstSet[nts] = new Set();<br>  for (let nts of this.nonTerminalSymbol) &#123;<br>    const memo = new Set([]);<br>    this._processFirst(nts, memo);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五ast生成">五、AST生成</h2><p>如下所示，在提前定义好的文法产生式做对应的规约动作，如下case0就是<code>Formals -&gt; int,TOKEN.ID</code>，在这里利用栈内的元素生成Formal_Class；就这样每次在对应的文法产生式上对对应的做规约动作，从而完成自底向上的ast的构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">[Formals -&gt; int, TOKEN.ID]: 0,<br>[Formals -&gt; Formals, &#x27;,&#x27;, int, TOKEN.ID]: 1<br><br>case 0:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2]);<br>  break;<br>case 1:<br>  res = new Formal_Class(yyvalsp[0][2], yyvalsp[1][2], yyvalsp[3]);<br>  break;<br><br></code></pre></td></tr></table></figure><h2 id="六语义分析">六、语义分析</h2><p>在语义分析阶段可以做类型检查和基本的校验，这里放置了一些基本的类型检查动作：1. 必须要有main函数，main函数的返回值必须是整形 2.其他函数的返回值和实际返回值类型对应 3. 赋值语句左右两侧类型一致 4.同一个作用域不得出现同名变量 5. 变量必须先声明并初始化才能使用</p><h2 id="七汇编代码生成">七、汇编代码生成</h2><p>思路：自上向下进行利用堆栈机代码生成，仅使用了3个寄存器，a0，v0，t0，其中v0是辅助寄存器帮助函数返回值存储以及系统调用的退出和打印；总结了下，最重要的点是对声明变量的内存分配以及取变量的时候，要知道对应的作用域链，该从哪个作用取，只要我们对基本的一些单元表达式做好了代码生成的工作，后面就是搭积木的工作了；下面是该语言的函数栈示意图：<img src="../飞书20230502-104729.jpg" /></p><p>这里如何取参数？由于函数栈在扩增的时候，不太方便通过sp指针获取参数和变量的存储位置，所以这里使用fp指针去作为基地址，寻找参数和局部变量</p><p>关于作用域问题是采用的树结构存储(双向链表)，每次从当前所在作用域内寻找变量，再继续依次向上寻找，直到找到函数级作用域；</p><p>以下是具体的几个单元表达式生成的例子：</p><p>a + b lw $a0 局部 or 参数 / li $a0, imm sw $a0, 0($29) addiu $29,$29, -4 lw $a0 局部 or 参数 / li $a0, imm add $a0, $t0, $a0</p><p>对于int x = 2，直接用li命令存储，并在函数的局部变量处向函数栈内放置元素; 对于int x = a + b,先利用a+b元表达式生成对应的代码，再用lw指令存储单元表达式的值，</p><h2 id="八编写代码高亮语法插件">八、编写代码高亮语法插件：</h2><p>我这里是速成版，比较简单，只涉及简单的语法部分 需要安装：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g vsce<br>$ npm <span class="hljs-keyword">install</span> -g yo<br></code></pre></td></tr></table></figure></p><p>如果是需要编写全新的插件，则允许： yo code 选择 new LanguageSupport，提示一些问题，按需填写即可，插件名称尽可能唯一，不然在插件市场里不好搜，运行完命令之后会有一个生成目录，编写高亮语法的文件在xxx.tmLanguage.json 文件里，如果你只是配置一个 VS Code中已有语言的语法，记得删掉生成的 package.json 中的 languages 配置。</p><p>https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/docs-language-extensions-syntax-highlight-guide.md#fu57uu(编写插件vscode)</p><p>这里看下我的规则：</p><p>以及vscode里的settings.json文件： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;[Default Dark+]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 这里是自己所选择的主题颜色，我的是vscode默认的颜色</span><br>    <span class="hljs-attr">&quot;textMateRules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;identifier.name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义或者符合标准规范的命名，对应插件里的xxx.tmLanguage.json文件里的name选项</span><br>        <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#33ba8f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#eb8328&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>xxx.tmLanguage.json里的配置： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;minic&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#keywords&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#type&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#number&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#id&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#comment&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support.type.primitive.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(void|int|bool)\\b&quot;</span> <span class="hljs-comment">// 类型</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword.control.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b(if|while|for|return|else)\\b&quot;</span> <span class="hljs-comment">// 关键字</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant.numeric.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[0-9]+\\b&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;id.name.mc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;\\b[a-z][a-z0-9]*\\b&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment.line.double-dash&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^//.*&quot;</span> <span class="hljs-comment">//注释</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scopeName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;source.mc&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>踩坑点：</p><ol type="1"><li><p>因为是根据分词 token那一套来的，其实也就是对你的语言的文件后缀名，比如我这里是 mc后缀，会做一个词法分析，词法分析的正则是自己编写的，然后每个正则也有对应的name，vscode 在配置(setting.json 文件)里可以根据这些 name做颜色的映射。所以一定要记得简单的正则要在两边加\b\b，表示单词分界，我一开始没加这个总是不生效</p></li><li><p>关于 name的命名，其实有一套规范的标准，当然也可以随心自定义，我这里的？？？就是自定义的。</p></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> myExtension<br><span class="hljs-variable">$</span> vsce package<br><span class="hljs-comment"># 生成 myExtension.vsix,这时候本地可以看到一些二进制插件文件</span><br><span class="hljs-variable">$</span> vsce publish<br><br></code></pre></td></tr></table></figure><p>如果以前没有 vscode 插件市场的账户需要注册https://code.visualstudio.com/api/working-with-extensions/publishing-extension注册完之后，记得本地保存下密钥，因为会经常用的</p><p>取消发布的插件： vsce unpublish -p 密钥 包 id 包 id 可以在 vscode的对应插件的信息里可以看到，(一般点击插件的设置图标就可以看到包 id选项)</p><p>TextMate 语法最好对正则比较熟悉 具体的详细资料：https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map</p><p>https://macromates.com/manual/en/language_grammars#naming-conventions（TextMate语法规则）https://macromates.com/manual/en/regular_expressions（相关正则）</p><h2 id="九前端可视化">九、前端可视化</h2><p>canvas</p><p>项目踩坑点：</p><ol type="1"><li>我本地全局和项目下都是安装了 ts-nodede1，但是通过 npm runts-node，就是起不起来：Cannot find module'typescript'，后来在https://github.com/TypeStrong/ts-node/issues/707，好像是版本的问题，找到了最好的解决方案：npmlink typescript，再运行即可</li></ol><p>项目难点：其实整个项目是在学习斯坦福编译原理的时候有顺便一起写的，写下来也挺累的，因为已经在工作了，在编写本项目前，也看了下斯坦福的cool 源码，然后了解了下 bison 和flex，顺便对照了了下虎书的伪代码，下面总结下一些比较重要或者困难的点：</p><ol type="1"><li><p>正则表达式部分，这一部分纯粹自己手写，代码设计可能看着有点邋遢，主要思想是借鉴虎书上的，虎书只画了几个图，也没有给伪代码，主要是怎么设计nfa的节点相关数据结构存储，一个是是用简单的链表，后面发现可能存在出度为多个的节点，就换用邻接表存储了，每个节点的信息包含了所有入度边的信息；其次正则表达式分析这里用的也是stack 对正则表达式进行分析，栈内的元素可能是节点也可能是字符串，在每次pop的时候需要注意对当前出栈的节点进行遍历拿到头尾节点，方便节点之间的连接。然后是将各个nfa 联合成一个大 nfa 的过程，采用 dfa + bfa + 备忘录 + 回溯；最好是将nfa =&gt; dfa 的过程，这一部分参照伪代码的，应该没啥大问题；</p></li><li><p>ast 生成部分：这一步文法分析表生成是参照伪代码的，后面的 ast生成过程是纯手写，其实在实现的过程中，也发现整个过程和 bison 的 yy文件如出一辙，不知道 bison 是怎么实现的 😯，本来是想弄成简单的 bison文件编写文法规则的，但是时间不允许，后面再抽空看下。ast生成这一部分主要是在规约动作上放置一些用户定义动作，这里就是写死的生成对应文法表达式的类，自底向上构建ast</p></li><li><p>这比一部分理论其实挺多的，但是在本项目里只要考虑周到即可，防止在编译的最好阶段报错，也是纯手写的</p></li><li><p>汇编生成部分：这一部分个人觉得最恶心了，因为汇编比较难调试，每次有bug都需要汇编语句一句一句看，其实回过头看，这样把元表达式（像+-<em>/赋值语句）的寄存器分配设计写好了，就可以拿它们组合成更大的原件。这里也是纯手写的，有一个比较困扰我的点，像if-else里面声明的变量如何在运行时候分配内存？我们都知道局部变量在不考虑用寄存器优化的情况下，一般都是存储在栈内的，像参数都是基于fp(栈指针)进行寻址的，比如形式参数 x,y，在生成汇编的时候就要记录，这里我拿数组的[x, y]，这样 x 的偏移量就是fp + 1 </em> 4, y 就是 fp + 2 * 4，但是像 if else里面的声明的变量只有运行到对应的分支才能分配内存，也就是说另一个没有执行的分支是不需要分配内存的。</p></li><li><p>前端部分：用的是原生 canvas，主要是平时工作很少用canvas，之前学过，不用就忘，顺便学习下，主要是整个 canvas类的设计吧。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/emocoder/2023/02/27/hello-world/"/>
    <url>/emocoder/2023/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/emocoder/2023/02/27/My-New-Post/"/>
    <url>/emocoder/2023/02/27/My-New-Post/</url>
    
    <content type="html"><![CDATA[<p>你好</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
